<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java为啥计算时间从1970-1-1开始</title>
      <link href="/posts/8a25b5de/"/>
      <url>/posts/8a25b5de/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p>Java中计算开始时间是从1970年1月1日开始的，但是为什么从1970年开始呢？其他语言也是从1970年1月1日开始么？</p><h1 id="java时间计算起点"><a class="markdownIt-Anchor" href="#java时间计算起点"></a> Java时间计算起点</h1><p>我们都知道，在Java中执行下面的代码会打印<code>Thu Jan 01 08:00:00 CST 1970</code>(系统时区设置为UTC+08:00-也就是北京时间) (如果设置为UTC世界时则会打印<code>Thu Jan 01 00:00:00 CST 1970</code>)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Date(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>为什么这个时间会定义在1970 年 1 月 1 日这个时候呢 ?<br />一番百度+Google，得到了以下答案：</p><blockquote><p>java 起源于 UNIX 系统，而 UNIX 认为 1970 年 1 月 1 日 0 点是时间纪元，所以java也遵循unix的这套时间系统。</p></blockquote><p>哪UNIX为什么要以1970 年 1 月 1 日 0 点为时间纪元呢？<br />其实原因也很简单，是因为当初的操作系统都是32位的，所以时间也是用32位来表示的。所以所能表示的最大值就是<code>2^32-1=2147483647</code>。也就是<code>2147483647/(365 * 24 * 60 * 60)=68.1</code>年。而当时最早的unix操作系统是由AT&amp;T贝尔实验室的三位科学家在1969年开发的，所以当时他们为了让时间尽可能的多利用起来，便用了下一年，即1970年1月1日作为开始。所以目前32位系统的时间最多能支撑到2038年1月19日3时14分7秒。到了这一天的凌晨3点14分8秒，时间表示就会因为溢出变为1901年12月13日20时45分52秒。这样便会出现时间回归的现象，会导致很多问题，所以还是要早点更新到64位操作系统。在64位操作系统中，系统可以表示到292,277,026,596年12月4日15时30分08秒。肯定是够够的了。</p><p>到这里java为啥从1970年1月1日开始的问题算是解答了，其他的语言其实也都遵循unix的这套时间系统，所以都是从1970年1月1日开始的。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://en.wikipedia.org/wiki/Unix_time" target="_blank" rel="noopener">Unix time - wiki</a><br /><a href="https://www.cnblogs.com/Jack47/p/unix-time-date-episode.html" target="_blank" rel="noopener">关于计算机中时间的科普和八卦</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 1970 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL LEFT JOIN 只取被关联表中一条数据</title>
      <link href="/posts/29a14022/"/>
      <url>/posts/29a14022/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>最近遇到一个需求，需要查询被关联表中最新的一条数据，在此记录一下。</p><h1 id="创建表和初始化数据"><a class="markdownIt-Anchor" href="#创建表和初始化数据"></a> 创建表和初始化数据</h1><p>比如我有两个表，用户表（user）、用户登录记录表(user_login_log)。现在需要查询用户并同时带出他最近的登录记录。</p><p>下面是初始化SQL</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">VARCHAR</span> (<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_login_log`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`user_id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`login_time`</span> <span class="built_in">TIMESTAMP</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'登录时间'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">'zhangsan'</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">'lisi'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user_login_log`</span> (<span class="string">`id`</span>,<span class="string">`user_id`</span>,<span class="string">`login_time`</span>) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">'1'</span>,<span class="string">'2020-01-01 12:58:30'</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">'1'</span>,<span class="string">'2020-01-02 12:58:30'</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">'1'</span>,<span class="string">'2020-01-03 12:58:30'</span>);</span><br></pre></td></tr></table></figure><h1 id="使用group-by"><a class="markdownIt-Anchor" href="#使用group-by"></a> 使用GROUP BY</h1><p>首先想到的就是GROUP BY ，看下面SQL</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`user`</span> u</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(login_time), <span class="keyword">id</span> <span class="keyword">AS</span> log_id,user_id</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`user_login_log`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id</span><br><span class="line">) l <span class="keyword">ON</span> u.id = l.user_id;</span><br></pre></td></tr></table></figure><p>下面是执行结果：<br /><img alt='执行结果' src='https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/mysql-left-join-orderby/1.png' align='left'/></p><p>初一看好像结果是对的，再仔细看log_id字段，按照想法应该是最后一条记录的ID(3)才对呀 [捂脸]。</p><p>查了一下资料，发现MySQL的GROUP BY 默认会保留“最先搜索出来的一条数据”<br />这样子的话，我又对SQL进行了改造：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`user`</span> u</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`user_login_log`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> login_time <span class="keyword">DESC</span>)temp <span class="keyword">GROUP</span> <span class="keyword">BY</span> temp.user_id</span><br><span class="line">) l <span class="keyword">ON</span> u.id = l.user_id;</span><br></pre></td></tr></table></figure><p>一执行，结果和刚才一模一样。[-_-||]</p><p>再查询了资料：根据MySQL手册，在MySQL5.7中，如果不加LIMIT，系统会把ORDER BY优化掉(MySQL5.5或之前不会)。再修改SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`user`</span> u</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`user_login_log`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> login_time <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10000</span>)temp <span class="keyword">GROUP</span> <span class="keyword">BY</span> temp.user_id</span><br><span class="line">) l <span class="keyword">ON</span> u.id = l.user_id;</span><br></pre></td></tr></table></figure><p>这样子终于行了：<br /><img alt='执行结果' src='https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/mysql-left-join-orderby/2.png' align='left'/></p><p>但是看着那个LIMIT 10000 很不爽，还有没有其他的方式呢，下面我们看看另外的方式。</p><h1 id="其他的方式"><a class="markdownIt-Anchor" href="#其他的方式"></a> 其他的方式</h1><p>在我不断的查询资料下，在<a href="https://stackoverflow.com/questions/6879391/mysql-join-with-limit-1-on-joined-table/24442655" target="_blank" rel="noopener">StackOverflow</a>看到了另外一种方案：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`user`</span> u</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">`user_login_log`</span> l <span class="keyword">ON</span> l.id=(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> <span class="string">`user_login_log`</span> <span class="keyword">WHERE</span> u.id=user_Id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> login_time <span class="keyword">DESC</span>  <span class="keyword">LIMIT</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>执行了一下也符合预期。</p><p>OK，这个问题就先到这里了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握手四次挥手</title>
      <link href="/posts/627d7c1/"/>
      <url>/posts/627d7c1/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><h2 id="tcp报文首部格式介绍"><a class="markdownIt-Anchor" href="#tcp报文首部格式介绍"></a> TCP报文首部格式介绍</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/tcp-three-handshakes-four-waves/1.png"  alt="TCP报文首部格式" /></p><ul><li>源端口和目的端口（Source Port和Destination Port）：分别占用2个字节，用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接。</li><li>序号seq（Sequence Number）：占4个字节，用来标识从TCP发端向TCP收端发送的数据字节流（tcp传输的每一个字节都按顺序编号），它表示在这个报文段中的的第一个数据字节在数据流中的序号。主要用来解决网络报乱序的问题。</li><li>确认号ack（Acknowledgment Number）：占4个字节，确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志为1时该确认序列号的字段才有效。主要用来解决不丢包的问题（确认序号减去上次收到的序号等于本段收到的报文的长度）。</li><li>数据偏移（Offset）：占4个bit，指出tcp报文段的数据起始处距离tcp报文段的起始有多远，这个字段实际指出Ttcp报文段的首部长度。需要这个值是因为任选字段的长度是可变的，它用来表示首部中32bit（4字节）字的数目，因此最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节。</li><li>保留：占6bit。</li><li>TCP Flags：TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：</li><li>紧急URG：当URG = 1时，表示TCP包的紧急指针域有效，告诉系统这个报文段中有紧急数据，应当尽快传输。</li><li>确认ACK：TCP应答号将会包含在TCP数据包中，有两个取值：0和1，为1的时候表示应答域有效，反之为0。</li><li>推送PSH：这个标志位表示Push操作，接收方tcp收到PSH = 1的报文段，就尽快交付给接收接收应用进程而不是再等到这个缓冲区都填满之后再向上交付。</li><li>复位RST：表示连接复位请求，当RST = 1，标明tcp有严重的错误，必须释放连接，重新建立运输连接。RST = 1还可以用来拒绝一个非法的报文段或者拒绝打开一个连接。</li><li>同步SYN：表示同步序号，用来建立连接，SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手。</li><li>终止FIN： 表示发送端已经达到数据末尾，将释放一个连接，FIN = 1， 表示报文段的发送方的数据已经发送完成，请求释放连接。</li><li>窗口：占2个字节，存放的是数据是字节为单位的窗口值告诉对方，本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。这是让发送方设置发送窗口的依据。</li><li>检验和，占2个字节。</li></ul><h2 id="三次握手四次挥手重要概念"><a class="markdownIt-Anchor" href="#三次握手四次挥手重要概念"></a> 三次握手，四次挥手重要概念</h2><p>要理解三次握手，四次挥手，首先要理解一下几个重要概念：同步SYN、确认ACK、序号seq、确认号ack、终止FIN5。</p><ul><li>同步SYN：在连接建立时用来同步序号，当SYN=1而ACK=0时，表明这是一个连接请求报文，对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1，SYN置1就表示这是一个连接请求或连接接受报文。</li><li>确认ACK：TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。</li><li>序号seq：标识从TCP发端向TCP收端发送的数据字节流（tcp传输的每一个字节都按顺序编号），它表示在这个报文段中的的第一个数据字节在数据流中的序号。</li><li>确认号ack：确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志为1时该确认序列号的字段才有效。</li><li>终止FIN：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。</li></ul><h1 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h1><p>TCP协议中，主动发起请求的一端称为『客户端』，被动连接的一端称为『服务端』。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/tcp-three-handshakes-four-waves/2.png"  alt="三次握手" /></p><p>刚开始的时候，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。</p><p>服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。</p><ol><li><p>第一次握手<br />客户端向服务端发送连接请求报文段。该报文段的头部中同步SYN=1，确认ACK=0，同时选择一个初始序号seq=x。请求发送后，客户端便进入SYN-SENT状态。</p><ul><li>SYN=1，ACK=0表示该报文段为连接请求报文</li><li>x为本次TCP通信的字节流的初始序号</li><li>TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号</li></ul></li><li><p>第二次握手<br />服务端收到连接请求报文段后，如果同意连接，会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。发送完应答后服务端进入SYN-RCVD状态。</p><ul><li>SYN=1，ACK=1表示该报文段为连接同意的应答报文</li><li>seq=y表示服务端作为发送者时，发送字节流中的第一个字节序号</li><li>ack=x+1表示服务端希望客户端发送的下一个数据报初始序号是从x+1开始</li></ul></li><li><p>第三次握手<br />客户端收到服务端连接同意的应答后，还会向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。该报文段的头部为：ACK=1，seq=x+1，ack=y+1。</p></li></ol><p>客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！</p><h2 id="tcp建立连接为什么是三次握手而不是两次或四次"><a class="markdownIt-Anchor" href="#tcp建立连接为什么是三次握手而不是两次或四次"></a> TCP建立连接为什么是三次握手，而不是两次或四次？</h2><p>首先应该清楚一点：不论握手多少次都不能确认一条信道一定是“可靠”的，但通过3次握手可以至少确认它是“可用”的，再往上加握手次数不过是提高它是“可用”的这个结论的可信度。</p><p>也就是说任意次的握手都是“不可靠”的，握手成功只能说明握手时的通信是正常的，并不能保证握手后的通信是正常的。握手只能保证尽可能的可靠，而不可能保证绝对可靠。</p><h3 id="那为什么不是两次握手"><a class="markdownIt-Anchor" href="#那为什么不是两次握手"></a> 那为什么不是两次握手？</h3><p>是为了防止已失效的连接请求报文段突然又传送到了服务端，造成服务端资源的浪费。</p><p>这句话怎样理解？</p><p>在一次TCP连接中，客户端A向服务端B发送连接请求SYN报文段，假如这个报文段没有及时被服务端B接收，而是滞留在网络的某处，于是客户端A超时重传，再次发送请求连接并且顺利与服务端B建立了连接，交换数据后断开连接。</p><p>滞留在网络中的某处的陈旧报文就变成了失效的连接请求报文。</p><p>但如果这个失效的请求SYN报文段，现在又突然传送到了服务端B处，设想这时是使用两次握手而不是三次握手，服务端B就以为客户端A现在建立请求连接，于是服务端B发出确认，新的连接就建立了，服务端B分配资源，等待客户端A传送数据，但客户端A并没有想要建立TCP连接，不会理会服务端B发送的应答，也不会向服务端B传送数据，于是服务端B就白白等待，空耗资源。</p><p>使用三次握手可以避免这个情况。服务端B收到客户端A的失效的陈旧SYN报文段，向客户端A发送SYN报文段，选择自己的序号seq=y，确认收到客户端A的SYN报文段，确认号ack=x+1。第三次握手客户端A收到B的SYN报文段后，从确认号就可得知不应理睬这个SYN报文段（因为A现在并没有发送seq=x的报文段）。</p><p>这时，客户端A会发送复位报文段，这个复位报文段中，RST=1，ACK=1，确认号ack=y+1。</p><p>服务端B收到A的复位报文，就知道不建立TCP连接，不会分配资源等待A发送数据。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/tcp-three-handshakes-four-waves/3.png"  alt="两次握手导致的问题" /></p><h3 id="为什么不是四次握手"><a class="markdownIt-Anchor" href="#为什么不是四次握手"></a> 为什么不是四次握手？</h3><p>既然两次握手不可以，那四次握手，五次握手呢？</p><p>因为三次握手已经能说明握手时的通信是正常的，四次握手、五次握手就显得浪费了。</p><h1 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h1><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/tcp-three-handshakes-four-waves/4.png"  alt="四次挥手" /></p><p>TCP连接的释放一共需要四步，这也是四次挥手的由来。</p><p>TCP连接是双向的，在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。</p><ol><li><p>第一次挥手<br />客户端数据发送完成，则它向服务端发送连接释放请求。该请求只有报文头，头中携带的主要参数为：FIN=1，seq=u。此时，客户端将进入FIN-WAIT-1状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p><ul><li>FIN=1表示该报文段是一个连接释放请求</li><li>seq=u，u-1是客户端向服务端发送的最后一个字节的序号</li></ul></li><li><p>第二次挥手<br />服务器收到客户端连接释放报文，通知相应的高层应用进程，告诉它客户端向服务器这个方向的连接已经释放了。</p></li></ol><p>此时服务端进入了CLOSE-WAIT（关闭等待）状态，并向客户端发出连接释放的应答，其报文头包含：ACK=1，ack=u+1，并且带上自己的序列号seq=v。</p><ul><li>ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答</li><li>seq=v，v是服务端释放应答报文段第一个字节序号</li><li>ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节<br />客户端收到该应答后，进入FIN-WAIT-2状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li></ul><p>第二次挥手完成后，客户端到服务端方向的连接已经释放，服务端不会再接收客户端的数据，客户端也没有数据要发送了。但服务端到客户端方向的连接仍然存在，服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p><ol start="3"><li><p>第三次挥手<br />服务端将最后的数据发送完毕后，就向客户端发送连接释放报文，其报文头包含：FIN=1，ack=u+1，由于在CLOS-WAIT状态，服务端很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p></li><li><p>第四次挥手<br />客户端收到服务器的连接释放报文后，向服务端发出确认应答，报文头：ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。</p></li></ol><p>该状态会持续2MSL（最长报文段寿命）时间，这个期间TCP连接还未释放，若该时间段内没有服务端的重发请求的话，客户端就进入CLOSED状态，撤销TCB。</p><p>服务端只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p><h2 id="为什么客户端最后还要等待2msl"><a class="markdownIt-Anchor" href="#为什么客户端最后还要等待2msl"></a> 为什么客户端最后还要等待2MSL？</h2><p>第一：为了保证服务端能收到客户端的确认应答。</p><p>若客户端发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，服务端等待超时后就会重新发送连接释放请求，但此时客户端已经关闭了，不会作出任何响应，因此服务端就无法正常关闭。</p><p>第二：防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。</p><p>客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h2 id="tcp关闭连接是为什么是四次挥手"><a class="markdownIt-Anchor" href="#tcp关闭连接是为什么是四次挥手"></a> TCP关闭连接是为什么是四次挥手？</h2><p>关闭连接时，服务器收到客户端的FIN报文时，仅仅表示客户端不再发送数据了但是还能接收数据，并且服务端也未必全部数据都发送给对方了，所以服务端可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，服务端的ACK和FIN一般都会分开发送，从而导致多了一次。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.jianshu.com/p/4084a9397138" target="_blank" rel="noopener">TCP/IP–理解TCP三次握手和四次挥手</a><br /><a href="https://juejin.im/post/5c25dd5ff265da612b13aa90" target="_blank" rel="noopener">“三次握手，四次挥手”你真的懂吗？</a><br /><a href="https://www.jianshu.com/p/afdd3736c923" target="_blank" rel="noopener">TCP三次握手四次挥手</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见Bean映射工具分析评测</title>
      <link href="/posts/818596de/"/>
      <url>/posts/818596de/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>工作中，我们经常需要将对象转换成不同的形式以适应不同的api，或者在不同业务层中传输对象而不同分层的对象存在不同的格式，因此我们需要编写映射代码将对象中的属性值从一种类型转换成另一种类型。</p><p>进行这种转换除了手动编写大量的get/set代码，还可以使用一些方便的类库，常用的有apache的BeanUtils，spring的BeanUtils，cglib的BeanCopier。</p><h1 id="常见bean映射工具分析"><a class="markdownIt-Anchor" href="#常见bean映射工具分析"></a> 常见Bean映射工具分析</h1><h2 id="beanutils"><a class="markdownIt-Anchor" href="#beanutils"></a> BeanUtils</h2><p>apache的BeanUtils和spring的BeanUtils中拷贝方法的原理都是先用jdk中 <code>java.beans.Introspector</code>类的<code>getBeanInfo()</code>方法获取对象的属性信息及属性get/set方法，接着使用反射（<code>Method</code>的<code>invoke(Object obj, Object... args)</code>）方法进行赋值。apache支持名称相同但类型不同的属性的转换，spring支持忽略某些属性不进行映射，他们都设置了缓存保存已解析过的BeanInfo信息。</p><h2 id="beancopier"><a class="markdownIt-Anchor" href="#beancopier"></a> BeanCopier</h2><p>cglib的<code>BeanCopier</code>采用了不同的方法：它不是利用反射对属性进行赋值，而是直接使用ASM的<code>MethodVisitor</code>直接编写各属性的get/set方法（具体过程可见BeanCopier类的<code>generateClass(ClassVisitor v)</code>方法）生成class文件，然后进行执行。由于是直接生成字节码执行，所以<code>BeanCopier</code>的性能较采用反射的<code>BeanUtils</code>有较大提高，这一点可在后面的测试中看出。</p><h2 id="dozer"><a class="markdownIt-Anchor" href="#dozer"></a> Dozer</h2><p>使用以上类库虽然可以不用手动编写get/set方法，但是他们都不能对不同名称的对象属性进行映射。在定制化的属性映射方面做得比较好的有Dozer，Dozer支持简单属性映射、复杂类型映射、双向映射、隐式映射以及递归映射。可使用xml或者注解进行映射的配置，支持自动类型转换，使用方便。但Dozer底层是使用reflect包下<code>Field</code>类的<code>set(Object obj, Object value)</code>方法进行属性赋值，执行速度上不是那么理想。</p><h2 id="orika"><a class="markdownIt-Anchor" href="#orika"></a> Orika</h2><p>Orika是近期在github活跃的项目，底层采用了<a href="https://github.com/jboss-javassist/javassist" target="_blank" rel="noopener">javassist</a>类库生成Bean映射的字节码，之后直接加载执行生成的字节码文件，因此在速度上比使用反射进行赋值会快很多，下面详细介绍Orika的使用方法。</p><h1 id="orika使用"><a class="markdownIt-Anchor" href="#orika使用"></a> Orika使用</h1><h2 id="依赖"><a class="markdownIt-Anchor" href="#依赖"></a> 依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ma.glasnost.orika<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>orika-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!-- or latest version --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="简单映射"><a class="markdownIt-Anchor" href="#简单映射"></a> 简单映射</h2><ol><li>构造一个MapperFactory</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MapperFactory mapperFactory = <span class="keyword">new</span> DefaultMapperFactory.Builder().build();</span><br></pre></td></tr></table></figure><ol start="2"><li>注册字段映射</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mapperFactory.classMap(PersonSource<span class="class">.<span class="keyword">class</span>, <span class="title">PersonDestination</span>.<span class="title">class</span>)  </span></span><br><span class="line">   .field("firstName", "givenName")</span><br><span class="line">   .field(<span class="string">"lastName"</span>, <span class="string">"sirName"</span>)</span><br><span class="line">   .byDefault()</span><br><span class="line">   .register();</span><br></pre></td></tr></table></figure><ol start="3"><li>进行映射</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MapperFacade mapper = mapperFactory.getMapperFacade();</span><br><span class="line"></span><br><span class="line">PersonSource source = <span class="keyword">new</span> PersonSource();  </span><br><span class="line"><span class="comment">// set some field values</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// map the fields of 'source' onto a new instance of PersonDest</span></span><br><span class="line">PersonDest destination = mapper.map(source, PersonDest<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>在第二步进行的字段映射是双向的，我们可以从目标类型映射回源类型，byDefault()方法用于注册名称相同的属性（如果所有属性名称都相同则可以省略第2步），如果不希望某个字段参与映射，可以使用exclude方法</p><h2 id="复杂映射"><a class="markdownIt-Anchor" href="#复杂映射"></a> 复杂映射</h2><ol><li>数组和List的映射<br />如果在目标类和目的类中分别有下面的属性</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicPerson</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; nameParts;</span><br><span class="line">  <span class="comment">// getters/setters omitted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicPersonDto</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> String firstName;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="comment">// getters/setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用下面的方式进行映射：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mapperFactory.classMap(BasicPerson<span class="class">.<span class="keyword">class</span>, <span class="title">BasicPersonDto</span>.<span class="title">class</span>)  </span></span><br><span class="line">   .field("nameParts[0]", "firstName")</span><br><span class="line">   .field(<span class="string">"nameParts[1]"</span>, <span class="string">"lastName"</span>)</span><br><span class="line">   .register();</span><br></pre></td></tr></table></figure><ol start="2"><li>类类型的映射</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> String first;</span><br><span class="line">   <span class="keyword">private</span> String last;</span><br><span class="line">   <span class="keyword">private</span> String fullName;</span><br><span class="line">   <span class="comment">// getters/setters </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicPerson</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> Name name;</span><br><span class="line">  <span class="comment">// getters/setters omitted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicPersonDto</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> String firstName;</span><br><span class="line">  <span class="comment">// getters/setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mapperFactory.classMap(BasicPerson<span class="class">.<span class="keyword">class</span>, <span class="title">BasicPersonDto</span>.<span class="title">class</span>)  </span></span><br><span class="line">   .field("name.first", "firstName")</span><br><span class="line">   .register();</span><br></pre></td></tr></table></figure><h2 id="自定义转换器"><a class="markdownIt-Anchor" href="#自定义转换器"></a> 自定义转换器</h2><p>orika同样支持自定义转换器，将指定类型或指定名称的属性做映射时添加自定义操作，例如，将String类型的或某个属性映射后加一个前缀，或者将Integer类型映射后加1等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConverter</span> <span class="keyword">extends</span> <span class="title">CustomConverter</span>&lt;<span class="title">Date</span>,<span class="title">MyDate</span>&gt; </span>&#123;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> MyDate <span class="title">convert</span><span class="params">(Date source, Type&lt;? extends MyDate&gt; destinationType)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// return a new instance of destinationType with all properties filled </span></span><br><span class="line">      <span class="comment">//example：source + 1；</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Date为源类型中要做转换的属性数据类型，例如String、Integer等，MyDate为目标类型中要做转换的属性数据类型</p><p>如果需要定义全局范围的转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConverterFactory converterFactory = mapperFactory.getConverterFactory();  </span><br><span class="line">converterFactory.registerConverter(<span class="keyword">new</span> MyConverter());</span><br></pre></td></tr></table></figure><p>如果仅需要某几个属性使用转换器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConverterFactory converterFactory = mapperFactory.getConverterFactory();  </span><br><span class="line">converterFactory.registerConverter(<span class="string">"myConverterIdValue"</span>, <span class="keyword">new</span> MyConverter());</span><br><span class="line"></span><br><span class="line">mapperFactory.classMap( Source<span class="class">.<span class="keyword">class</span>, <span class="title">Destination</span>.<span class="title">class</span> )  </span></span><br><span class="line">   .fieldMap("sourceField1", "sourceField2").converter("myConverterIdValue").add()</span><br><span class="line">   ...</span><br><span class="line">   .register();</span><br></pre></td></tr></table></figure><h2 id="其他说明"><a class="markdownIt-Anchor" href="#其他说明"></a> 其他说明</h2><ol><li><p>Orika支持递归映射，将映射嵌套类直到用“简单”类型完成映射。它还包含故障保险，以正确处理正在尝试映射的对象中的递归引用。</p></li><li><p>在于spring集成时，可以将MapperFactory设置为单例</p></li></ol><h1 id="各映射工具的性能测试"><a class="markdownIt-Anchor" href="#各映射工具的性能测试"></a> 各映射工具的性能测试</h1><p>构造一个包含普通类型及类类型的Bean对象,使用jmh微基准框架进行测试。由于jvm会对热点代码进行优化：方法反射调用次数超过阈值时会生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码进行执行。</p><p>故测试时每种方法先预热执行15次，而后再执行100次获取每次执行的平均时间：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Benchmark                     Mode  Samples   Score  Score error  Units  </span><br><span class="line">o.s.MyBenchmark.apache        avgt      100  25.246        0.535  us&#x2F;op  </span><br><span class="line">o.s.MyBenchmark.beanCopier    avgt      100   0.004        0.000  us&#x2F;op  </span><br><span class="line">o.s.MyBenchmark.byHand        avgt      100   0.004        0.000  us&#x2F;op  </span><br><span class="line">o.s.MyBenchmark.dozer         avgt      100   5.855        0.260  us&#x2F;op  </span><br><span class="line">o.s.MyBenchmark.orika         avgt      100   0.353        0.017  us&#x2F;op  </span><br><span class="line">o.s.MyBenchmark.spring        avgt      100   0.627        0.020  us&#x2F;op</span><br></pre></td></tr></table></figure><p>统计报告中Units单位为微秒/次，由Score项可以看出，基于ASM的cglib BeanCopier拷贝速度基本和手写get/set方法的速度无异，其次的就是基于javassist的Orika了，Orika的速度是spring BeanUtils的两倍，Dozer的20倍，Apache BeanUtils的120倍。</p><p>综上，当属性名和属性类型完全相同时使用BeanCopier是最好的选择，当存在属性名称不同或者属性名称相同但属性类型不同的情况时，使用Orika是一种不错的选择。如果你对Orika感到不放心，实际应用前可以写个测试类查看它的转换结果是否符合预期。</p><h1 id="原文链接"><a class="markdownIt-Anchor" href="#原文链接"></a> 原文链接</h1><p><a href="https://www.jianshu.com/p/40e0e64797b9" target="_blank" rel="noopener">https://www.jianshu.com/p/40e0e64797b9</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> BeanUtils </tag>
            
            <tag> Orika </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务解决方案</title>
      <link href="/posts/62ceeeec/"/>
      <url>/posts/62ceeeec/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p>在<a href="/posts/a2fb19c9/">上一篇</a>文章的BASE理论中提到了最终一致性，其实分布式事务的讨论主要就是聚焦于强一致性和最终一致性。</p><p>分布式事务就是为了解决微服务架构（形式都是分布式系统）中不同节点之间的数据一致性问题。这个一致性问题本质上解决的也是传统事务需要解决的问题，即一个请求在多个微服务调用链中，所有服务的数据处理要么全部成功，要么全部回滚。当然分布式事务问题的形式可能与传统事务会有比较大的差异，但是问题本质是一致的，都是要求解决数据的一致性问题。</p><p>下面我们从微服务开始来了解一下分布式事务和一些最终一致性的解决方案。</p><h1 id="微服务"><a class="markdownIt-Anchor" href="#微服务"></a> 微服务</h1><h2 id="微服务发展"><a class="markdownIt-Anchor" href="#微服务发展"></a> 微服务发展</h2><p>微服务倡导将复杂的单体应用拆分为若干个功能简单、松耦合的服务，这样可以降低开发难度、增强扩展性、便于敏捷开发。当前被越来越多的开发者推崇，很多互联网行业巨头、开源社区等都开始了微服务的讨论和实践。</p><h2 id="微服务落地存在的问题"><a class="markdownIt-Anchor" href="#微服务落地存在的问题"></a> 微服务落地存在的问题</h2><p>虽然微服务现在如火如荼，但对其实践其实仍处于探索阶段。很多中小型互联网公司，鉴于经验、技术实力等问题，微服务落地比较困难。</p><p>如著名架构师Chris Richardson所言，目前存在的主要困难有如下几方面：</p><ol><li>单体应用拆分为分布式系统后，进程间的通讯机制和故障处理措施变的更加复杂。</li><li>系统微服务化后，一个看似简单的功能，内部可能需要调用多个服务并操作多个数据库实现，服务调用的分布式事务问题变的非常突出。</li><li>微服务数量众多，其测试、部署、监控等都变的更加困难。</li></ol><p>随着RPC框架的成熟，第一个问题已经逐渐得到解决。例如springcloud可以非常好的支持restful调用，dubbo可以支持多种通讯协议。</p><p>对于第三个问题，随着docker、devops技术的发展以及各公有云paas平台自动化运维工具的推出，微服务的测试、部署与运维会变得越来越容易。</p><p>而对于第二个问题，现在还没有通用方案很好的解决微服务产生的事务问题。分布式事务已经成为微服务落地最大的阻碍，也是最具挑战性的一个技术难题。</p><h1 id="分布式事务中相关概念"><a class="markdownIt-Anchor" href="#分布式事务中相关概念"></a> 分布式事务中相关概念</h1><p><strong>刚性事务</strong>：满足ACID理论的事务</p><p><strong>柔性事务</strong>：满足BASE理论（基本可用，最终一致）的事务</p><p><strong>XA协议</strong>：全局事务管理器与资源管理器的接口。XA是由X/Open组织提出的分布式事务规范。该规范主要定义了全局事务管理器和局部资源管理器之间的接口。主流的数据库产品都实现了XA接口。XA接口是一个双向的系统接口，在事务管理器以及多个资源管理器之间作为通信桥梁。之所以需要XA是因为在分布式系统中从理论上讲两台机器是无法达到一致性状态的，因此引入一个单点进行协调。由全局事务管理器管理和协调的事务可以跨越多个资源和进程。全局事务管理器一般使用XA二阶段协议与数据库进行交互。</p><p><strong>幂等</strong>：重复调用多次产生的业务结果与调用一次产生的结果相同。</p><h1 id="分布式事务典型方案"><a class="markdownIt-Anchor" href="#分布式事务典型方案"></a> 分布式事务典型方案</h1><p>在分布式系统中，要实现分布式事务，现有解决方案无外乎那几种，下面我们就来一一了解一下。</p><h2 id="两阶段提交2pc"><a class="markdownIt-Anchor" href="#两阶段提交2pc"></a> 两阶段提交(2PC)</h2><p>两阶段提交缩写2PC（two-phase commit）,是一个非常经典的强一致、中心化的原子提交协议。这里所说的中心化是指协议中有两类节点：一个中心化<strong>协调者</strong>节点（coordinator）和N个<strong>参与者</strong>节点（partcipant）。</p><ol><li><p><strong>第一阶段表决阶段(投票阶段)</strong>：所有参与者都将本事务能否成功的信息反馈发给协调者。</p><ul><li>事务询问：协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应</li><li>执行事务并反馈：各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中，如果参与者成功执事务操作，就反馈给协调者Yes响应，表示事物可以执行，如果没有成功执行事务，就反馈给协调者No响应，表示事务不可以执行</li></ul></li><li><p><strong>第二阶段执行阶段</strong>：协调者根据所有参与者的反馈，通知所有参与者，步调一致地在所有分支上提交或者回滚。<br />假如协调者从所有的参与者或得反馈都是Yes响应，那么就会执行事务提交</p><ul><li>发送提交请求：协调者向所有参与者节点发出Commit请求</li><li>事务提交：参与者接受到Commit请求后，会正式执行事务提交操作，并在完成提交之后放弃整个事务执行期间占用的事务资源</li><li>反馈事务提交结果：参与者在完成事物提交之后，向协调者发送ACK消息</li><li>完成事务：协调者接收到所有参与者反馈的ACK消息后，完成事务</li></ul><p>假如任何一个参与者向协调者反馈了No响应，或者在等待超市之后，协调者尚无法接收到所有参与者的反馈响应，那么就中断事务。</p><ul><li>发送回滚请求：协调者向所有参与者节点发出Rollback请求</li><li>事务回滚：参与者接收到Rollback请求后，会利用其在阶段一中记录的Undo信息执行事物回滚操作，并在完成回滚之后释放事务执行期间占用的资源。</li><li>反馈事务回滚结果：参与则在完成事务回滚之后，向协调者发送ACK消息</li><li>中断事务：协调者接收到所有参与者反馈的ACk消息后，完成事务中断</li></ul></li></ol><img alt='2PC' src='https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/distributed-transaction/1.png' align='left'/><h3 id="存在的问题"><a class="markdownIt-Anchor" href="#存在的问题"></a> 存在的问题</h3><ul><li><strong>同步阻塞</strong>：对于任何一次指令必须收到明确的响应，才会继续做下一步，否则处于阻塞状态，占用的资源被一直锁定，不会被释放。</li><li><strong>单点故障</strong>：一旦协调者出现故障，整个系统不可用</li><li><strong>数据不一致</strong>：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li><li><strong>不确定性</strong>：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。</li></ul><h2 id="三阶段提交3pc"><a class="markdownIt-Anchor" href="#三阶段提交3pc"></a> 三阶段提交(3PC)</h2><p>三阶段提交协议（3PC 协议）是两阶段提交协议的改进版本。它通过超时机制解决了阻塞的问题，并且把两个阶段增加为三个阶段：</p><ol><li><strong>第一阶段询问阶段(CanCommit)</strong>：协调者询问参与者是否可以完成指令，协调者只需要回答是还是不是，而不需要做真正的操作，这个阶段参与者在等待超时后会自动中止。</li><li><strong>第二阶段准备阶段(PreCommit)</strong>：如果在询问阶段所有的参与者都返回可以执行操作，协调者向参与者发送预执行请求，然后参与者写 redo 和 undo 日志，锁定资源，执行操作，但是不提交操作；如果在询问阶段任何参与者返回不能执行操作的结果，则协调者向参与者发送中止请求，这里的逻辑与两阶段提交协议的的准备阶段是相似的，这个阶段参与者在等待超时后会自动提交。</li><li><strong>第三阶段提交阶段(Commit)</strong>：如果每个参与者在准备阶段返回准备成功，也就是预留资源和执行操作成功，协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；如果任何一个参与者返回准备失败，也就是预留资源或者执行操作失败，协调者向参与者发起中止指令，参与者取消已经变更的事务，执行 undo 日志，释放锁定的资源，这里的逻辑与两阶段提交协议的提交阶段一致。</li></ol><p>询问阶段可以确保尽可能早的发现无法执行操作而需要中止的行为，但是它并不能发现所有的这种行为，只会减少这种情况的发生。<br />如果在询问阶段等待超时，则自动中止；如果在准备阶段之后等待超时，则自动提交。这也是根据概率统计上的正确性最大。</p><h2 id="tcc方案"><a class="markdownIt-Anchor" href="#tcc方案"></a> TCC方案</h2><p>TCC（Try-Confirm-Cancel）又称补偿事务。其核心思想是：“针对每个操作都要注册一个与其对应的确认和补偿（撤销操作）”。它分为三个操作：</p><ol><li><strong>Try操作</strong>：主要是对业务系统做检测及资源预留。</li><li><strong>Confirm操作</strong>：确认执行业务操作。(需要保证幂等性)</li><li><strong>Cancel操作</strong>：取消执行业务操作。(需要保证幂等性)</li></ol><p>事务发起方向事务协调器发起事务请求，事务协调器调用所有事务参与者的 try 方法完成资源的预留，这时候并没有真正执行业务，而是为后面具体要执行的业务预留资源，这里完成了一阶段。<br />如果事务协调器发现有参与者的 try 方法预留资源时候发现资源不够，则调用参与方的 cancel 方法回滚预留的资源，需要注意 cancel 方法需要实现业务幂等，因为有可能调用失败（比如网络原因参与者接受到了请求，但是由于网络原因事务协调器没有接受到回执）会重试。<br />如果事务协调器发现所有参与者的 try 方法返回都 OK，则事务协调器调用所有参与者的 confirm 方法，不做资源检查，直接进行具体的业务操作。<br />如果协调器发现所有参与者的 confirm 方法都 OK 了，则分布式事务结束。<br />如果协调器发现有些参与者的 confirm 方法失败了，或者由于网络原因没有收到回执，则协调器会进行重试。这里如果重试一定次数后还是失败，会做事务补偿。</p><img alt='TCC' src='https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/distributed-transaction/2.png' align='left'/><p>与2PC协议比较 ，TCC拥有以下特点：</p><ul><li>位于业务服务层而非资源层 ，由业务层保证原子性</li><li>没有单独的准备(Prepare)阶段，降低了提交协议的成本</li><li>Try操作 兼备资源操作与准备能力</li><li>Try操作可以灵活选择业务资源的锁定粒度，而不是锁住整个资源，提高了并发度</li></ul><p>当然，TCC需要较高的开发成本，每个子业务都需要有响应的comfirm、Cancel操作，即实现相应的补偿逻辑。</p><h2 id="本地消息表"><a class="markdownIt-Anchor" href="#本地消息表"></a> 本地消息表</h2><p>本地消息表这个方案最初是 ebay 架构师 Dan Pritchett 在 2008 年发表给 ACM 的文章。该方案中会有消息生产者与消费者两个角色，假设系统 A 是消息生产者，系统 B 是消息消费者，其大致流程如下：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/distributed-transaction/3.png"  alt="本地消息表" /></p><ol><li>当系统 A 被其他系统调用发生数据库表更操作，首先会更新数据库的业务表，其次会往相同数据库的消息表中插入一条数据，两个操作发生在同一个事务中</li><li>系统 A 的脚本定期轮询本地消息往 mq 中写入一条消息，如果消息发送失败会进行重试</li><li>系统 B 消费 mq 中的消息，并处理业务逻辑。如果本地事务处理失败，会在继续消费 mq 中的消息进行重试，如果业务上的失败，可以通知系统 A 进行回滚操作。<br />本地消息表实现的条件：</li></ol><ul><li>消费者与生成者的接口都要支持幂等</li><li>生产者需要额外记录消息日志</li><li>需要提供补偿逻辑，如果消费者业务失败，需要生产者支持回滚操作<br />容错机制：</li><li>步骤 1 失败时，事务直接回滚</li><li>步骤 2、3 写 mq 与消费 mq 失败会进行重试</li><li>步骤 3 业务失败系统 B 向系统 A 发起事务回滚操作</li></ul><p>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。</p><h2 id="基于可靠消息"><a class="markdownIt-Anchor" href="#基于可靠消息"></a> 基于可靠消息</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/distributed-transaction/4.png"  alt="基于可靠消息" /><br />如上图，大致流程如下：</p><ol><li>A 系统先向 mq 发送一条 prepare 消息，如果 prepare 消息发送失败，则直接取消操作<br />如果消息发送成功，则执行本地事务</li><li>如果本地事务执行成功，则向 mq 发送一条 confirm 消息，如果发送失败，则发送回滚消息</li><li>B 系统定期消费 mq 中的 confirm 消息，执行本地事务，并发送 ack 消息。如果 B 系统中的本地事务失败，会一直不断重试，如果是业务失败，会向 A 系统发起回滚请求</li><li>mq 会定期轮询所有 prepared 消息调用系统 A 提供的接口查询消息的处理情况，如果该 prepare 消息本地事务处理成功，则重新发送 confirm 消息，否则直接回滚该消息</li></ol><p>该方案与本地消息最大的不同是去掉了本地消息表，其次本地消息表依赖消息表重试写入 mq 这一步由本方案中的轮询 prepare 消息状态来重试或者回滚该消息替代。其实现条件与余容错方案基本一致。目前市面上实现该方案的只有阿里的 RocketMq。</p><h2 id="最大努力通知"><a class="markdownIt-Anchor" href="#最大努力通知"></a> 最大努力通知</h2><p>最大努力通知是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果 不影响主动方的处理结果。</p><p>这个方案的大致意思就是：</p><p>系统 A 本地事务执行完之后，发送个消息到 MQ；<br />这里会有个专门消费 MQ 的服务，这个服务会消费 MQ 并调用系统 B 的接口；<br />要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B, 反复 N 次(逐步拉大通知间隔)，最后还是不行就放弃。</p><p>系统A应该提供一个查询执行情况接口，以供系统B校对结果和执行补偿操作。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>到这里分布式事务了解得差不多了，分布式事务本身是一个技术难题，是没有一种完美的方案应对所有场景的，具体还是要根据业务场景去抉择。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p><a href="https://www.jianshu.com/p/5f193a5fc9cf" target="_blank" rel="noopener">详谈式最终一致性</a><br /><a href="https://www.cnblogs.com/bluemiaomiao/p/11216380.html" target="_blank" rel="noopener">分布式事务中常见的三种解决方案</a><br /><a href="https://zhuanlan.zhihu.com/p/100279671" target="_blank" rel="noopener">微服务分布式事务4种解决方案实战</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP原则和BASE的学习</title>
      <link href="/posts/a2fb19c9/"/>
      <url>/posts/a2fb19c9/</url>
      
        <content type="html"><![CDATA[<p>分布式系统（distributed system）正变得越来越重要，现在大型网站几乎都是分布式的。<br />分布式系统的最大难点，就是各个节点的状态如何同步。CAP 原则是这方面的基本，下面我们就来了解一下CAP原则和其权衡的结果BASE。</p><h1 id="cap原则"><a class="markdownIt-Anchor" href="#cap原则"></a> CAP原则</h1><p>CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得。</p><ul><li><strong>一致性</strong>（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（注意这个的C和数据库事务ACID中的C是不同的含义，要注意区分）</li><li><strong>可用性</strong>（A）：在用户访问系统时，系统是否还能响应客户端的读写请求。</li><li><strong>分区容错性</strong>（P）：分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。</li></ul><p>如下图：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/cap-base/1.png"  alt="CAP原则" /></p><p>由于分区容忍性是分布式的最基本要求，大部分的分布式系统都是在C和A之间做选择。</p><h1 id="base"><a class="markdownIt-Anchor" href="#base"></a> BASE</h1><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。</p><p>BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p><p>接下来我们着重对BASE中的三要素进行详细讲解。</p><p><strong>基本可用</strong>：指分布式系统在出现不可预知故障的时候，允许损失部分可用性。<br />注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子：</p><p><em>响应时间上的损失</em>：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。<br /><em>功能上的损失</em>：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p><p><strong>软状态状态</strong>：是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><p><strong>最终一致性</strong>：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><p>参考资料：<br /><a href="https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">CAP原则 - 百科</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring事务</title>
      <link href="/posts/7d41eccf/"/>
      <url>/posts/7d41eccf/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是事务"><a class="markdownIt-Anchor" href="#什么是事务"></a> 什么是事务</h1><p>事务(Transaction)是指是程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，否则在每个操作中所作的所有更改都会被撤消。Spring事务管理基于底层数据库本身的事务处理机制。</p><p>事务具备ACID四种特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。</p><ul><li>原子性（Atomicity）<br />原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</li><li>一致性（Consistency）<br />一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。举例来说，假设用户A和用户B两者的钱加起来一共是1000，那么不管A和B之间如何转账、转几次账，事务结束后两个用户的钱相加起来应该还得是1000，这就是事务的一致性。</li><li>隔离性（Isolation）<br />隔离性是当多个用户并发访问数据库时，比如同时操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li><li>持久性（Durability）<br />持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li></ul><h1 id="事务的传播特性"><a class="markdownIt-Anchor" href="#事务的传播特性"></a> 事务的传播特性</h1><p>事务传播行为就是多个事务方法调用时，如何定义方法间事务的传播。Spring定义了7中传播行为：</p><ol><li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，<strong>这是Spring默认的选择</strong>。</li><li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li><li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li><li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li><li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li><li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作。</li></ol><h1 id="事务的隔离级别"><a class="markdownIt-Anchor" href="#事务的隔离级别"></a> 事务的隔离级别</h1><ol><li>read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。</li><li>read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</li><li>repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。</li><li>serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻读</li></ol><h2 id="脏读-不可重复读-幻读概念说明"><a class="markdownIt-Anchor" href="#脏读-不可重复读-幻读概念说明"></a> 脏读、不可重复读、幻读概念说明</h2><ul><li><strong>脏读</strong>：指当一个事务正字访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。</li><li><strong>不可重复读</strong>：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。</li><li><strong>幻读</strong>：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）</li></ul><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">read uncommited</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">read commited</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">repeatable read</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">serializable</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><p>(√)代表会发生，(×)代表不会发生</p><h1 id="事务几种实现方式"><a class="markdownIt-Anchor" href="#事务几种实现方式"></a> 事务几种实现方式</h1><ol><li>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。</li><li>基于 TransactionProxyFactoryBean的声明式事务管理</li><li>基于 @Transactional 的声明式事务管理</li><li>基于Aspectj AOP配置事务</li></ol><h1 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h1><p><a href="https://www.jianshu.com/p/35a60503e6c3" target="_blank" rel="noopener">Spring 事务详解</a></p><style>table th {width: 25%;}</style>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth 2.0 学习</title>
      <link href="/posts/443da21b/"/>
      <url>/posts/443da21b/</url>
      
        <content type="html"><![CDATA[<h1 id="oauth-20-介绍"><a class="markdownIt-Anchor" href="#oauth-20-介绍"></a> OAuth 2.0 介绍</h1><p>OAuth（Open Authorization，开放授权）是为用户资源的授权定义了一个安全、开放及简单的标准，第三方无需知道用户的账号及密码，就可获取到用户的授权信息。<br />OAuth2.0是OAuth协议的延续版本，但不向后兼容OAuth 1.0。</p><p>在传统的客户端-服务器身份验证模型中，客户端请求访问限制资源（受保护的资源）是通过使用资源所有者凭证向资源服务器进行身份验证。为了让第三方应用程序访问受限制的资源，资源所有者需要将自己的凭证提供给第三方。这会带来一些问题和局限性：</p><ul><li>需要第三方应用程序来存储资源所有者的凭证以供将来使用，通常是密码明文。</li><li>服务器需要支持密码验证，尽管密码方式有安全性弱点。</li><li>第三方应用程序获得了访问限制资源的权限并可以持续访问，而且也有访问限制资源子集的能力。</li><li>资源所有者不能撤消对单个第三方的访问权限而不撤销所有第三方的访问权限，如果要撤销授权就只能修改密码。</li><li>任何第三方应用程序被攻击都会导致用户密码以及其保护的资源损害。</li></ul><p>OAuth通过引入授权层解决了这些问题，并将客户角色与资源角色分开。在OAuth中，客户端请求访问受控资源，由资源所有者控制并由资源服务器托管，并且发出的凭证与资源所有者的凭证不同。而不是直接使用资源所有者的凭证来访问受保护的资源。大致流程如下：</p><ol><li>客户端申请<strong>访问令牌</strong>（包含访问具体范围，生存期和其他访问属性的字符串）。</li><li>访问令牌经资源所有者的批准由授权服务器向第三方客户端颁发。</li><li>客户端使用访问令牌访问资源服务器托管的受保护资源。</li></ol><h1 id="oauth-20-中的角色"><a class="markdownIt-Anchor" href="#oauth-20-中的角色"></a> OAuth 2.0 中的角色</h1><p>OAuth 2.0为用户和应用定义了如下四种角色：</p><ul><li><p>资源拥有者(resource owner)</p><p>资源拥有者是指拥有共享数据的人或应用。比如Facebook或者Google的用户就是是资源拥有者，他们拥有的资源就是他们的数据。资源拥有者一般指人，这也是最常见的情况。但资源拥有者也可以是一个应用，OAuth 2.0规范中包含这两种可能性。</p></li><li><p>资源服务器(resource server)</p><p>资源服务器是指托管资源的服务器。比如，Facebook或Google就是资源服务器(或者有一个资源服务器)。</p></li><li><p>客户端应用(client)</p><p>客户端应用是指请求访问存储在资源服务器的资源的应用。资源被资源拥有者所拥有。客户端应用可以是一个请求访问用户Facebook账号的第三方游戏。</p></li><li><p>授权服务器(authorization server)</p><p>授权服务器是指授权客户端应用能够访问资源拥有者所拥有的资源。授权服务器和资源服务器可以是同一个服务器，但不是必须的。如果这两个服务器是分开的，OAuth 2.0没有讨论这个两个服务器应该如何通信。这是由资源服务器和授权服务器开发者自己设计决定的。</p></li></ul><h1 id="oauth-20-授权方式"><a class="markdownIt-Anchor" href="#oauth-20-授权方式"></a> OAuth 2.0 授权方式</h1><p>OAuth 2.0为我们提供了四种授权方式，如下：</p><ul><li>授权码（authorization-code）</li><li>隐藏式（implicit）</li><li>密码式（password）：</li><li>客户端凭证（client credentials）</li></ul><p><strong>注意</strong>：不管哪一种授权方式，第三方应用申请令牌之前，都必须先到要访问的系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。<br />下面我们就一一来了解一下。</p><h2 id="授权码方式"><a class="markdownIt-Anchor" href="#授权码方式"></a> 授权码方式</h2><p>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</p><p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。如下图：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/oauth2/1.png"  alt="授权码方式" /></p><p><strong>A</strong>：用户访问客户端，客户端将用户导向授权服务器，通过用户代理（User-Agent）发送包括它的客户端标识符、请求的范围、本地状态和一个重定向URI，授权服务器在授予(或拒绝)访问权后将其发送给用户代理。URI如下：</p><blockquote><p><code>http://authorization-server/oauth/authorize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=CALLBACK_URL&amp;scope=read</code></p></blockquote><p>在URI中<code>response_type</code>参数表示要求返回授权码（code），<code>client_id</code>参数让授权服务器知道是谁在请求，<code>redirect_uri</code>参数是授权服务器接受或拒绝请求后的跳转网址（一般需要encode），scope参数表示要求的授权范围（这里是只读）</p><p><strong>B</strong>：授权服务器对资源所有者进行身份验证(通过用户代理，让用户输入用户名和密码)，并确定资源所有者是否授予或拒绝客户端的访问请求。</p><p><strong>C</strong>：用户跳转后，假如资源所有者同意授权请求，那么授权服务器将会使用前面提供的或者事先指定的重定向URI（redirection URI），重定向到客户端，并附上一个授权码（code）和一个前面提供的本地状态（state）（如果有的话，则会原值返回）。</p><blockquote><p><code>https://client/callback?code=AUTHORIZATION_CODE</code></p></blockquote><p>上面 URL 中，<code>code</code>参数就是授权码。</p><p><strong>D</strong>：客户端收到授权码，附上早先的重定向URI，向授权服务器申请令牌。这一步是在<strong>客户端的后台</strong>的服务器上完成的，对用户不可见。在发出请求时，授权服务器对客户端进行身份验证。请求参数包含授权代码、用于获得验证的授权代码的重定向URI、标识客户端身份的client id和client secret。</p><blockquote><p><code>https://authorization-server/oauth/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRETgrant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=CALLBACK_URL</code></p></blockquote><p>上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 authorization-server 确认 client 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p><p><strong>E</strong>：授权服务器对客户端进行身份验证，验证授权代码，并确保所收到的重定向URI与用于在步骤<strong>C</strong>中对客户端重定向的URI相匹配，如果有效，授权服务器将发送访问令牌<code>access token</code>和刷新令牌<code>refresh token</code>（可选）。</p><p>然后授权服务器给我们返回授权码，如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="attr">"access_token"</span>:<span class="string">"ACCESS_TOKEN"</span>,</span><br><span class="line">  <span class="attr">"token_type"</span>:<span class="string">"bearer"</span>,</span><br><span class="line">  <span class="attr">"expires_in"</span>:<span class="number">2592000</span>,</span><br><span class="line">  <span class="attr">"refresh_token"</span>:<span class="string">"REFRESH_TOKEN"</span>,</span><br><span class="line">  <span class="attr">"scope"</span>:<span class="string">"read"</span>,</span><br><span class="line">  <span class="attr">"other"</span>:<span class="string">"..."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的参数主要是：</p><ul><li>access_token：表示访问令牌。必选项。</li><li>token_type：表示令牌类型。该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>refresh_token：表示更新令牌。可选项，用来获取下一次的访问令牌。</li><li>scope：表示权限范围。可选项，如果与客户端申请的范围一致，此项可省略。</li></ul><p>最后我们拿到access_token去访问受保护的资源即可，如下：</p><blockquote><p><code>http://resource-server/api/userinfo?access_token=ACCESS_TOKEN</code></p></blockquote><h2 id="隐藏式"><a class="markdownIt-Anchor" href="#隐藏式"></a> 隐藏式</h2><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）“隐藏式”（implicit）。如下图：<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/oauth2/2.png"  alt="隐藏式" /></p><p><strong>A</strong>：Client网站提供一个链接，要求用户跳转到authorization-server，授权用户数据给 Client 网站使用。</p><blockquote><p><code>https://authorization-server/oauth/authorize?response_type=token&amp;client_id=CLIENT_IDredirect_uri=CALLBACK_URL&amp;scope=read</code></p></blockquote><p>上面 URL 中，<code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。</p><p><strong>B</strong>：授权服务器对资源所有者进行身份验证(通过用户代理，让用户输入用户名和密码)，并确定资源所有者是否授予或拒绝客户端的访问请求。</p><p><strong>C</strong>：用户跳转到 authorization-server ，登录后同意给予 client 网站授权。这时，authorization-server就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 client。</p><blockquote><p><code>https://client/callback#token=ACCESS_TOKEN</code></p></blockquote><p>上面 URL 中，<code>token</code>参数就是令牌，client因此直接在前端拿到令牌。</p><p><strong>注意</strong>:令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在&quot;中间人攻击&quot;的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p><p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p><h2 id="密码式"><a class="markdownIt-Anchor" href="#密码式"></a> 密码式</h2><p>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为&quot;密码式&quot;（password）。如下图：<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/oauth2/3.png"  alt="密码式" /></p><p><strong>A</strong>：Client要求用户提供authorization-server的用户名和密码。</p><p><strong>B</strong>：拿到用户名密码以后，Client 就直接向 authorization-server 请求令牌。</p><blockquote><p><code>https://authorization-server/token?grant_type=password&amp;username=USERNAME&amp;password=PASSWORD&amp;client_id=CLIENT_ID</code></p></blockquote><p>上面 URL 中，grant_type参数是授权方式，这里的password表示&quot;密码式&quot;，username和password是 authorization-server 的用户名和密码。</p><p><strong>C</strong>：授权服务器认证用户名和密码信息正确后，然后返回客户端access_token等信息，这里是以<strong>JSON</strong>的方式返回，类似授权码方式时返回的JSON</p><p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p><h2 id="客户端凭证"><a class="markdownIt-Anchor" href="#客户端凭证"></a> 客户端凭证</h2><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向&quot;服务提供商&quot;进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求&quot;服务提供商&quot;提供服务，其实不存在授权问题。如下图：<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/oauth2/4.png"  alt="客户端凭证" /></p><p><strong>A</strong>：客户端直接向授权服务器发起认证请求，URI如下：</p><blockquote><p><code>https://authorization-server/token?grant_type=client_credentials&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET</code></p></blockquote><p>上面 URL 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让 authorization-server 确认 client 的身份</p><p><strong>B</strong>：authorization-server 网站验证通过以后，直接返回令牌。</p><p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p><p>好了，OAuth 2.0 到这里就差不多了，更多的内容请访问<a href="https://oauth.net/2/" target="_blank" rel="noopener">官网</a></p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p><a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth 2.0官网</a></p>]]></content>
      
      
      <categories>
          
          <category> 权限 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro入门</title>
      <link href="/posts/43cf7ac5/"/>
      <url>/posts/43cf7ac5/</url>
      
        <content type="html"><![CDATA[<h1 id="shiro-简介"><a class="markdownIt-Anchor" href="#shiro-简介"></a> Shiro 简介</h1><p>Apache Shiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相当简单，对比 Spring Security，可能没有 Spring Security 做的功能强大，但是在实际工作时可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。对于它俩到底哪个好，这个不必纠结，能更简单的解决项目问题就好了。</p><h2 id="shiro基本功能"><a class="markdownIt-Anchor" href="#shiro基本功能"></a> Shiro基本功能</h2><p>Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。Shiro 可以帮助我们完成：认证、授权、加密、会话管理、与 Web 集成、缓存等。这不就是我们想要的嘛，而且 Shiro 的 API 也是非常简单；其基本功能点如下图所示：<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/shiro/1.png"  alt="Shiro基本功能" /><br /><strong>Authentication</strong>：身份认证 / 登录，验证用户是不是拥有相应的身份；</p><p><strong>Authorization</strong>：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</p><p><strong>Session Management</strong>：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；</p><p><strong>Cryptography</strong>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</p><p><strong>Web Support</strong>：Web 支持，可以非常容易的集成到 Web 环境；</p><p><strong>Caching</strong>：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率；</p><p><strong>Concurrency</strong>：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</p><p><strong>Testing</strong>：提供测试支持；</p><p><strong>Run As</strong>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</p><p><strong>Remember Me</strong>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</p><p><strong>注：记住一点，Shiro 不会去维护用户、维护权限；这些需要我们自己去设计 / 提供；然后通过相应的接口注入给 Shiro 即可。</strong></p><h2 id="shiro架构"><a class="markdownIt-Anchor" href="#shiro架构"></a> Shiro架构</h2><p>接下来我们分别从外部和内部来看看 Shiro 的架构，对于一个好的框架，从外部来看应该具有非常简单易于使用的 API，且 API 契约明确；从内部来看的话，其应该有一个可扩展的架构，即非常容易插入用户自定义实现，因为任何框架都不能满足所有需求。</p><h2 id="从外部看"><a class="markdownIt-Anchor" href="#从外部看"></a> 从外部看</h2><p>首先，我们从外部来看 Shiro 吧，即从应用程序角度的来观察如何使用 Shiro 完成工作。如下图：<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/shiro/2.png"  alt="Shiro架构-外部" /><br />可以看到：应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject；其每个 API 的含义：</p><p><strong>Subject</strong>：主体，代表了当前 “用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；</p><p><strong>SecurityManager</strong>：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；</p><p><strong>Realm</strong>：域，Shiro 从从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。</p><p>也就是说对于我们而言，最简单的一个 Shiro 应用：</p><p>应用代码通过 Subject 来进行认证和授权，而 Subject 又委托给 SecurityManager；</p><p>我们需要给 Shiro 的 SecurityManager 注入 Realm，从而让 SecurityManager 能得到合法的用户及其权限进行判断。<br /><strong>从以上也可以看出，Shiro 不提供维护用户 / 权限，而是通过 Realm 让开发人员自己注入。</strong></p><h2 id="从内部看"><a class="markdownIt-Anchor" href="#从内部看"></a> 从内部看</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/shiro/3.png"  alt="Shiro架构-内部" /><br /><strong>Subject</strong>：主体，可以看到主体可以是任何可以与应用交互的 “用户”；</p><p><strong>SecurityManager</strong>：相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。</p><p><strong>Authenticator</strong>：认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</p><p><strong>Authrizer</strong>：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</p><p><strong>Realm</strong>：可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户 / 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm；</p><p><strong>SessionManager</strong>：如果写过 Servlet 就应该知道 Session 的概念，Session 呢需要有人去管理它的生命周期，这个组件就是 SessionManager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所有呢，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）；</p><p><strong>SessionDAO</strong>：DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能；</p><p><strong>CacheManager</strong>：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</p><p><strong>Cryptography</strong>：密码模块，Shiro 提高了一些常见的加密组件用于如密码加密 / 解密的。</p><h1 id="shiro使用"><a class="markdownIt-Anchor" href="#shiro使用"></a> Shiro使用</h1><p>下面简单简绍一下在SpringBoot如何使用。<br /><strong>第一步</strong>：添加包引用。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!--shiro--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第二步</strong>：创建 Realm</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = (String) token.getPrincipal();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"admin"</span>.equals(username)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException(<span class="string">"账户不存在!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(username, <span class="string">"123"</span>, getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Realm 中实现简单的认证操作即可，不做授权，授权的具体写法可以参考：<a href="https://www.w3cschool.cn/shiro/hzlw1ifd.html" target="_blank" rel="noopener">Shiro Realm 介绍</a>。这里的认证表示用户名必须是 admin ，用户密码必须是 123 ，满足这样的条件，就能登录成功！</p><p><strong>第三步</strong> 配置 Shiro 基本信息<br />接下来在 application.properties 中配置 Shiro 的基本信息：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">shiro.sessionManager.sessionIdCookieEnabled=true</span><br><span class="line">shiro.sessionManager.sessionIdUrlRewritingEnabled=true</span><br><span class="line">shiro.unauthorizedUrl=/unauthorizedurl</span><br><span class="line">shiro.web.enabled=true</span><br><span class="line">shiro.successUrl=/index</span><br><span class="line">shiro.loginUrl=/login</span><br></pre></td></tr></table></figure><p>配置解释：</p><ul><li>第一行表示是否允许将sessionId 放到 cookie 中</li><li>第二行表示是否允许将 sessionId 放到 Url 地址拦中</li><li>第三行表示访问未获授权的页面时，默认的跳转路径</li><li>第四行表示开启 shiro</li><li>第五行表示登录成功的跳转页面</li><li>第六行表示登录页面</li></ul><p>再配置 ShiroConfig</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MyRealm <span class="title">myRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRealm();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DefaultWebSecurityManager <span class="title">securityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager manager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        manager.setRealm(myRealm());</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">ShiroFilterChainDefinition <span class="title">shiroFilterChainDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultShiroFilterChainDefinition definition = <span class="keyword">new</span> DefaultShiroFilterChainDefinition();</span><br><span class="line">        definition.addPathDefinition(<span class="string">"/doLogin"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        definition.addPathDefinition(<span class="string">"/**"</span>, <span class="string">"authc"</span>);</span><br><span class="line">        <span class="keyword">return</span> definition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里进行 Shiro 的配置主要配置 3 个 Bean ：</p><ul><li>首先需要提供一个 Realm 的实例。</li><li>需要配置一个 SecurityManager，在 SecurityManager 中配置 Realm。</li><li>配置一个 ShiroFilterChainDefinition ，在 ShiroFilterChainDefinition 中指定路径拦截规则等。</li></ul><p>这样就基本上完成了。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p><a href="https://www.w3cschool.cn/shiro/" target="_blank" rel="noopener">跟我学Shiro - w3cschool</a></p>]]></content>
      
      
      <categories>
          
          <category> 权限 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS单点登录</title>
      <link href="/posts/b6c57655/"/>
      <url>/posts/b6c57655/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>在日常生活中，很多人由于忘记某些网站的登录密码而烦恼，因为大多数用户都要记忆不少于10个用户名和相应密码。为了便于记忆，很多人都在不同的站点使用相同的用户名和密码，虽然这样可以减少负担，但是同时也降低了安全性，而且使用不同的站点同样要进行多次登录。同时，随着信息化飞速发展，大型企业和政府部门等都开始使用电子系统进行办公，而且整个办公系统由多个不同的子系统构成，如办公自动化(OA)系统，财务管理系统，档案管理系统，信息查询系统等。如果每个系统都使用独立的登录和验证机制，那么每天工作人员都要登录不同的系统进行办公。用户登录的频繁操作，降低了员工的工作效率，造成工作成本的浪费。而大量的密码和用户名的记忆时间长了也会出现问题，忘记密码或者混淆密码都会造成很大的麻烦。基于以上原因，为用户提供一个畅通的登录通道就变得十分重要。</p><h1 id="ssosinglesign-on单点登录"><a class="markdownIt-Anchor" href="#ssosinglesign-on单点登录"></a> SSO(SingleSign-On，单点登录)</h1><h2 id="sso简介"><a class="markdownIt-Anchor" href="#sso简介"></a> SSO简介</h2><p>SSO是一种帮助用户快捷访问网络中多个站点的安全通信技术。单点登录系统基于一种安全的通信协议，该协议通过多个系统之间的用户身份信息的交换来实现单点登录。使用单点登录系统时，用户只需要登录一次，就可以访问多个系统，不需要记忆多个口令密码。单点登录使用户可以快速访问网络，从而提高工作效率，同时也能帮助提高系统的安全性。</p><p>在SSO体系中，主要包括三部分：</p><ul><li>User （多个）</li><li>Web 应用（多个）</li><li>SSO 认证中心（ 1 个）</li></ul><p>而SSO的实现基本核心原则如下：</p><ul><li>所有的登录都在 SSO 认证中心进行</li><li>SSO 认证中心通过一些方法来告诉 Web 应用当前访问用户究竟是不是已通过认证的用户</li><li>SSO 认证中心和所有的 Web 应用建立一种信任关系， SSO 认证中心对用户身份正确性的判断会通过某种方法告之 Web 应用，而且判断结果必须被 Web 应用信任。</li></ul><h2 id="sso原理"><a class="markdownIt-Anchor" href="#sso原理"></a> SSO原理</h2><h3 id="登录"><a class="markdownIt-Anchor" href="#登录"></a> 登录</h3><p>上面介绍我们知道，在SSO中有一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。那其他的系统如何访问受保护的资源？这里就是通过认证中心间接授权通过令牌来实现，当SSO验证了用户信息的正确性后，就会创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/sso-cas/1.png"  alt="单点登录-登录" /></p><p>上面是一张SSO登录原理图，下面我们来分析一下具体的流程：</p><ol><li>首先用户访问系统1受保护的资源，系统1发现未登陆，跳转至SSO认证中心，并将自己的参数传递过去</li><li>SSO认证中心发现用户未登录，将用户引导至登录页面</li><li>用户输入用户名和密码提交至SSO认证中心</li><li>SSO认证中心校验用户信息，创建用户与SSO认证中心之间的会话，称为全局会话，同时创建授权令牌</li><li>SSO认证中心带着令牌跳转会最初的请求地址（系统1）</li><li>系统1拿到令牌，去SSO认证中心校验令牌是否有效</li><li>SSO认证中心校验令牌，返回有效，注册系统1的地址</li><li>系统1使用该令牌创建与用户的会话，称为局部会话，返回给用户受保护资源</li><li>用户访问系统2受保护的资源</li><li>系统2发现用户未登录，跳转至SSO认证中心，并将自己的地址作为参数传递过去</li><li>SSO认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</li><li>系统2拿到令牌，去SSO认证中心校验令牌是否有效</li><li>SSO认证中心校验令牌，返回有效，注册系统2地址</li><li>系统2使用该令牌创建与用户的局部会话，返回给用户受保护资源</li></ol><p>用户登录成功之后，会与SSO认证中心及各个子系统建立会话，用户与SSO认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过SSO认证中心，全局会话与局部会话有如下约束关系：</p><ul><li>局部会话存在，全局会话一定存在</li><li>全局会话存在，局部会话不一定存在</li><li>全局会话销毁，局部会话必须销毁</li></ul><h3 id="注销"><a class="markdownIt-Anchor" href="#注销"></a> 注销</h3><p>既然有登陆那么就自然有注销，单点登录也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁。原理图如下：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/sso-cas/2.png"  alt="单点登录-注销" /><br />SSO认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作</p><p>同样的我们也来分析一下具体的流程：</p><ol><li>用户向系统1发起注销请求</li><li>系统1根据用户与系统1建立的会话id拿到令牌，向SSO认证中心发起注销请求</li><li>SSO认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址</li><li>SSO认证中心向所有注册系统发起注销请求</li><li>各注册系统接收SSO认证中心的注销请求，销毁局部会话</li><li>SSO认证中心引导用户至登录页面</li></ol><p>上面的关于SSO原理部分参考单点登录原理与简单实现，如果不太理解可以去看看<a href="https://www.cnblogs.com/ywlaker/p/6113927.html" target="_blank" rel="noopener"><em>原文</em></a>。</p><h1 id="cas"><a class="markdownIt-Anchor" href="#cas"></a> CAS</h1><h2 id="cas介绍"><a class="markdownIt-Anchor" href="#cas介绍"></a> CAS介绍</h2><p>CAS全称为Central Authentication Service即中央认证服务，是一个企业多语言单点登录的解决方案，并努力去成为一个身份验证和授权需求的综合平台。</p><p>CAS是由Yale大学发起的一个企业级的、开源的项目，旨在为Web应用系统提供一种可靠的单点登录解决方法（属于 Web SSO ）。</p><p>CAS协议至少涉及三方：客户端Web浏览器，请求身份验证的Web应用程序和CAS服务器。 它也可能涉及后端服务，如数据库服务器，它没有自己的HTTP接口，但与Web应用程序进行通信。</p><p><strong>主要特征</strong>：</p><ul><li><p>多种的协议的支持，包括CAS (v1、v2、v3)、SAML(v1、v2)、OAuth、OpenID、OpenID Connect和WS-Federation Passive Requestor</p></li><li><p>多种认证机制，可以通过JAAS，LDAP，RDBMS，X.509，Radius，SPNEGO，JWT，Remote，Trusted，BASIC，Apache Shiro，MongoDB，Pac4J等进行身份验证</p></li><li><p>可以通过WS-FED，Facebook，Twitter，SAML IdP，OpenID，OpenID Connect，CAS等代理委派认证</p></li><li><p>多种形式的授权包括ABAC, Time/Date, REST, Internet2’s Grouper等</p></li><li><p>同时也支持HAZELCAST、EHCache、JPA、MycCache、Apache IGITE、MangGDB、ReDIS、DimoDoB、Couchbase等实现高可用多个集群部署</p></li><li><p>各种丰富的客户端，像常见的Java、Python、Node、PHP、C#、Perl等等</p></li></ul><p>下面是CAS相关的一些网址：<br /><a href="https://github.com/apereo/cas" target="_blank" rel="noopener">Github</a>、<a href="https://github.com/apereo/cas/tags" target="_blank" rel="noopener">下载链接</a>、<a href="https://apereo.github.io/cas/5.2.x/index.html" target="_blank" rel="noopener">开发文档</a>、<a href="https://www.apereo.org/projects/cas" target="_blank" rel="noopener">CAS官网</a></p><h2 id="cas基本原理"><a class="markdownIt-Anchor" href="#cas基本原理"></a> CAS基本原理</h2><p>CAS的结构中主要分两部分，一部分是CAS Server，另一部分是CAS Client。</p><ul><li><p>CAS Server：CAS Server 负责完成对用户的认证工作 , 需要独立部署 , CAS Server 会处理用户名 / 密码等凭证(Credentials)。</p></li><li><p>CAS Client：负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到 CAS Server 进行认证。（原则上，客户端应用不再接受任何的用户名密码等 Credentials ）。<br />下图是 CAS 最基本的协议过程<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/sso-cas/3.png"  alt="CAS流程" /></p></li></ul><ol><li>访问服务：浏览器(Web Browser)发送请求访问应用系统(包含CAS Client的服务)提供的服务资源。</li><li>定向认证：应用系统会<strong>重定向</strong>用户请求到认证中心(CAS Server)。</li><li>用户认证：如果认证中心发现用户未认证，会跳转到用户认证界面，让用户进行身份认证。</li><li>发放票据：如果认证通过，认证中心会产生一个随机的Service Ticket发放给用户，并重定向用户请求到应用系统。</li><li>验证票据：应用系统拿Service Ticket去认证中心验证票据的合法性，验证通过后，允许客户端访问服务。</li><li>传输用户信息：最后认证中心传输用户认证结果信息给应用系统。</li></ol><h2 id="cas两种模式"><a class="markdownIt-Anchor" href="#cas两种模式"></a> CAS两种模式</h2><p>CAS有两种模式：基础模式和代理模式<br />基础模式适用于：参与SSO的应用都为Web应用且各应用之间相互独立。<br />代理模式适用于：参与SSO的应用存在非Web应用（CAS基本模式会用到Cookie）或者应用之间存在集成关系。</p><h3 id="基础模式"><a class="markdownIt-Anchor" href="#基础模式"></a> 基础模式</h3><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/sso-cas/4.png"  alt="CAS基础模式" /><br />如上图：首先用户访问受保护的资源，权限没有认证，所以会把请求的URL以参数跳转到CAS认证中心，CAS认证中心发现没有SSO session，所以弹出登录页面，输入用户信息，提交到CAS认证中心进行信息的认证，如果信息正确，CAS认证中心就会创建一个SSO session和CASTGC cookie，这个CASTGC cookie包含了TGT，而用户session则以TGT为key创建，同时服务端会分发一个ST返回给用户。用户拿到了ST后，访问带参数ST的资源地址，同时应用将ST发送给CAS认证中心，CAS认证中心对ST进行校验，同时判断相应的cookie（包含TGT）是否正确（通过先前设定的key），判断ST是否是有效的，结果会返回一个包含成功信息的XML给应用。应用在建立相应的session和cookie跳转到浏览器，用户再通过浏览器带cookie去应用访问受保护的资源地址，cookie和后端session验证成功便可以成功访问到信息。</p><p>第二次访问应用时，浏览器就会携带相应的cookie信息，后台session验证用户是否登录，与一般单系统应用登录模式一样。</p><p>当我们访问其他的应用，与前面的步骤也是基本相同，首先用户访问受保护的资源，跳转回浏览器，浏览器含有先前登录的CASTGC cookie，CASTGC cookie包含了TGT并发送到CAS认证中心，CAS认证中心校验TGT是否有效，如果有效分发浏览器一个带ST参数的资源地址URL，应用程序拿到ST后，再发送给CAS认证中心，如果认证了ST有效后，结果会返回一个包含成功信息的XML给应用。同样的步骤，应用在建立相应的session和cookie跳转到浏览器，用户再通过浏览器带cookie去应用访问受保护的资源地址，验证session成功便可以成功访问到信息。</p><h3 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h3><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/sso-cas/5.png"  alt="CAS代理模式" /><br />如上图代理模式分两步</p><ol><li>加载代理应用</li></ol><p>首先用户访问代理地址，权限没有认证，所以会把请求的URL以参数跳转到CAS认证中心，CAS认证中心发现没有SSO session，所以弹出登录页面，输入用户信息，提交到CAS认证中心进行信息的认证，如果信息正确，CAS认证中心就会创建一个SSO session——CASTGC cookie，这个CASTGC cookie包含了TGT，这个TGT作为一个用户session，它会分发一个ST返回给用户。用户拿到了ST后，访问带参数ST的代理地址，代理地址将ST发送给CAS认证中心并且带一个pgtUrl，这是请求一个PGT的回调URL。CAS认证中通过调用回调PGT URL将TGT和PGTIOU传递给代理地址，代理地址匹配存储PGTIOU和PGT并执行下一步，然后CAS返回一个PGTIOU给代理匹配刚刚存储是PGTIOU与PGT是否一致。后面就通过PGTIOU查找PGT，然后代理地址在建立相应的session cookie跳转到浏览器，用户再通过浏览器带cookie去访问代理地址。</p><ol start="2"><li>通过代理访问应用</li></ol><p>通过代理访问应用，在浏览器中通过携带相应的cookie去访问代理，然后验证session cookie的有效性，然后再代理地址通过PGT跳转到CAS认证中心，认证中心再通过代理地址访问应用，相同的步骤，应用发送ST给CAS认证中心，检验proxy ticket是否有效，如何有效返回给应用一个XML信息。在应用中查询代理URL是否可信赖，阻止代理用户非法的行为。然后应用再建立相应的session cookie跳转到代理地址，代理地址再带cookie去访问应用，并验证是否正确。如果正确，则应用响应代理地址的请求，代理地址再把请求发送给用户。</p><h2 id="cas术语概念"><a class="markdownIt-Anchor" href="#cas术语概念"></a> CAS术语概念</h2><h3 id="cas-系统中的票据-tgc-tgt-st-pgt-pgtiou-pt"><a class="markdownIt-Anchor" href="#cas-系统中的票据-tgc-tgt-st-pgt-pgtiou-pt"></a> CAS 系统中的票据： TGC、TGT 、 ST 、 PGT 、 PGTIOU 、 PT 。</h3><ol><li><p>TGC（ticket-granting cookie）<br />授权的票据证明，由 CAS Server 通过 SSL 方式发送给终端用户，存放用户身份认证凭证的Cookie，在浏览器和CAS Server间通讯时使用，并且只能基于安全通道传输（Https），是CAS Server用来明确用户身份的凭证。</p></li><li><p>TGT（Ticket Grangting Ticket）<br />TGT是CAS为用户签发的登录票据，拥有了TGT，用户就可以证明自己在CAS成功登录过。TGT封装了Cookie值以及此Cookie值对应的用户信息。用户在CAS认证成功后，CAS生成Cookie（叫TGC），写入浏览器，同时生成一个TGT对象，放入自己的缓存，TGT对象的ID就是Cookie的值。当HTTP再次请求到来时，如果传过来的有CAS生成的Cookie，则CAS以此Cookie值为key查询缓存中有无TGT ，如果有的话，则说明用户之前登录过，如果没有，则用户需要重新登录。</p></li><li><p>ST（Service Ticket）<br />ST是CAS为用户签发的访问某一service的票据。用户访问service时，service发现用户没有ST，则要求用户去CAS获取ST。用户向CAS发出获取ST的请求，如果用户的请求中包含Cookie，则CAS会以此Cookie值为key查询缓存中有无TGT，如果存在TGT，则用此TGT签发一个ST，返回给用户。用户凭借ST去访问service，service拿ST去CAS验证，验证通过后，允许用户访问资源。</p></li><li><p>PGT（Proxy Granting Ticket）<br />Proxy Service的代理凭据。用户通过CAS成功登录某一Proxy Service后，CAS生成一个PGT对象，缓存在CAS本地，同时将PGT的值（一个UUID字符串）回传给Proxy Service，并保存在Proxy Service里。Proxy Service拿到PGT后，就可以为Target Service（back-end service）做代理，为其申请PT。</p></li><li><p>PGTIOU（Proxy Granting Ticket I Owe You）<br />PGTIOU是CAS协议中定义的一种附加票据，它增强了传输、获取PGT的安全性。<br />PGT的传输与获取的过程：Proxy Service调用CAS的serviceValidate接口验证ST成功后，CAS首先会访问pgtUrl指向的Https URL，将生成的 PGT及PGTIOU传输给proxy service，proxy service会以PGTIOU为key，PGT为value，将其存储在Map中；然后CAS会生成验证ST成功的XML消息，返回给Proxy Service，XML消息中含有PGTIOU，proxy service收到XML消息后，会从中解析出PGTIOU的值，然后以其为key，在Map中找出PGT的值，赋值给代表用户信息的Assertion对象的pgtId，同时在Map中将其删除。</p></li><li><p>PT（Proxy Ticket）<br />PT是用户访问Target Service（back-end service）的票据。如果用户访问的是一个Web应用，则Web应用会要求浏览器提供ST，浏览器就会用Cookie去CAS获取一个ST，然后就可以访问这个Web应用了。如果用户访问的不是一个Web应用，而是一个C/S结构的应用，因为C/S结构的应用得不到Cookie，所以用户不能自己去CAS获取ST，而是通过访问proxy service的接口，凭借proxy service的PGT去获取一个PT，然后才能访问到此应用。</p></li></ol><h3 id="tgt-st-pgt-pt之间关系"><a class="markdownIt-Anchor" href="#tgt-st-pgt-pt之间关系"></a> TGT、ST、PGT、PT之间关系</h3><ul><li>ST是TGT签发的。用户在CAS上认证成功后，CAS生成TGT，用TGT签发一个ST，ST的ticketGrantingTicket属性值是TGT对象，然后把ST的值redirect到客户应用。</li><li>PGT是ST签发的。用户凭借ST去访问Proxy service，Proxy service去CAS验证ST（同时传递PgtUrl参数给CAS），如果ST验证成功，则CAS用ST签发一个PGT，PGT对象里的ticketGrantingTicket是签发ST的TGT对象。</li><li>PT是PGT签发的。Proxy service代理back-end service去CAS获取PT的时候，CAS根据传来的pgt参数，获取到PGT对象，然后调用其grantServiceTicket方法，生成一个PT对象。</li></ul><h3 id="其他概念"><a class="markdownIt-Anchor" href="#其他概念"></a> 其他概念</h3><ul><li><p>KDC(Key Distribution Center)----------密钥发放中心；</p></li><li><p>Authentication Service (AS) --------- 认证服务，索取Crendential ，发放 TGT；</p></li><li><p>Ticket-Granting Service (TGS) --------- 票据授权服务，索取TGT ，发放ST。</p></li></ul><h1 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h1><p><a href="https://baike.baidu.com/item/SSO/3451380" target="_blank" rel="noopener">SSO百度百科</a><br /><a href="https://blog.csdn.net/Anumbrella/java/article/details/80821486" target="_blank" rel="noopener">初识SSO</a></p>]]></content>
      
      
      <categories>
          
          <category> 权限 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> SSO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RBAC权限模型</title>
      <link href="/posts/37cc241/"/>
      <url>/posts/37cc241/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>权限对于每个系统都非常重要，现有的系统的权限管理基本都是基于RBAC来实现的，所以我们应该学习RBAC。</p><h1 id="什么是rbac模型"><a class="markdownIt-Anchor" href="#什么是rbac模型"></a> 什么是RBAC模型</h1><p>RBAC是Role-Based Access Control的英文缩写，意思是基于角色的访问控制。<br />RBAC认为权限授权实际上是Who、What、How的问题。在RBAC模型中，who、what、how构成了访问权限三元组，也就是“Who对What(Which)进行How的操作，也就是“主体”对“客体”的操作，其中who——是权限的拥有者或主体（如：User、Role），what——是资源或对象（Resource、Class)</p><p>RBAC其实是一种分析模型，主要分为：</p><ul><li>基本模型RBAC0（Core RBAC）</li><li>角色分层模型RBAC1（Hierarchal RBAC）</li><li>角色限制模型RBAC2（Constraint RBAC）</li><li>统一模型RBAC3（Combines RBAC）。</li></ul><h2 id="rbac0"><a class="markdownIt-Anchor" href="#rbac0"></a> RBAC0</h2><p>RBAC0，它是RBAC的核心，RBAC1、RBAC2、RBAC3都是先后在RBAC0上的扩展。RBAC0定义了能构成RBAC控制系统的最小的元素集合，RBAC0由四部分构成：</p><ul><li>用户（User）</li><li>角色（Role）</li><li>会话（Session）</li><li>许可（Pemission）</li></ul><p>其中许可又包括“操作”和“控制对象”其中许可被赋予角色，而不是用户，当一个角色被指定给一个用户时，此用户就拥有了该角色所包含的许可。会话是动态的概念，用户必须通过会话才可以设置角色，是用户与激活的角色之间的映射关系。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/rbac/1.png"  alt="RBAC0" title="RBAC0" /></p><p>图中，用户与角色是多对多的关系；角色和许可也是多对多的关系；用户与会话是一对一关系；会话与角色是一对多关系；</p><h2 id="rbac1"><a class="markdownIt-Anchor" href="#rbac1"></a> RBAC1</h2><p>RBAC1，它是RBAC角色的分层模型，RBAC1建立在RBAC0基础之上，在角色中引入了继承的概念，有了继承那么角色就有了上下级或者等级关系，角色间的继承关系可分为一般继承关系和受限继承关系。一般继承关系仅要求角色继承关系是一个绝对偏序关系，允许角色间的多继承。而受限继承关系则进一步要求角色继承关系是一个树结构，实现角色间的单继承。</p><p>这种模型合适于角色之间的层次明确，包含明确。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/rbac/2.png"  alt="RBAC1" title="RBAC1" /></p><h2 id="rbac2"><a class="markdownIt-Anchor" href="#rbac2"></a> RBAC2</h2><p>RBAC2，它是RBAC的约束模型，RBAC2也是建立的RBAC0的基础之上的，在RBAC0基础上假如了约束的概念，主要引入了静态职责分离SSD(Static Separation of Duty)和动态职责分离DSD(Dynamic Separation of Duty)。</p><p>SSD是用户和角色的指派阶段加入的，主要是对用户和角色有如下约束:</p><ul><li>互斥角色：同一个用户在两个互斥角色中只能选择一个</li><li>基数约束：一个用户拥有的角色是有限的，一个角色拥有的许可也是有限的</li><li>先决条件约束：用户想要获得高级角色，首先必须拥有低级角色</li></ul><p>DSD是会话和角色之间的约束，可以动态的约束用户拥有的角色，如一个用户可以拥有两个角色，但是运行时只能激活一个角色。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/rbac/3.png"  alt="RBAC2" title="RBAC2" /></p><h2 id="rbac3"><a class="markdownIt-Anchor" href="#rbac3"></a> RBAC3</h2><p>RBAC3，它是RBAC1与RBAC2合集，所以RBAC3是既有角色分层又有约束的一种模型</p><p>以上就是RBAC模型的四种设计思想，在使用中根据系统需要做相应的修改。</p><h1 id="rbac新解"><a class="markdownIt-Anchor" href="#rbac新解"></a> RBAC新解</h1><p>有两种正使用的 RBAC 控制方式：隐式(模糊)的方式和显示(明确)的方式</p><h2 id="隐式模糊的方式"><a class="markdownIt-Anchor" href="#隐式模糊的方式"></a> 隐式(模糊)的方式</h2><p>不能明确的知道一个角色到底关联了哪些可执行操作，直接通过角色来验证用户有没有操作权限<br />例如：“超级管理员”角色能新建用户</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(hasRole(<span class="string">"admin"</span>))&#123;</span><br><span class="line">  <span class="comment">// show add user button</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种权限访问控制是非常脆弱的，一个极小的权限方面的需求变动都可能导致上面的代码需要重新修改<br />假如：需要新增“部门管理员”角色，也能新增用户</p><p>这种方式就是基于角色的访问控制：（Role-Based Access Control）</p><h2 id="显示明确的方式"><a class="markdownIt-Anchor" href="#显示明确的方式"></a> 显示(明确)的方式</h2><p>明确定义一个角色能对哪些资源进行什么操作<br />例如：如果当前用户有新建用户的权限则显示新建按钮</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接判断是否拥有权限</span></span><br><span class="line"><span class="keyword">if</span>(user.hasPermission(<span class="string">"user:add"</span>))&#123;</span><br><span class="line">  <span class="comment">// show add user button</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显式的权限控制方式的好处"><a class="markdownIt-Anchor" href="#显式的权限控制方式的好处"></a> 显式的权限控制方式的好处</h2><h3 id="更少的代码重构"><a class="markdownIt-Anchor" href="#更少的代码重构"></a> 更少的代码重构</h3><p>系统的功能需求一旦确定下来后，一段时间内对它的改动相应还是比较少的。<br />显式的权限控制方式不会因不同的角色要对功能进行操作而修改功能代码</p><h3 id="更直观"><a class="markdownIt-Anchor" href="#更直观"></a> 更直观</h3><p>保护资源对象、控制对资源对象的操作。<br />这样的权限控制方式更符合人们的思想习惯。</p><h3 id="更有弹性"><a class="markdownIt-Anchor" href="#更有弹性"></a> 更有弹性</h3><p>可支持任何安全模型的设计。<br />例如：将操作(权限)直接分配给角色，或者将多个角色关联到组(group)上。</p><h3 id="外部安全策略管理"><a class="markdownIt-Anchor" href="#外部安全策略管理"></a> 外部安全策略管理</h3><p>资源/行为与用户、组、角色的关联可以通过外部的模块或专用工具或管理控制台来完成</p><h3 id="可在运行环境做修改"><a class="markdownIt-Anchor" href="#可在运行环境做修改"></a> 可在运行环境做修改</h3><p>因为基于资源的权限控制代码并不依赖于行为的主体(如组、角色、用户等)（没有将行为的主体的字符名词写在代码中），所以你甚至可以在程序运行的时候通过修改主体能对资源进行的操作，通过配置的方式就可应对权限方面需求的变动，不需要重构代码。</p><p>这种显式的机制带给我们的富有弹性的权限模型。在这种新的模型下，已不必再局限于角色了，你可以将权限直接分配给用户、组或其它对象。</p><p>这种方式就是基于资源的访问控制：（Resource-Based Access Control），也就是所谓的RBAC新解。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ol><li><a href="https://baike.so.com/doc/5499468-5736904.html" target="_blank" rel="noopener">百科RBAC</a></li><li><a href="https://blog.csdn.net/yangwenxue_admin/article/details/73936803" target="_blank" rel="noopener">权限系统与RBAC模型概述</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 权限 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RBAC </tag>
            
            <tag> 权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java后端学习路线图</title>
      <link href="/posts/a7645600/"/>
      <url>/posts/a7645600/</url>
      
        <content type="html"><![CDATA[<h1 id="java后端学习"><a class="markdownIt-Anchor" href="#java后端学习"></a> JAVA后端学习</h1><h2 id="计算机基础知识"><a class="markdownIt-Anchor" href="#计算机基础知识"></a> 计算机基础知识</h2><ul><li>操作系统</li><li>网络</li><li>网络传输协议</li><li>数据结构</li><li>算法</li><li>进程、线程</li><li>linux基础</li></ul><h2 id="常用工具"><a class="markdownIt-Anchor" href="#常用工具"></a> 常用工具</h2><ul><li>Git</li><li>IDEA、VSCode</li><li>JMC</li><li>Linux分析工具</li><li>Maven、Gradle</li></ul><h2 id="java基础知识"><a class="markdownIt-Anchor" href="#java基础知识"></a> JAVA基础知识</h2><ul><li>JAVA基础</li><li>多线程</li><li>JVM</li></ul><h2 id="前端"><a class="markdownIt-Anchor" href="#前端"></a> 前端</h2><ul><li>HTML</li><li>CSS</li><li>JavaScript</li><li>Ajax</li><li>JSON</li><li>Vue</li><li>Node.js</li></ul><h2 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h2><ul><li>MySQL、Oracle</li><li>分库分表：Sharding-Sphere、Mycat、Sharding-JDBC</li></ul><h2 id="基本框架"><a class="markdownIt-Anchor" href="#基本框架"></a> 基本框架</h2><ul><li>Spring</li><li>SpringMVC</li><li>MyBatis</li><li>SpringBoot</li></ul><h2 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h2><ul><li>消息队列基础</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li><li>ActiveMQ</li><li>分布式事务</li></ul><h2 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h2><ul><li>Redis</li><li>Memcache</li><li>MongoDB</li></ul><h2 id="搜索引擎"><a class="markdownIt-Anchor" href="#搜索引擎"></a> 搜索引擎</h2><ul><li>ElasticSearch</li><li>Canal</li><li>Kibana</li><li>Lucene</li><li>Logstash</li></ul><h2 id="大数据"><a class="markdownIt-Anchor" href="#大数据"></a> 大数据</h2><ul><li>ODPS</li><li>Hadoop</li><li>Hive</li><li>Hbase</li><li>Cassandra</li><li>Fllink</li><li>Spark</li></ul><h2 id="rpc"><a class="markdownIt-Anchor" href="#rpc"></a> RPC</h2><ul><li>Dubbo</li><li>SpringCloud</li><li>Netty</li></ul><h2 id="网关"><a class="markdownIt-Anchor" href="#网关"></a> 网关</h2><ul><li>Nginx</li><li>LVS</li><li>Apache</li><li>Zookeeper</li><li>CDN</li></ul><h2 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h2><ul><li>Docker</li><li>K8s</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/posts/5d36ff15/"/>
      <url>/posts/5d36ff15/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br />Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。<br />Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。<br />Markdown 编写的文档后缀为 .md, .markdown。</p></blockquote><h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h1><h2 id="标题"><a class="markdownIt-Anchor" href="#标题"></a> 标题</h2><p>Markdown 标题有两种格式。</p><h3 id="使用-和-标记一级和二级标题"><a class="markdownIt-Anchor" href="#使用-和-标记一级和二级标题"></a> 使用 = 和 - 标记一级和二级标题</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">我是一级标题  </span><br><span class="line">=================</span><br><span class="line"></span><br><span class="line">我的是二级标题  </span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure><p>效果如下：<br /><img src='https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/markdown/1.jpg' align='left'/></p><h3 id="使用-号标记"><a class="markdownIt-Anchor" href="#使用-号标记"></a> 使用 # 号标记</h3><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><p>效果如下：<br /><img src='https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/markdown/2.jpg' align='left'/></p><h2 id="段落与格式"><a class="markdownIt-Anchor" href="#段落与格式"></a> 段落与格式</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。<br />也可以在段落后面使用一个空行来表示重新开始一个段落。</p><h3 id="字体"><a class="markdownIt-Anchor" href="#字体"></a> 字体</h3><p>Markdown 可以使用以下几种字体：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">***粗斜体文本**</span>*</span><br><span class="line"><span class="strong">___粗斜体文本__</span>_</span><br></pre></td></tr></table></figure><p><em>斜体文本</em><br /><em>斜体文本</em><br /><strong>粗体文本</strong><br /><strong>粗体文本</strong><br /><em><strong>粗斜体文本</strong></em><br /><em><strong>粗斜体文本</strong></em></p><h3 id="分隔线"><a class="markdownIt-Anchor" href="#分隔线"></a> 分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="bullet">* </span><span class="emphasis">* *</span></span><br><span class="line"><span class="strong">*****</span></span><br><span class="line"><span class="bullet">- </span>- -</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><h3 id="删除线"><a class="markdownIt-Anchor" href="#删除线"></a> 删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~我是被删除的~~</span><br></pre></td></tr></table></figure><p>效果如下：<br /><s>我是被删除的</s></p><h3 id="下划线"><a class="markdownIt-Anchor" href="#下划线"></a> 下划线</h3><p>下划线可以通过 HTML 的<code>&lt;u&gt;&lt;/u&gt;</code>标签或者自定义样式来实现：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线文本<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"border-bottom:1px dashed black;"</span>&gt;</span></span>带下划线文本<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><u>带下划线文本</u><br /><span style="border-bottom:1px dashed black;">带下划线文本</span></p><h2 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h2><p>Markdown 支持有序列表和无序列表。</p><h3 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表"></a> 无序列表</h3><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>第一项</span><br><span class="line"><span class="bullet">* </span>第二项</span><br><span class="line"><span class="bullet">* </span>第三项</span><br><span class="line"><span class="bullet">+ </span>第四项</span><br><span class="line"><span class="bullet">+ </span>第五项</span><br><span class="line"><span class="bullet">+ </span>第六项</span><br><span class="line"><span class="bullet">- </span>第七项</span><br><span class="line"><span class="bullet">- </span>第八项</span><br><span class="line"><span class="bullet">- </span>第九项</span><br></pre></td></tr></table></figure><p>效果如下：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第四项</li><li>第五项</li><li>第六项</li></ul><ul><li>第七项</li><li>第八项</li><li>第九项</li></ul><h3 id="有序列表"><a class="markdownIt-Anchor" href="#有序列表"></a> 有序列表</h3><p>有序列表使用数字并加上 . 号来表示，如：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>第一项</span><br><span class="line"><span class="bullet">2. </span>第二项</span><br><span class="line"><span class="bullet">3. </span>第三项</span><br></pre></td></tr></table></figure><p>效果如下：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="列表嵌套"><a class="markdownIt-Anchor" href="#列表嵌套"></a> 列表嵌套</h3><p>列表嵌套只需在子列表中的选项添加四个空格即可：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>第一项：</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第二个元素</span><br><span class="line"><span class="bullet">2. </span>第二项：</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure><p>效果如下：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="区块"><a class="markdownIt-Anchor" href="#区块"></a> 区块</h2><h3 id="区块引用"><a class="markdownIt-Anchor" href="#区块引用"></a> 区块引用</h3><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块引用</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>区块引用</p></blockquote><h3 id="区块嵌套"><a class="markdownIt-Anchor" href="#区块嵌套"></a> 区块嵌套</h3><p>区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 最外层</span></span><br><span class="line"><span class="quote">&gt; &gt; 第一层嵌套</span></span><br><span class="line"><span class="quote">&gt; &gt; &gt; 第二层嵌套</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h3 id="区块中使用列表"><a class="markdownIt-Anchor" href="#区块中使用列表"></a> 区块中使用列表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块中使用列表</span></span><br><span class="line"><span class="quote">&gt; 1. 第一项</span></span><br><span class="line"><span class="quote">&gt; 2. 第二项</span></span><br><span class="line"><span class="quote">&gt; + 第一项</span></span><br><span class="line"><span class="quote">&gt; + 第二项</span></span><br><span class="line"><span class="quote">&gt; + 第三项</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h3 id="列表中使用区块"><a class="markdownIt-Anchor" href="#列表中使用区块"></a> 列表中使用区块</h3><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>第一项</span><br><span class="line"><span class="code">    &gt; 引用</span></span><br><span class="line"><span class="code">    &gt; 引用</span></span><br><span class="line"><span class="bullet">* </span>第二项</span><br></pre></td></tr></table></figure><p>效果如下：</p><ul><li>第一项<blockquote><p>引用<br />引用</p></blockquote></li><li>第二项</li></ul><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><h3 id="行内代码"><a class="markdownIt-Anchor" href="#行内代码"></a> 行内代码</h3><p>行内的一个函数或片段的代码可以用反引号（一个两个都行）把它包起来（`），例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">`console.log('这是一个行内代码')`</span> </span><br><span class="line"><span class="string">``</span><span class="built_in">console</span>.log(<span class="string">'这是一个行内代码'</span>)<span class="string">``</span></span><br></pre></td></tr></table></figure><p>效果如下：<br /><code>console.log('这是一个行内代码')</code><br /><code>console.log('这是一个行内代码')</code></p><h3 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h3><p>代码块使用 4 个空格、一个制表符（Tab 键）开头（前面要空一行）或者```（三个或以上） 包裹一段代码：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">  console.log('四个空格')</span><br><span class="line">  console.log('一个制表符')</span><br><span class="line"><span class="code">```</span> [代码语言]</span><br><span class="line">console.log('<span class="code">```</span> 包裹')  </span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><pre><code>console.log('四个空格')  console.log('一个制表符')  </code></pre>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'```包裹'</span>)</span><br></pre></td></tr></table></figure><h2 id="链接与图片"><a class="markdownIt-Anchor" href="#链接与图片"></a> 链接与图片</h2><h3 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h3><p>链接使用方法如下：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  [链接名称](链接地址)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure><p>例如：</p>  <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度一下</span>](<span class="link">https://www.baidu.com/</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">https:</span>//<span class="attr">www.baidu.com</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果如下：<br /><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度一下</a><br /><a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></p><p>我们也可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p>  <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这里是 [<span class="string">Google</span>][<span class="symbol">google</span>]，变量名google</span><br><span class="line">这里是 [<span class="string">百度</span>][<span class="symbol">baidu</span>]，变量名baidu</span><br><span class="line"> </span><br><span class="line"> 然后在文档的结尾为变量赋值（网址）：</span><br><span class="line"> [google]: http://www.google.com/</span><br><span class="line"> [baidu]: http://www.baidu.com/</span><br></pre></td></tr></table></figure><p>这里是 <a href="http://www.google.com/" target="_blank" rel="noopener">Google</a>，变量名google<br />这里是 <a href="http://www.baidu.com/" target="_blank" rel="noopener">百度</a>，变量名baidu</p><h3 id="图片"><a class="markdownIt-Anchor" href="#图片"></a> 图片</h3><p>图片语法格式如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt 属性文本</span>](<span class="link">图片地址 "可选标题"</span>)</span><br><span class="line">![<span class="string">Markdown图标</span>](<span class="link">https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/markdown/markdown.jpg "Markdown图标"</span>)</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/markdown/markdown.jpg"  alt="Markdown图标" title="Markdown图标" /><br />也可以用HTML标签：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">'markdown'</span> <span class="attr">src</span>=<span class="string">'https://cdn.jsdelivr.net/gh/lshaolin/repo/img/post/markdown/markdown.jpg'</span> <span class="attr">align</span>=<span class="string">'left'</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="表格"><a class="markdownIt-Anchor" href="#表格"></a> 表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><p>语法格式如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>我们还可以设置表格的对齐方式：</p><ul><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。</li></ul><p>其中的&quot;-&quot;可以一个或者多个</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单 | 元 | 格 |</span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:right">右对齐</th><th style="text-align:center">居中对齐</th></tr></thead><tbody><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr><tr><td style="text-align:left">单</td><td style="text-align:right">元</td><td style="text-align:center">格</td></tr></tbody></table><h1 id="高级技巧"><a class="markdownIt-Anchor" href="#高级技巧"></a> 高级技巧</h1><h2 id="支持html元素"><a class="markdownIt-Anchor" href="#支持html元素"></a> 支持HTML元素</h2><p><strong>不在 Markdown 涵盖范围之内</strong> 的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。<br />需要注意的是区块元素比如 <code>&lt;div&gt;、 &lt;table&gt;、&lt;pre&gt;、 &lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。<br />行内标签如<code>&lt;span&gt;、 &lt;cite&gt;、&lt;del&gt; &lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>可以在 Markdown 的段落、列表或是标题里随意使用。<br />例如：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">del</span>&gt;</span></span>删除线<span class="xml"><span class="tag">&lt;/<span class="name">del</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果如下：<br /><del>删除线</del></p><h2 id="转义"><a class="markdownIt-Anchor" href="#转义"></a> 转义</h2><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号<br />例如：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**文本加粗**</span> </span><br><span class="line">\<span class="emphasis">*\*</span> 正常显示星号 \<span class="emphasis">*\*</span></span><br></pre></td></tr></table></figure><p>效果如下：<br /><strong>文本加粗</strong><br />** 正常显示星号 **</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line"><span class="bullet">*   </span>星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line"><span class="section">#   井字号</span></span><br><span class="line"><span class="bullet">+   </span>加号</span><br><span class="line"><span class="bullet">-   </span>减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure><h2 id="公式"><a class="markdownIt-Anchor" href="#公式"></a> 公式</h2><p>当你需要在编辑器中插入数学公式时，可以使用一个美元符 $ (行内)或两个美元符 $$ （独占一行）包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax或者KaTeX 对数学公式进行渲染。</p><h3 id="行内与独行"><a class="markdownIt-Anchor" href="#行内与独行"></a> 行内与独行</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">行内公式$x+y+z=0$</span><br><span class="line">独立行$$x+y+z=0$$</span><br></pre></td></tr></table></figure><p>行内公式： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x+y+z=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br />独立行：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x+y+z=0 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><h3 id="上标-下标与组合"><a class="markdownIt-Anchor" href="#上标-下标与组合"></a> 上标、下标与组合</h3><p>上标符号，符号：<code>^</code>，如：<code>$x^4$</code>，效果：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">x^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span><br />下标符号，符号：<code>_</code>，如：<code>$x_1$</code>，效果：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br />组合符号，符号：<code>{}</code>，如：<code>${x}^{2+}_{2}$</code>，效果：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mn>2</mn><mrow><mn>2</mn><mo>+</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">{x}^{2+}_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span></span></span></span></p><p>其他公式详情请参考：<a href="https://juejin.im/post/5a6721bd518825733201c4a2" target="_blank" rel="noopener">MarkDown 插入数学公式</a></p><h2 id="流程图"><a class="markdownIt-Anchor" href="#流程图"></a> 流程图</h2><h3 id="横向流程图"><a class="markdownIt-Anchor" href="#横向流程图"></a> 横向流程图</h3><blockquote><p>``` mermaid<br />graph LR<br />A[开始] --&gt;|链接文字| B(圆边)<br />B --&gt; C{条件x=?}<br />C --&gt;|x=1| D[结果1]<br />C --&gt;|x=2| E[结果2]<br />```</p></blockquote><p>效果如下：</p><div class="mermaid">          graph LR    A[开始] -->|链接文字| B(圆边)    B --> C{条件x=?}    C -->|x=1| D[结果1]    C -->|x=2| E[结果2]          </div><h3 id="竖向流程图"><a class="markdownIt-Anchor" href="#竖向流程图"></a> 竖向流程图</h3><blockquote><p>``` mermaid<br />graph TD<br />A[开始] --&gt;|链接文字| B(圆边)<br />B --&gt; C{条件x=?}<br />C --&gt;|x=1| D[结果1]<br />C --&gt;|x=2| E[结果2]<br />```</p></blockquote><div class="mermaid">          graph TD    A[开始] -->|链接文字| B(圆边)    B --> C{条件x=?}    C -->|x=1| D[结果1]    C -->|x=2| E[结果2]          </div><p>其他如 ：时序图、类别图、状态图、甘特图和圆形图请查看<a href="https://mermaid-js.github.io/mermaid/" target="_blank" rel="noopener">mermaid文档</a></p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ol><li><a href="https://www.markdownguide.org/" target="_blank" rel="noopener">Markdown</a></li><li><a href="https://mermaid-js.github.io/mermaid/" target="_blank" rel="noopener">mermaid文档</a></li><li><a href="https://www.w3cschool.cn/markdownyfsm/" target="_blank" rel="noopener">Markdown 语法说明</a></li><li><a href="https://juejin.im/post/5a6721bd518825733201c4a2" target="_blank" rel="noopener">MarkDown 插入数学公式</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
