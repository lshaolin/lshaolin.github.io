<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP三次握手四次挥手</title>
      <link href="/posts/627d7c1/"/>
      <url>/posts/627d7c1/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><h2 id="tcp报文首部格式介绍"><a class="markdownIt-Anchor" href="#tcp报文首部格式介绍"></a> TCP报文首部格式介绍</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/tcp-three-handshakes-four-waves/1.png"  alt="TCP报文首部格式" /></p><ul><li>源端口和目的端口（Source Port和Destination Port）：分别占用2个字节，用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接。</li><li>序号seq（Sequence Number）：占4个字节，用来标识从TCP发端向TCP收端发送的数据字节流（tcp传输的每一个字节都按顺序编号），它表示在这个报文段中的的第一个数据字节在数据流中的序号。主要用来解决网络报乱序的问题。</li><li>确认号ack（Acknowledgment Number）：占4个字节，确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志为1时该确认序列号的字段才有效。主要用来解决不丢包的问题（确认序号减去上次收到的序号等于本段收到的报文的长度）。</li><li>数据偏移（Offset）：占4个bit，指出tcp报文段的数据起始处距离tcp报文段的起始有多远，这个字段实际指出Ttcp报文段的首部长度。需要这个值是因为任选字段的长度是可变的，它用来表示首部中32bit（4字节）字的数目，因此最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节。</li><li>保留：占6bit。</li><li>TCP Flags：TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：</li><li>紧急URG：当URG = 1时，表示TCP包的紧急指针域有效，告诉系统这个报文段中有紧急数据，应当尽快传输。</li><li>确认ACK：TCP应答号将会包含在TCP数据包中，有两个取值：0和1，为1的时候表示应答域有效，反之为0。</li><li>推送PSH：这个标志位表示Push操作，接收方tcp收到PSH = 1的报文段，就尽快交付给接收接收应用进程而不是再等到这个缓冲区都填满之后再向上交付。</li><li>复位RST：表示连接复位请求，当RST = 1，标明tcp有严重的错误，必须释放连接，重新建立运输连接。RST = 1还可以用来拒绝一个非法的报文段或者拒绝打开一个连接。</li><li>同步SYN：表示同步序号，用来建立连接，SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手。</li><li>终止FIN： 表示发送端已经达到数据末尾，将释放一个连接，FIN = 1， 表示报文段的发送方的数据已经发送完成，请求释放连接。</li><li>窗口：占2个字节，存放的是数据是字节为单位的窗口值告诉对方，本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。这是让发送方设置发送窗口的依据。</li><li>检验和，占2个字节。</li></ul><h2 id="三次握手四次挥手重要概念"><a class="markdownIt-Anchor" href="#三次握手四次挥手重要概念"></a> 三次握手，四次挥手重要概念</h2><p>要理解三次握手，四次挥手，首先要理解一下几个重要概念：同步SYN、确认ACK、序号seq、确认号ack、终止FIN5。</p><ul><li>同步SYN：在连接建立时用来同步序号，当SYN=1而ACK=0时，表明这是一个连接请求报文，对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1，SYN置1就表示这是一个连接请求或连接接受报文。</li><li>确认ACK：TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。</li><li>序号seq：标识从TCP发端向TCP收端发送的数据字节流（tcp传输的每一个字节都按顺序编号），它表示在这个报文段中的的第一个数据字节在数据流中的序号。</li><li>确认号ack：确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志为1时该确认序列号的字段才有效。</li><li>终止FIN：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。</li></ul><h1 id="三次握手"><a class="markdownIt-Anchor" href="#三次握手"></a> 三次握手</h1><p>TCP协议中，主动发起请求的一端称为『客户端』，被动连接的一端称为『服务端』。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/tcp-three-handshakes-four-waves/2.png"  alt="三次握手" /></p><p>刚开始的时候，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。</p><p>服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。</p><ol><li><p>第一次握手<br />客户端向服务端发送连接请求报文段。该报文段的头部中同步SYN=1，确认ACK=0，同时选择一个初始序号seq=x。请求发送后，客户端便进入SYN-SENT状态。</p><ul><li>SYN=1，ACK=0表示该报文段为连接请求报文</li><li>x为本次TCP通信的字节流的初始序号</li><li>TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号</li></ul></li><li><p>第二次握手<br />服务端收到连接请求报文段后，如果同意连接，会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。发送完应答后服务端进入SYN-RCVD状态。</p><ul><li>SYN=1，ACK=1表示该报文段为连接同意的应答报文</li><li>seq=y表示服务端作为发送者时，发送字节流中的第一个字节序号</li><li>ack=x+1表示服务端希望客户端发送的下一个数据报初始序号是从x+1开始</li></ul></li><li><p>第三次握手<br />客户端收到服务端连接同意的应答后，还会向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。该报文段的头部为：ACK=1，seq=x+1，ack=y+1。</p></li></ol><p>客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！</p><h2 id="tcp建立连接为什么是三次握手而不是两次或四次"><a class="markdownIt-Anchor" href="#tcp建立连接为什么是三次握手而不是两次或四次"></a> TCP建立连接为什么是三次握手，而不是两次或四次？</h2><p>首先应该清楚一点：不论握手多少次都不能确认一条信道一定是“可靠”的，但通过3次握手可以至少确认它是“可用”的，再往上加握手次数不过是提高它是“可用”的这个结论的可信度。</p><p>也就是说任意次的握手都是“不可靠”的，握手成功只能说明握手时的通信是正常的，并不能保证握手后的通信是正常的。握手只能保证尽可能的可靠，而不可能保证绝对可靠。</p><h3 id="那为什么不是两次握手"><a class="markdownIt-Anchor" href="#那为什么不是两次握手"></a> 那为什么不是两次握手？</h3><p>是为了防止已失效的连接请求报文段突然又传送到了服务端，造成服务端资源的浪费。</p><p>这句话怎样理解？</p><p>在一次TCP连接中，客户端A向服务端B发送连接请求SYN报文段，假如这个报文段没有及时被服务端B接收，而是滞留在网络的某处，于是客户端A超时重传，再次发送请求连接并且顺利与服务端B建立了连接，交换数据后断开连接。</p><p>滞留在网络中的某处的陈旧报文就变成了失效的连接请求报文。</p><p>但如果这个失效的请求SYN报文段，现在又突然传送到了服务端B处，设想这时是使用两次握手而不是三次握手，服务端B就以为客户端A现在建立请求连接，于是服务端B发出确认，新的连接就建立了，服务端B分配资源，等待客户端A传送数据，但客户端A并没有想要建立TCP连接，不会理会服务端B发送的应答，也不会向服务端B传送数据，于是服务端B就白白等待，空耗资源。</p><p>使用三次握手可以避免这个情况。服务端B收到客户端A的失效的陈旧SYN报文段，向客户端A发送SYN报文段，选择自己的序号seq=y，确认收到客户端A的SYN报文段，确认号ack=x+1。第三次握手客户端A收到B的SYN报文段后，从确认号就可得知不应理睬这个SYN报文段（因为A现在并没有发送seq=x的报文段）。</p><p>这时，客户端A会发送复位报文段，这个复位报文段中，RST=1，ACK=1，确认号ack=y+1。</p><p>服务端B收到A的复位报文，就知道不建立TCP连接，不会分配资源等待A发送数据。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/tcp-three-handshakes-four-waves/3.png"  alt="两次握手导致的问题" /></p><h3 id="为什么不是四次握手"><a class="markdownIt-Anchor" href="#为什么不是四次握手"></a> 为什么不是四次握手？</h3><p>既然两次握手不可以，那四次握手，五次握手呢？</p><p>因为三次握手已经能说明握手时的通信是正常的，四次握手、五次握手就显得浪费了。</p><h1 id="四次挥手"><a class="markdownIt-Anchor" href="#四次挥手"></a> 四次挥手</h1><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/tcp-three-handshakes-four-waves/4.png"  alt="四次挥手" /></p><p>TCP连接的释放一共需要四步，这也是四次挥手的由来。</p><p>TCP连接是双向的，在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。</p><ol><li><p>第一次挥手<br />客户端数据发送完成，则它向服务端发送连接释放请求。该请求只有报文头，头中携带的主要参数为：FIN=1，seq=u。此时，客户端将进入FIN-WAIT-1状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p><ul><li>FIN=1表示该报文段是一个连接释放请求</li><li>seq=u，u-1是客户端向服务端发送的最后一个字节的序号</li></ul></li><li><p>第二次挥手<br />服务器收到客户端连接释放报文，通知相应的高层应用进程，告诉它客户端向服务器这个方向的连接已经释放了。</p></li></ol><p>此时服务端进入了CLOSE-WAIT（关闭等待）状态，并向客户端发出连接释放的应答，其报文头包含：ACK=1，ack=u+1，并且带上自己的序列号seq=v。</p><ul><li>ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答</li><li>seq=v，v是服务端释放应答报文段第一个字节序号</li><li>ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节<br />客户端收到该应答后，进入FIN-WAIT-2状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li></ul><p>第二次挥手完成后，客户端到服务端方向的连接已经释放，服务端不会再接收客户端的数据，客户端也没有数据要发送了。但服务端到客户端方向的连接仍然存在，服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p><ol start="3"><li><p>第三次挥手<br />服务端将最后的数据发送完毕后，就向客户端发送连接释放报文，其报文头包含：FIN=1，ack=u+1，由于在CLOS-WAIT状态，服务端很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p></li><li><p>第四次挥手<br />客户端收到服务器的连接释放报文后，向服务端发出确认应答，报文头：ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。</p></li></ol><p>该状态会持续2MSL（最长报文段寿命）时间，这个期间TCP连接还未释放，若该时间段内没有服务端的重发请求的话，客户端就进入CLOSED状态，撤销TCB。</p><p>服务端只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p><h2 id="为什么客户端最后还要等待2msl"><a class="markdownIt-Anchor" href="#为什么客户端最后还要等待2msl"></a> 为什么客户端最后还要等待2MSL？</h2><p>第一：为了保证服务端能收到客户端的确认应答。</p><p>若客户端发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，服务端等待超时后就会重新发送连接释放请求，但此时客户端已经关闭了，不会作出任何响应，因此服务端就无法正常关闭。</p><p>第二：防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。</p><p>客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h2 id="tcp关闭连接是为什么是四次挥手"><a class="markdownIt-Anchor" href="#tcp关闭连接是为什么是四次挥手"></a> TCP关闭连接是为什么是四次挥手？</h2><p>关闭连接时，服务器收到客户端的FIN报文时，仅仅表示客户端不再发送数据了但是还能接收数据，并且服务端也未必全部数据都发送给对方了，所以服务端可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，服务端的ACK和FIN一般都会分开发送，从而导致多了一次。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.jianshu.com/p/4084a9397138" target="_blank" rel="noopener">TCP/IP–理解TCP三次握手和四次挥手</a><br /><a href="https://juejin.im/post/5c25dd5ff265da612b13aa90" target="_blank" rel="noopener">“三次握手，四次挥手”你真的懂吗？</a><br /><a href="https://www.jianshu.com/p/afdd3736c923" target="_blank" rel="noopener">TCP三次握手四次挥手</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见Bean映射工具分析评测</title>
      <link href="/posts/818596de/"/>
      <url>/posts/818596de/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>工作中，我们经常需要将对象转换成不同的形式以适应不同的api，或者在不同业务层中传输对象而不同分层的对象存在不同的格式，因此我们需要编写映射代码将对象中的属性值从一种类型转换成另一种类型。</p><p>进行这种转换除了手动编写大量的get/set代码，还可以使用一些方便的类库，常用的有apache的BeanUtils，spring的BeanUtils，cglib的BeanCopier。</p><h1 id="常见bean映射工具分析"><a class="markdownIt-Anchor" href="#常见bean映射工具分析"></a> 常见Bean映射工具分析</h1><h2 id="beanutils"><a class="markdownIt-Anchor" href="#beanutils"></a> BeanUtils</h2><p>apache的BeanUtils和spring的BeanUtils中拷贝方法的原理都是先用jdk中 <code>java.beans.Introspector</code>类的<code>getBeanInfo()</code>方法获取对象的属性信息及属性get/set方法，接着使用反射（<code>Method</code>的<code>invoke(Object obj, Object... args)</code>）方法进行赋值。apache支持名称相同但类型不同的属性的转换，spring支持忽略某些属性不进行映射，他们都设置了缓存保存已解析过的BeanInfo信息。</p><h2 id="beancopier"><a class="markdownIt-Anchor" href="#beancopier"></a> BeanCopier</h2><p>cglib的<code>BeanCopier</code>采用了不同的方法：它不是利用反射对属性进行赋值，而是直接使用ASM的<code>MethodVisitor</code>直接编写各属性的get/set方法（具体过程可见BeanCopier类的<code>generateClass(ClassVisitor v)</code>方法）生成class文件，然后进行执行。由于是直接生成字节码执行，所以<code>BeanCopier</code>的性能较采用反射的<code>BeanUtils</code>有较大提高，这一点可在后面的测试中看出。</p><h2 id="dozer"><a class="markdownIt-Anchor" href="#dozer"></a> Dozer</h2><p>使用以上类库虽然可以不用手动编写get/set方法，但是他们都不能对不同名称的对象属性进行映射。在定制化的属性映射方面做得比较好的有Dozer，Dozer支持简单属性映射、复杂类型映射、双向映射、隐式映射以及递归映射。可使用xml或者注解进行映射的配置，支持自动类型转换，使用方便。但Dozer底层是使用reflect包下<code>Field</code>类的<code>set(Object obj, Object value)</code>方法进行属性赋值，执行速度上不是那么理想。</p><h2 id="orika"><a class="markdownIt-Anchor" href="#orika"></a> Orika</h2><p>Orika是近期在github活跃的项目，底层采用了<a href="https://github.com/jboss-javassist/javassist" target="_blank" rel="noopener">javassist</a>类库生成Bean映射的字节码，之后直接加载执行生成的字节码文件，因此在速度上比使用反射进行赋值会快很多，下面详细介绍Orika的使用方法。</p><h1 id="orika使用"><a class="markdownIt-Anchor" href="#orika使用"></a> Orika使用</h1><h2 id="依赖"><a class="markdownIt-Anchor" href="#依赖"></a> 依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ma.glasnost.orika<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>orika-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="comment">&lt;!-- or latest version --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="简单映射"><a class="markdownIt-Anchor" href="#简单映射"></a> 简单映射</h2><ol><li>构造一个MapperFactory</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MapperFactory mapperFactory = <span class="keyword">new</span> DefaultMapperFactory.Builder().build();</span><br></pre></td></tr></table></figure><ol start="2"><li>注册字段映射</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mapperFactory.classMap(PersonSource<span class="class">.<span class="keyword">class</span>, <span class="title">PersonDestination</span>.<span class="title">class</span>)  </span></span><br><span class="line">   .field("firstName", "givenName")</span><br><span class="line">   .field(<span class="string">"lastName"</span>, <span class="string">"sirName"</span>)</span><br><span class="line">   .byDefault()</span><br><span class="line">   .register();</span><br></pre></td></tr></table></figure><ol start="3"><li>进行映射</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MapperFacade mapper = mapperFactory.getMapperFacade();</span><br><span class="line"></span><br><span class="line">PersonSource source = <span class="keyword">new</span> PersonSource();  </span><br><span class="line"><span class="comment">// set some field values</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// map the fields of 'source' onto a new instance of PersonDest</span></span><br><span class="line">PersonDest destination = mapper.map(source, PersonDest<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>在第二步进行的字段映射是双向的，我们可以从目标类型映射回源类型，byDefault()方法用于注册名称相同的属性（如果所有属性名称都相同则可以省略第2步），如果不希望某个字段参与映射，可以使用exclude方法</p><h2 id="复杂映射"><a class="markdownIt-Anchor" href="#复杂映射"></a> 复杂映射</h2><ol><li>数组和List的映射<br />如果在目标类和目的类中分别有下面的属性</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicPerson</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; nameParts;</span><br><span class="line">  <span class="comment">// getters/setters omitted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicPersonDto</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> String firstName;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="comment">// getters/setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用下面的方式进行映射：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mapperFactory.classMap(BasicPerson<span class="class">.<span class="keyword">class</span>, <span class="title">BasicPersonDto</span>.<span class="title">class</span>)  </span></span><br><span class="line">   .field("nameParts[0]", "firstName")</span><br><span class="line">   .field(<span class="string">"nameParts[1]"</span>, <span class="string">"lastName"</span>)</span><br><span class="line">   .register();</span><br></pre></td></tr></table></figure><ol start="2"><li>类类型的映射</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> String first;</span><br><span class="line">   <span class="keyword">private</span> String last;</span><br><span class="line">   <span class="keyword">private</span> String fullName;</span><br><span class="line">   <span class="comment">// getters/setters </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicPerson</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> Name name;</span><br><span class="line">  <span class="comment">// getters/setters omitted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicPersonDto</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> String firstName;</span><br><span class="line">  <span class="comment">// getters/setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mapperFactory.classMap(BasicPerson<span class="class">.<span class="keyword">class</span>, <span class="title">BasicPersonDto</span>.<span class="title">class</span>)  </span></span><br><span class="line">   .field("name.first", "firstName")</span><br><span class="line">   .register();</span><br></pre></td></tr></table></figure><h2 id="自定义转换器"><a class="markdownIt-Anchor" href="#自定义转换器"></a> 自定义转换器</h2><p>orika同样支持自定义转换器，将指定类型或指定名称的属性做映射时添加自定义操作，例如，将String类型的或某个属性映射后加一个前缀，或者将Integer类型映射后加1等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConverter</span> <span class="keyword">extends</span> <span class="title">CustomConverter</span>&lt;<span class="title">Date</span>,<span class="title">MyDate</span>&gt; </span>&#123;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> MyDate <span class="title">convert</span><span class="params">(Date source, Type&lt;? extends MyDate&gt; destinationType)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// return a new instance of destinationType with all properties filled </span></span><br><span class="line">      <span class="comment">//example：source + 1；</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Date为源类型中要做转换的属性数据类型，例如String、Integer等，MyDate为目标类型中要做转换的属性数据类型</p><p>如果需要定义全局范围的转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConverterFactory converterFactory = mapperFactory.getConverterFactory();  </span><br><span class="line">converterFactory.registerConverter(<span class="keyword">new</span> MyConverter());</span><br></pre></td></tr></table></figure><p>如果仅需要某几个属性使用转换器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConverterFactory converterFactory = mapperFactory.getConverterFactory();  </span><br><span class="line">converterFactory.registerConverter(<span class="string">"myConverterIdValue"</span>, <span class="keyword">new</span> MyConverter());</span><br><span class="line"></span><br><span class="line">mapperFactory.classMap( Source<span class="class">.<span class="keyword">class</span>, <span class="title">Destination</span>.<span class="title">class</span> )  </span></span><br><span class="line">   .fieldMap("sourceField1", "sourceField2").converter("myConverterIdValue").add()</span><br><span class="line">   ...</span><br><span class="line">   .register();</span><br></pre></td></tr></table></figure><h2 id="其他说明"><a class="markdownIt-Anchor" href="#其他说明"></a> 其他说明</h2><ol><li><p>Orika支持递归映射，将映射嵌套类直到用“简单”类型完成映射。它还包含故障保险，以正确处理正在尝试映射的对象中的递归引用。</p></li><li><p>在于spring集成时，可以将MapperFactory设置为单例</p></li></ol><h1 id="各映射工具的性能测试"><a class="markdownIt-Anchor" href="#各映射工具的性能测试"></a> 各映射工具的性能测试</h1><p>构造一个包含普通类型及类类型的Bean对象,使用jmh微基准框架进行测试。由于jvm会对热点代码进行优化：方法反射调用次数超过阈值时会生成一个专用的MethodAccessor实现类，生成其中的invoke()方法的字节码进行执行。</p><p>故测试时每种方法先预热执行15次，而后再执行100次获取每次执行的平均时间：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Benchmark                     Mode  Samples   Score  Score error  Units  </span><br><span class="line">o.s.MyBenchmark.apache        avgt      100  25.246        0.535  us&#x2F;op  </span><br><span class="line">o.s.MyBenchmark.beanCopier    avgt      100   0.004        0.000  us&#x2F;op  </span><br><span class="line">o.s.MyBenchmark.byHand        avgt      100   0.004        0.000  us&#x2F;op  </span><br><span class="line">o.s.MyBenchmark.dozer         avgt      100   5.855        0.260  us&#x2F;op  </span><br><span class="line">o.s.MyBenchmark.orika         avgt      100   0.353        0.017  us&#x2F;op  </span><br><span class="line">o.s.MyBenchmark.spring        avgt      100   0.627        0.020  us&#x2F;op</span><br></pre></td></tr></table></figure><p>统计报告中Units单位为微秒/次，由Score项可以看出，基于ASM的cglib BeanCopier拷贝速度基本和手写get/set方法的速度无异，其次的就是基于javassist的Orika了，Orika的速度是spring BeanUtils的两倍，Dozer的20倍，Apache BeanUtils的120倍。</p><p>综上，当属性名和属性类型完全相同时使用BeanCopier是最好的选择，当存在属性名称不同或者属性名称相同但属性类型不同的情况时，使用Orika是一种不错的选择。如果你对Orika感到不放心，实际应用前可以写个测试类查看它的转换结果是否符合预期。</p><h1 id="原文链接"><a class="markdownIt-Anchor" href="#原文链接"></a> 原文链接</h1><p><a href="https://www.jianshu.com/p/40e0e64797b9" target="_blank" rel="noopener">https://www.jianshu.com/p/40e0e64797b9</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> BeanUtils </tag>
            
            <tag> Orika </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShardingSphere-JDBC原理与使用</title>
      <link href="/posts/e4c595e8/"/>
      <url>/posts/e4c595e8/</url>
      
        <content type="html"><![CDATA[<h1 id="shardingsphere-jdbc是什么"><a class="markdownIt-Anchor" href="#shardingsphere-jdbc是什么"></a> ShardingSphere-JDBC是什么</h1><p>ShardingSphere-JDBC（Sharding-JDBC）是一个分布式数据库中间件，定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。</p><ul><li>适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC。</li><li>支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等。</li><li>支持任意实现 JDBC 规范的数据库，目前支持 MySQL，Oracle，SQLServer，PostgreSQL 以及任何遵循 SQL92 标准的数据库。</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/1.png"  alt="ShardingSphere-JDBC" /></p><h1 id="shardingsphere-jdbc的核心功能"><a class="markdownIt-Anchor" href="#shardingsphere-jdbc的核心功能"></a> ShardingSphere-JDBC的核心功能</h1><h2 id="数据分片"><a class="markdownIt-Anchor" href="#数据分片"></a> 数据分片</h2><p>传统的将数据集中存储至单一数据节点的解决方案，在性能、可用性和运维成本这三方面已经难于满足互联网的海量数据场景。</p><p>从性能方面来说，由于关系型数据库大多采用 B+ 树类型的索引，在数据量超过阈值的情况下，索引深度的增加也将使得磁盘访问的 IO 次数增加，进而导致查询性能的下降；同时，高并发访问请求也使得集中式数据库成为系统的最大瓶颈。</p><p>从可用性的方面来讲，服务化的无状态型，能够达到较小成本的随意扩容，这必然导致系统的最终压力都落在数据库之上。而单一的数据节点，或者简单的主从架构，已经越来越难以承担。数据库的可用性，已成为整个系统的关键。</p><p>从运维成本方面考虑，当一个数据库实例中的数据达到阈值以上，对于 DBA 的运维压力就会增大。数据备份和恢复的时间成本都将随着数据量的大小而愈发不可控。一般来讲，单一数据库实例的数据的阈值在 1TB 之内，是比较合理的范围。</p><p>在传统的关系型数据库无法满足互联网场景需要的情况下，将数据存储至原生支持分布式的 NoSQL 的尝试越来越多。 但 NoSQL 对 SQL 的不兼容性以及生态圈的不完善，使得它们在与关系型数据库的博弈中始终无法完成致命一击，而关系型数据库的地位却依然不可撼动。</p><p>数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。 数据分片的有效手段是对关系型数据库进行分库和分表。分库和分表均可以有效的避免由数据量超过可承受阈值而产生的查询瓶颈。 除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库压力，但却能够提供尽量将分布式事务转化为本地事务的可能，一旦涉及到跨库的更新操作，分布式事务往往会使问题变得复杂。 使用多主多从的分片方式，可以有效的避免数据单点，从而提升数据架构的可用性。</p><p>通过分库和分表进行数据的拆分来使得各个表的数据量保持在阈值以下，以及对流量进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段。 数据分片的拆分方式又分为垂直分片和水平分片。</p><h3 id="垂直分片"><a class="markdownIt-Anchor" href="#垂直分片"></a> 垂直分片</h3><p>按照业务拆分的方式称为垂直分片，又称为纵向拆分，它的核心理念是专库专用。 在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是按照业务将表进行归类，分布到不同的数据库中，从而将压力分散至不同的数据库。 下图展示了根据业务需要，将用户表和订单表垂直分片到不同的数据库的方案。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/2.png"  alt="垂直分片" /><br />垂直分片往往需要对架构和设计进行调整。通常来讲，是来不及应对互联网业务需求快速变化的；而且，它也并无法真正的解决单点瓶颈。 垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理。</p><h3 id="水平分片"><a class="markdownIt-Anchor" href="#水平分片"></a> 水平分片</h3><p>水平分片又称为横向拆分。 相对于垂直分片，它不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分。 例如：根据主键分片，偶数主键的记录放入 0 库（或表），奇数主键的记录放入 1 库（或表），如下图所示。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/3.png"  alt="水平分片" /><br />水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是分库分表的标准解决方案。</p><h2 id="分布式事务"><a class="markdownIt-Anchor" href="#分布式事务"></a> 分布式事务</h2><p>数据库事务需要满足 ACID（原子性、一致性、隔离性、持久性）四个特性。</p><ul><li>原子性（Atomicity）指事务作为整体来执行，要么全部执行，要么全不执行。</li><li>一致性（Consistency）指事务应确保数据从一个一致的状态转变为另一个一致的状态。-</li><li>隔离性（Isolation）指多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li>持久性（Durability）指已提交的事务修改数据会被持久保存。<br />在单一数据节点中，事务仅限于对单一数据库资源的访问控制，称之为本地事务。几乎所有的成熟的关系型数据库都提供了对本地事务的原生支持。 但是在基于微服务的分布式应用环境下，越来越多的应用场景要求对多个服务的访问及其相对应的多个数据库资源能纳入到同一个事务当中，分布式事务应运而生。</li></ul><p>关系型数据库虽然对本地事务提供了完美的 ACID 原生支持。 但在分布式的场景下，它却成为系统性能的桎梏。如何让数据库在分布式场景下满足 ACID 的特性或找寻相应的替代方案，是分布式事务的重点工作。</p><h3 id="本地事务"><a class="markdownIt-Anchor" href="#本地事务"></a> 本地事务</h3><p>在不开启任何分布式事务管理器的前提下，让每个数据节点各自管理自己的事务。 它们之间没有协调以及通信的能力，也并不互相知晓其他数据节点事务的成功与否。 本地事务在性能方面无任何损耗，但在强一致性以及最终一致性方面则力不从心。</p><h3 id="两阶段提交"><a class="markdownIt-Anchor" href="#两阶段提交"></a> 两阶段提交</h3><p>XA协议最早的分布式事务模型是由 X/Open 国际联盟提出的 X/Open Distributed Transaction Processing (DTP) 模型，简称 XA 协议。</p><p>基于XA协议实现的分布式事务对业务侵入很小。 它最大的优势就是对使用方透明，用户可以像使用本地事务一样使用基于XA协议的分布式事务。 XA协议能够严格保障事务 ACID 特性。</p><p>严格保障事务 ACID 特性是一把双刃剑。 事务执行在过程中需要将所需资源全部锁定，它更加适用于执行时间确定的短事务。 对于长事务来说，整个事务进行期间对数据的独占，将导致对热点数据依赖的业务系统并发性能衰退明显。 因此，在高并发的性能至上场景中，基于XA协议的分布式事务并不是最佳选择。</p><h3 id="柔性事务"><a class="markdownIt-Anchor" href="#柔性事务"></a> 柔性事务</h3><p>如果将实现了 ACID 的事务要素的事务称为刚性事务的话，那么基于 BASE 事务要素的事务则称为柔性事务。 BASE 是基本可用、柔性状态和最终一致性这三个要素的缩写。</p><ul><li>基本可用（Basically Available）保证分布式事务参与方不一定同时在线。</li><li>柔性状态（Soft state）则允许系统状态更新有一定的延时，这个延时对客户来说不一定能够察觉。</li><li>而最终一致性（Eventually consistent）通常是通过消息传递的方式保证系统的最终一致性。<br />在 ACID 事务中对隔离性的要求很高，在事务执行过程中，必须将所有的资源锁定。 柔性事务的理念则是通过业务逻辑将互斥锁操作从资源层面上移至业务层面。通过放宽对强一致性要求，来换取系统吞吐量的提升。</li></ul><p>基于 ACID 的强一致性事务和基于 BASE 的最终一致性事务都不是银弹，只有在最适合的场景中才能发挥它们的最大长处。 可通过下表详细对比它们之间的区别，以帮助开发者进行技术选型。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/4.png"  alt="事务对比" /></p><h2 id="读写分离"><a class="markdownIt-Anchor" href="#读写分离"></a> 读写分离</h2><p>面对日益增加的系统访问量，数据库的吞吐量面临着巨大瓶颈。 对于同一时刻有大量并发读操作和较少写操作类型的应用系统来说，将数据库拆分为主库和从库，主库负责处理事务性的增删改操作，从库负责处理查询操作，能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。</p><p>通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。 使用多主多从的方式，不但能够提升系统的吞吐量，还能够提升系统的可用性，可以达到在任何一个数据库宕机，甚至磁盘物理损坏的情况下仍然不影响系统的正常运行。</p><p>与将数据根据分片键打散至各个数据节点的水平分片不同，读写分离则是根据SQL语义的分析，将读操作和写操作分别路由至主库与从库。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/5.png"  alt="读写分离" /><br />读写分离的数据节点中的数据内容是一致的，而水平分片的每个数据节点的数据内容却并不相同。将水平分片和读写分离联合使用，能够更加有效的提升系统性能。</p><h2 id="分布式治理"><a class="markdownIt-Anchor" href="#分布式治理"></a> 分布式治理</h2><p>随着数据规模的不断膨胀，使用多节点集群的分布式方式逐渐成为趋势。在这种情况下，如何高效、自动化管理集群节点，实现不同节点的协同工作，配置一致性，状态一致性，高可用性，可观测性等，就成为一个重要的挑战。</p><p>ShardingSphere通过三个模块：治理、可观测性、集群管理（计划中）来处理。</p><h1 id="核心概念"><a class="markdownIt-Anchor" href="#核心概念"></a> 核心概念</h1><h2 id="逻辑表"><a class="markdownIt-Anchor" href="#逻辑表"></a> 逻辑表</h2><p>水平拆分的数据库（表）的相同逻辑和数据结构表的总称。例：订单数据根据主键尾数拆分为 10 张表，分别是 t_order_0 到 t_order_9，他们的逻辑表名为 t_order。</p><h2 id="真实表"><a class="markdownIt-Anchor" href="#真实表"></a> 真实表</h2><p>在分片的数据库中真实存在的物理表。即上个示例中的 t_order_0 到 t_order_9。</p><h2 id="数据节点"><a class="markdownIt-Anchor" href="#数据节点"></a> 数据节点</h2><p>数据分片的最小单元。由数据源名称和数据表组成，例：ds_0.t_order_0。</p><h2 id="绑定表"><a class="markdownIt-Anchor" href="#绑定表"></a> 绑定表</h2><p>指分片规则一致的主表和子表。例如：t_order 表和 t_order_item 表，均按照 order_id 分片，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。举例说明，如果 SQL 为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order o <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>在不配置绑定表关系时，假设分片键 order_id 将数值 10 路由至第 0 片，将数值 11 路由至第 1 片，那么路由后的 SQL 应该为 4 条，它们呈现为笛卡尔积：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>在配置绑定表关系后，路由的 SQL 应该为 2 条：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>其中 t_order 在 FROM 的最左侧，ShardingSphere 将会以它作为整个绑定表的主表。 所有路由计算将会只使用主表的策略，那么 t_order_item 表的分片计算将会使用 t_order 的条件。故绑定表之间的分区键要完全相同。</p><h2 id="广播表"><a class="markdownIt-Anchor" href="#广播表"></a> 广播表</h2><p>指所有的分片数据源中都存在的表，表结构和表中的数据在每个数据库中均完全一致。适用于数据量不大且需要与海量数据的表进行关联查询的场景，例如：字典表。</p><h2 id="分片键"><a class="markdownIt-Anchor" href="#分片键"></a> 分片键</h2><p>用于分片的数据库字段，是将数据库（表）水平拆分的关键字段。例：将订单表中的订单主键的尾数取模分片，则订单主键为分片字段。 SQL 中如果无分片字段，将执行全路由，性能较差。 除了对单分片字段的支持，Apache ShardingSphere 也支持根据多个字段进行分片。</p><h2 id="分片算法"><a class="markdownIt-Anchor" href="#分片算法"></a> 分片算法</h2><p>通过分片算法将数据分片，支持通过 =、&gt;=、&lt;=、&gt;、&lt;、BETWEEN 和 IN 分片。 分片算法需要应用方开发者自行实现，可实现的灵活度非常高。</p><p>目前提供4种分片算法。 由于分片算法和业务实现紧密相关，因此并未提供内置分片算法，而是通过分片策略将各种场景提炼出来，提供更高层级的抽象，并提供接口让应用开发者自行实现分片算法。</p><ul><li><p>标准分片算法<br />对应 StandardShardingAlgorithm，用于处理使用单一键作为分片键的 =、IN、BETWEEN AND、&gt;、&lt;、&gt;=、&lt;=进行分片的场景。需要配合 StandardShardingStrategy 使用。</p></li><li><p>复合分片算法<br />对应 ComplexKeysShardingAlgorithm，用于处理使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度。需要配合 ComplexShardingStrategy 使用。</p></li><li><p>Hint分片算法<br />对应 HintShardingAlgorithm，用于处理使用 Hint 行分片的场景。需要配合 HintShardingStrategy 使用。</p></li></ul><h2 id="分片策略"><a class="markdownIt-Anchor" href="#分片策略"></a> 分片策略</h2><p>包含分片键和分片算法，由于分片算法的独立性，将其独立抽离。真正可用于分片操作的是分片键 + 分片算法，也就是分片策略。目前提供 5 种分片策略。</p><ul><li><p>标准分片策略<br />对应 StandardShardingStrategy。提供对 SQ L语句中的 =, &gt;, &lt;, &gt;=, &lt;=, IN 和 BETWEEN AND 的分片操作支持。 StandardShardingStrategy 只支持单分片键，提供 PreciseShardingAlgorithm 和 RangeShardingAlgorithm 两个分片算法。 PreciseShardingAlgorithm 是必选的，用于处理 = 和 IN 的分片。 RangeShardingAlgorithm 是可选的，用于处理 BETWEEN AND, &gt;, &lt;, &gt;=, &lt;=分片，如果不配置 RangeShardingAlgorithm，SQL 中的 BETWEEN AND 将按照全库路由处理。</p></li><li><p>复合分片策略<br />对应 ComplexShardingStrategy。复合分片策略。提供对 SQL 语句中的 =, &gt;, &lt;, &gt;=, &lt;=, IN 和 BETWEEN AND 的分片操作支持。 ComplexShardingStrategy 支持多分片键，由于多分片键之间的关系复杂，因此并未进行过多的封装，而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度。</p></li><li><p>Hint分片策略<br />对应 HintShardingStrategy。通过 Hint 指定分片值而非从 SQL 中提取分片值的方式进行分片的策略。</p></li><li><p>不分片策略<br />对应 NoneShardingStrategy。不分片的策略。</p></li></ul><h2 id="sql-hint"><a class="markdownIt-Anchor" href="#sql-hint"></a> SQL Hint</h2><p>对于分片字段非 SQL 决定，而由其他外置条件决定的场景，可使用 SQL Hint 灵活的注入分片字段。 例：内部系统，按照员工登录主键分库，而数据库中并无此字段。SQL Hint 支持通过 Java API 和 SQL 注释（待实现）两种方式使用。 详情请参见强制分片路由。</p><h2 id="分布式主键"><a class="markdownIt-Anchor" href="#分布式主键"></a> 分布式主键</h2><p>详见<a href="https://shardingsphere.apache.org/document/current/cn/features/sharding/concept/key-generator/" target="_blank" rel="noopener">分布式主键</a></p><h1 id="shardingsphere-jdbc内核剖析"><a class="markdownIt-Anchor" href="#shardingsphere-jdbc内核剖析"></a> ShardingSphere-JDBC内核剖析</h1><p>ShardingSphere-JDBC核心由 <code>SQL 解析 =&gt; SQL 路由 =&gt; SQL 改写 =&gt; SQL 执行 =&gt; 结果归并</code>的流程组成，如下图：<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/6.png"  alt="ShardingSphere-JDBC核心流程" /></p><h2 id="sql解析"><a class="markdownIt-Anchor" href="#sql解析"></a> SQL解析</h2><p>SQL解析过程分为词法解析和语法解析。 词法解析器用于将 SQL 拆解为不可再分的原子符号，称为 Token。并根据不同数据库方言所提供的字典，将其归类为关键字，表达式，字面量和操作符。 再使用语法解析器将 SQL 转换为抽象语法树。<br />例如，以下 SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> <span class="keyword">status</span> = <span class="string">'ACTIVE'</span> <span class="keyword">AND</span> age &gt; <span class="number">18</span></span><br></pre></td></tr></table></figure><p>解析之后的为抽象语法树见下图。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/7.png"  alt="sql解析" /><br />为了便于理解，抽象语法树中的关键字的 Token 用绿色表示，变量的 Token 用红色表示，灰色表示需要进一步拆分。</p><p>最后，通过对抽象语法树的遍历去提炼分片所需的上下文，并标记有可能需要改写的位置。 供分片使用的解析上下文包含查询选择项（Select Items）、表信息（Table）、分片条件（Sharding Condition）、自增主键信息（Auto increment Primary Key）、排序信息（Order By）、分组信息（Group By）以及分页信息（Limit、Rownum、Top）。 SQL 的一次解析过程是不可逆的，一个个 Token 按 SQL 原本的顺序依次进行解析，性能很高。 考虑到各种数据库 SQL 方言的异同，在解析模块提供了各类数据库的 SQL 方言字典。</p><h2 id="sql-路由"><a class="markdownIt-Anchor" href="#sql-路由"></a> SQL 路由</h2><p>根据解析上下文匹配数据库和表的分片策略，并生成路由路径。 对于携带分片键的 SQL，根据分片键的不同可以划分为单片路由(分片键的操作符是等号)、多片路由(分片键的操作符是 IN)和范围路由(分片键的操作符是 BETWEEN)。 不携带分片键的 SQL 则采用广播路由。</p><p>分片策略通常可以采用由数据库内置或由用户方配置。 数据库内置的方案较为简单，内置的分片策略大致可分为尾数取模、哈希、范围、标签、时间等。 由用户方配置的分片策略则更加灵活，可以根据使用方需求定制复合分片策略。 如果配合数据自动迁移来使用，可以做到无需用户关注分片策略，自动由数据库中间层分片和平衡数据即可，进而做到使分布式数据库具有的弹性伸缩的能力。 在 ShardingSphere 的线路规划中，弹性伸缩将于 4.x 开启。</p><h3 id="分片路由"><a class="markdownIt-Anchor" href="#分片路由"></a> 分片路由</h3><p>用于根据分片键进行路由的场景，又细分为直接路由、标准路由和笛卡尔积路由这 3 种类型。</p><h4 id="直接路由"><a class="markdownIt-Anchor" href="#直接路由"></a> 直接路由</h4><p>满足直接路由的条件相对苛刻，它需要通过 Hint（使用 HintAPI 直接指定路由至库表）方式分片，并且是只分库不分表的前提下，则可以避免 SQL 解析和之后的结果归并。 因此它的兼容性最好，可以执行包括子查询、自定义函数等复杂情况的任意 SQL。直接路由还可以用于分片键不在 SQL 中的场景。例如，设置用于数据库分片的键为 3，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hintManager.setDatabaseShardingValue(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>假如路由算法为 value % 2，当一个逻辑库 t_order 对应 2 个真实库 t_order_0 和 t_order_1 时，路由后 SQL 将在 t_order_1 上执行。下方是使用 API 的代码样例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"SELECT * FROM t_order"</span>;</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">        HintManager hintManager = HintManager.getInstance();</span><br><span class="line">        Connection conn = dataSource.getConnection();</span><br><span class="line">        PreparedStatement pstmt = conn.prepareStatement(sql)) &#123;</span><br><span class="line">    hintManager.setDatabaseShardingValue(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">try</span> (ResultSet rs = pstmt.executeQuery()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准路由"><a class="markdownIt-Anchor" href="#标准路由"></a> 标准路由</h4><p>标准路由是 ShardingSphere 最为推荐使用的分片方式，它的适用范围是不包含关联查询或仅包含绑定表之间关联查询的 SQL。 当分片运算符是等于号时，路由结果将落入单库（表），当分片运算符是 BETWEEN 或 IN 时，则路由结果不一定落入唯一的库（表），因此一条逻辑 SQL 最终可能被拆分为多条用于执行的真实 SQL。 举例说明，如果按照 order_id 的奇数和偶数进行数据分片，一个单表查询的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>那么路由的结果应为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_0 <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_1 <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>绑定表的关联查询与单表查询复杂度和性能相当。举例说明，如果一个包含绑定表的关联查询的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o.order_id=i.order_id  <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>那么路由的结果应为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id  <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id  <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>可以看到，SQL 拆分的数目与单表是一致的。</p><h4 id="笛卡尔路由"><a class="markdownIt-Anchor" href="#笛卡尔路由"></a> 笛卡尔路由</h4><p>笛卡尔路由是最复杂的情况，它无法根据绑定表的关系定位分片规则，因此非绑定表之间的关联查询需要拆解为笛卡尔积组合执行。 如果上个示例中的 SQL 并未配置绑定表关系，那么路由的结果应为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id  <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id  <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id  <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id  <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>笛卡尔路由查询性能较低，需谨慎使用。</p><h3 id="广播路由"><a class="markdownIt-Anchor" href="#广播路由"></a> 广播路由</h3><p>对于不携带分片键的 SQL，则采取广播路由的方式。根据 SQL 类型又可以划分为全库表路由、全库路由、全实例路由、单播路由和阻断路由这 5 种类型。</p><h4 id="全库表路由"><a class="markdownIt-Anchor" href="#全库表路由"></a> 全库表路由</h4><p>全库表路由用于处理对数据库中与其逻辑表相关的所有真实表的操作，主要包括不带分片键的 DQL 和 DML，以及 DDL 等。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>则会遍历所有数据库中的所有表，逐一匹配逻辑表和真实表名，能够匹配得上则执行。路由后成为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_0 <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_1 <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_2 <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_3 <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="全库路由"><a class="markdownIt-Anchor" href="#全库路由"></a> 全库路由</h4><p>全库路由用于处理对数据库的操作，包括用于库设置的 SET 类型的数据库管理命令，以及 TCL 这样的事务控制语句。 在这种情况下，会根据逻辑库的名字遍历所有符合名字匹配的真实库，并在真实库中执行该命令，例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>在 t_order 中执行，t_order 有 2 个真实库。则实际会在 t_order_0 和 t_order_1 上都执行这个命令。</p><h4 id="全实例路由"><a class="markdownIt-Anchor" href="#全实例路由"></a> 全实例路由</h4><p>全实例路由用于 DCL 操作，授权语句针对的是数据库的实例。无论一个实例中包含多少个 Schema，每个数据库的实例只执行一次。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> customer@<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="keyword">identified</span> <span class="keyword">BY</span> <span class="string">'123'</span>;</span><br></pre></td></tr></table></figure><p>这个命令将在所有的真实数据库实例中执行，以确保 customer 用户可以访问每一个实例。</p><h4 id="单播路由"><a class="markdownIt-Anchor" href="#单播路由"></a> 单播路由</h4><p>单播路由用于获取某一真实表信息的场景，它仅需要从任意库中的任意真实表中获取数据即可。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> t_order;</span><br></pre></td></tr></table></figure><p>t_order 的两个真实表 t_order_0，t_order_1 的描述结构相同，所以这个命令在任意真实表上选择执行一次。</p><h4 id="阻断路由"><a class="markdownIt-Anchor" href="#阻断路由"></a> 阻断路由</h4><p>阻断路由用于屏蔽 SQL 对数据库的操作，例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> order_db;</span><br></pre></td></tr></table></figure><p>这个命令不会在真实数据库中执行，因为 ShardingSphere 采用的是逻辑 Schema 的方式，无需将切换数据库 Schema 的命令发送至数据库中。</p><p>路由引擎的整体结构划分如下图。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/8.png"  alt="路由引擎" /></p><h2 id="sql改写"><a class="markdownIt-Anchor" href="#sql改写"></a> sql改写</h2><p>工程师面向逻辑库与逻辑表书写的 SQL，并不能够直接在真实的数据库中执行，SQL 改写用于将逻辑 SQL 改写为在真实数据库中可以正确执行的 SQL。 它包括正确性改写和优化改写两部分</p><h3 id="正确性改写"><a class="markdownIt-Anchor" href="#正确性改写"></a> 正确性改写</h3><p>在包含分表的场景中，需要将分表配置中的逻辑表名称改写为路由之后所获取的真实表名称。仅分库则不需要表名称的改写。除此之外，还包括补列和分页信息修正等内容。</p><h3 id="标识符改写"><a class="markdownIt-Anchor" href="#标识符改写"></a> 标识符改写</h3><p>需要改写的标识符包括表名称、索引名称以及 Schema 名称。</p><p>表名称改写是指将找到逻辑表在原始 SQL 中的位置，并将其改写为真实表的过程。表名称改写是一个典型的需要对 SQL 进行解析的场景。 从一个最简单的例子开始，若逻辑 SQL 为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> order_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>假设该 SQL 配置分片键 order_id，并且 order_id=1 的情况，将路由至分片表 1。那么改写之后的 SQL 应该为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id <span class="keyword">FROM</span> t_order_1 <span class="keyword">WHERE</span> order_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在这种最简单的 SQL 场景中，是否将 SQL 解析为抽象语法树似乎无关紧要，只要通过字符串查找和替换就可以达到 SQL 改写的效果。 但是下面的场景，就无法仅仅通过字符串的查找替换来正确的改写 SQL 了：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> order_id=<span class="number">1</span> <span class="keyword">AND</span> remarks=<span class="string">' t_order xxx'</span>;</span><br></pre></td></tr></table></figure><p>正确改写的 SQL 应该是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id <span class="keyword">FROM</span> t_order_1 <span class="keyword">WHERE</span> order_id=<span class="number">1</span> <span class="keyword">AND</span> remarks=<span class="string">' t_order xxx'</span>;</span><br></pre></td></tr></table></figure><p>而非：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id <span class="keyword">FROM</span> t_order_1 <span class="keyword">WHERE</span> order_id=<span class="number">1</span> <span class="keyword">AND</span> remarks=<span class="string">' t_order_1 xxx'</span>;</span><br></pre></td></tr></table></figure><p>由于表名之外可能含有表名称的类似字符，因此不能通过简单的字符串替换的方式去改写 SQL。</p><p>下面再来看一个更加复杂的 SQL 改写场景：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t_order.order_id <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> t_order.order_id=<span class="number">1</span> <span class="keyword">AND</span> remarks=<span class="string">' t_order xxx'</span>;</span><br></pre></td></tr></table></figure><p>上面的 SQL 将表名作为字段的标识符，因此在 SQL 改写时需要一并修改：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t_order_1.order_id <span class="keyword">FROM</span> t_order_1 <span class="keyword">WHERE</span> t_order_1.order_id=<span class="number">1</span> <span class="keyword">AND</span> remarks=<span class="string">' t_order xxx'</span>;</span><br></pre></td></tr></table></figure><p>而如果 SQL 中定义了表的别名，则无需连同别名一起修改，即使别名与表名相同亦是如此。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t_order.order_id <span class="keyword">FROM</span> t_order <span class="keyword">AS</span> t_order <span class="keyword">WHERE</span> t_order.order_id=<span class="number">1</span> <span class="keyword">AND</span> remarks=<span class="string">' t_order xxx'</span>;</span><br></pre></td></tr></table></figure><p>SQL 改写则仅需要改写表名称就可以了：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t_order.order_id <span class="keyword">FROM</span> t_order_1 <span class="keyword">AS</span> t_order <span class="keyword">WHERE</span> t_order.order_id=<span class="number">1</span> <span class="keyword">AND</span> remarks=<span class="string">' t_order xxx'</span>;</span><br></pre></td></tr></table></figure><p>索引名称是另一个有可能改写的标识符。 在某些数据库中（如 MySQL、SQLServer），索引是以表为维度创建的，在不同的表中的索引是可以重名的； 而在另外的一些数据库中（如 PostgreSQL、Oracle），索引是以数据库为维度创建的，即使是作用在不同表上的索引，它们也要求其名称的唯一性。</p><p>在 ShardingSphere 中，管理 Schema 的方式与管理表如出一辙，它采用逻辑 Schema 去管理一组数据源。 因此，ShardingSphere 需要将用户在 SQL 中书写的逻辑 Schema 替换为真实的数据库 Schema。</p><p>ShardingSphere 目前还不支持在 DQL 和 DML 语句中使用 Schema。 它目前仅支持在数据库管理语句中使用 Schema，例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> t_order <span class="keyword">FROM</span> order_ds;</span><br></pre></td></tr></table></figure><p>Schema 的改写指的是将逻辑 Schema 采用单播路由的方式，改写为随机查找到的一个正确的真实 Schema。</p><h3 id="补列"><a class="markdownIt-Anchor" href="#补列"></a> 补列</h3><p>需要在查询语句中补列通常由两种情况导致。 第一种情况是 ShardingSphere 需要在结果归并时获取相应数据，但该数据并未能通过查询的 SQL 返回。 这种情况主要是针对 GROUP BY 和 ORDER BY。结果归并时，需要根据 GROUP BY 和 ORDER BY 的字段项进行分组和排序，但如果原始 SQL 的选择项中若并未包含分组项或排序项，则需要对原始 SQL 进行改写。 先看一下原始 SQL 中带有结果归并所需信息的场景：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id, user_id <span class="keyword">FROM</span> t_order <span class="keyword">ORDER</span> <span class="keyword">BY</span> user_id;</span><br></pre></td></tr></table></figure><p>由于使用 user_id 进行排序，在结果归并中需要能够获取到 user_id 的数据，而上面的 SQL 是能够获取到 user_id 数据的，因此无需补列。</p><p>如果选择项中不包含结果归并时所需的列，则需要进行补列，如以下 SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id <span class="keyword">FROM</span> t_order <span class="keyword">ORDER</span> <span class="keyword">BY</span> user_id;</span><br></pre></td></tr></table></figure><p>由于原始 SQL 中并不包含需要在结果归并中需要获取的 user_id，因此需要对 SQL 进行补列改写。补列之后的 SQL 是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id, user_id <span class="keyword">AS</span> ORDER_BY_DERIVED_0 <span class="keyword">FROM</span> t_order <span class="keyword">ORDER</span> <span class="keyword">BY</span> user_id;</span><br></pre></td></tr></table></figure><p>值得一提的是，补列只会补充缺失的列，不会全部补充，而且，在 SELECT 语句中包含 * 的 SQL，也会根据表的元数据信息选择性补列。下面是一个较为复杂的 SQL 补列场景：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> o.* <span class="keyword">FROM</span> t_order o, t_order_item i <span class="keyword">WHERE</span> o.order_id=i.order_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> user_id, order_item_id;</span><br></pre></td></tr></table></figure><p>我们假设只有 t_order_item 表中包含 order_item_id 列，那么根据表的元数据信息可知，在结果归并时，排序项中的 user_id 是存在于 t_order 表中的，无需补列；order_item_id 并不在 t_order 中，因此需要补列。 补列之后的 SQL 是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> o.*, order_item_id <span class="keyword">AS</span> ORDER_BY_DERIVED_0 <span class="keyword">FROM</span> t_order o, t_order_item i <span class="keyword">WHERE</span> o.order_id=i.order_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> user_id, order_item_id;</span><br></pre></td></tr></table></figure><p>补列的另一种情况是使用 AVG 聚合函数。在分布式的场景中，使用 avg1 + avg2 + avg3 / 3 计算平均值并不正确，需要改写为 (sum1 + sum2 + sum3) / (count1 + count2 + count3)。 这就需要将包含 AVG 的 SQL 改写为 SUM 和 COUNT，并在结果归并时重新计算平均值。例如以下 SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(price) <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> user_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>需要改写为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(price) <span class="keyword">AS</span> AVG_DERIVED_COUNT_0, <span class="keyword">SUM</span>(price) <span class="keyword">AS</span> AVG_DERIVED_SUM_0 <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> user_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>然后才能够通过结果归并正确的计算平均值。</p><p>最后一种补列是在执行 INSERT 的 SQL 语句时，如果使用数据库自增主键，是无需写入主键字段的。 但数据库的自增主键是无法满足分布式场景下的主键唯一的，因此 ShardingSphere 提供了分布式自增主键的生成策略，并且可以通过补列，让使用方无需改动现有代码，即可将分布式自增主键透明的替换数据库现有的自增主键。 分布式自增主键的生成策略将在下文中详述，这里只阐述与 SQL 改写相关的内容。 举例说明，假设表 t_order 的主键是 order_id，原始的 SQL 为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order (<span class="string">`field1`</span>, <span class="string">`field2`</span>) <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>可以看到，上述 SQL 中并未包含自增主键，是需要数据库自行填充的。ShardingSphere 配置自增主键后，SQL 将改写为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order (<span class="string">`field1`</span>, <span class="string">`field2`</span>, order_id) <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="number">1</span>, xxxxx);</span><br></pre></td></tr></table></figure><p>改写后的 SQL 将在 INSERT FIELD 和 INSERT VALUE 的最后部分增加主键列名称以及自动生成的自增主键值。上述 SQL 中的 xxxxx 表示自动生成的自增主键值。</p><p>如果 INSERT 的 SQL 中并未包含表的列名称，ShardingSphere 也可以根据判断参数个数以及表元信息中的列数量对比，并自动生成自增主键。例如，原始的 SQL 为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>改写的 SQL 将只在主键所在的列顺序处增加自增主键即可：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order <span class="keyword">VALUES</span> (xxxxx, <span class="number">10</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>自增主键补列时，如果使用占位符的方式书写 SQL，则只需要改写参数列表即可，无需改写 SQL 本身。</p><h3 id="分页修正"><a class="markdownIt-Anchor" href="#分页修正"></a> 分页修正</h3><p>从多个数据库获取分页数据与单数据库的场景是不同的。 假设每 10 条数据为一页，取第 2 页数据。在分片环境下获取 LIMIT 10, 10，归并之后再根据排序条件取出前 10 条数据是不正确的。 举例说明，若 SQL 为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> score <span class="keyword">FROM</span> t_score <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>, <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>下图展示了不进行 SQL 的改写的分页执行结果。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/9.png"  alt="sql分页改写前" /><br />通过图中所示，想要取得两个表中共同的按照分数排序的第 2 条和第 3 条数据，应该是 95 和 90。 由于执行的 SQL 只能从每个表中获取第 2 条和第 3 条数据，即从 t_score_0 表中获取的是 90 和 80；从 t_score_0 表中获取的是 85 和 75。 因此进行结果归并时，只能从获取的 90，80，85 和 75 之中进行归并，那么结果归并无论怎么实现，都不可能获得正确的结果。</p><p>正确的做法是将分页条件改写为 LIMIT 0, 3，取出所有前两页数据，再结合排序条件计算出正确的数据。 下图展示了进行 SQL 改写之后的分页执行结果。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/10.png"  alt="sql分页改写后" /><br />越获取偏移量位置靠后数据，使用 LIMIT 分页方式的效率就越低。 有很多方法可以避免使用 LIMIT 进行分页。比如构建行记录数量与行偏移量的二级索引，或使用上次分页数据结尾 ID 作为下次查询条件的分页方式等。</p><p>分页信息修正时，如果使用占位符的方式书写 SQL，则只需要改写参数列表即可，无需改写 SQL 本身。</p><h3 id="批量拆分"><a class="markdownIt-Anchor" href="#批量拆分"></a> 批量拆分</h3><p>在使用批量插入的 SQL 时，如果插入的数据是跨分片的，那么需要对 SQL 进行改写来防止将多余的数据写入到数据库中。 插入操作与查询操作的不同之处在于，查询语句中即使用了不存在于当前分片的分片键，也不会对数据产生影响；而插入操作则必须将多余的分片键删除。 举例说明，如下 SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order (order_id, xxx) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'xxx'</span>), (<span class="number">2</span>, <span class="string">'xxx'</span>), (<span class="number">3</span>, <span class="string">'xxx'</span>);</span><br></pre></td></tr></table></figure><p>假设数据库仍然是按照 order_id 的奇偶值分为两片的，仅将这条 SQL 中的表名进行修改，然后发送至数据库完成 SQL 的执行 ，则两个分片都会写入相同的记录。 虽然只有符合分片查询条件的数据才能够被查询语句取出，但存在冗余数据的实现方案并不合理。因此需要将 SQL 改写为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_0 (order_id, xxx) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'xxx'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_order_1 (order_id, xxx) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'xxx'</span>), (<span class="number">3</span>, <span class="string">'xxx'</span>);</span><br></pre></td></tr></table></figure><p>使用 IN 的查询与批量插入的情况相似，不过 IN 操作并不会导致数据查询结果错误。通过对 IN 查询的改写，可以进一步的提升查询性能。如以下 SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>改写为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_0 <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_1 <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>可以进一步的提升查询性能。ShardingSphere 暂时还未实现此改写策略，目前的改写结果是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_0 <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_1 <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>虽然 SQL 的执行结果是正确的，但并未达到最优的查询效率。</p><h3 id="优化改写"><a class="markdownIt-Anchor" href="#优化改写"></a> 优化改写</h3><p>优化改写的目的是在不影响查询正确性的情况下，对性能进行提升的有效手段。它分为单节点优化和流式归并优化。</p><h4 id="单节点优化"><a class="markdownIt-Anchor" href="#单节点优化"></a> 单节点优化</h4><p>路由至单节点的 SQL，则无需优化改写。 当获得一次查询的路由结果后，如果是路由至唯一的数据节点，则无需涉及到结果归并。因此补列和分页信息等改写都没有必要进行。 尤其是分页信息的改写，无需将数据从第 1 条开始取，大量的降低了对数据库的压力，并且节省了网络带宽的无谓消耗。</p><h4 id="流式归并优化"><a class="markdownIt-Anchor" href="#流式归并优化"></a> 流式归并优化</h4><p>它仅为包含 GROUP BY 的 SQL 增加 ORDER BY 以及和分组项相同的排序项和排序顺序，用于将内存归并转化为流式归并。 在结果归并的部分中，将对流式归并和内存归并进行详细说明。</p><p>改写引擎的整体结构划分如下图所示。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/11.png"  alt="sql改写引擎" /></p><h2 id="sql执行"><a class="markdownIt-Anchor" href="#sql执行"></a> sql执行</h2><p>ShardingSphere 采用一套自动化的执行引擎，负责将路由和改写完成之后的真实 SQL 安全且高效发送到底层数据源执行。 它不是简单地将 SQL 通过 JDBC 直接发送至数据源执行；也并非直接将执行请求放入线程池去并发执行。它更关注平衡数据源连接创建以及内存占用所产生的消耗，以及最大限度地合理利用并发等问题。 执行引擎的目标是自动化的平衡资源控制与执行效率。</p><h3 id="连接模式"><a class="markdownIt-Anchor" href="#连接模式"></a> 连接模式</h3><p>从资源控制的角度看，业务方访问数据库的连接数量应当有所限制。 它能够有效地防止某一业务操作过多的占用资源，从而将数据库连接的资源耗尽，以致于影响其他业务的正常访问。 特别是在一个数据库实例中存在较多分表的情况下，一条不包含分片键的逻辑 SQL 将产生落在同库不同表的大量真实 SQL ，如果每条真实SQL都占用一个独立的连接，那么一次查询无疑将会占用过多的资源。</p><p>从执行效率的角度看，为每个分片查询维持一个独立的数据库连接，可以更加有效的利用多线程来提升执行效率。 为每个数据库连接开启独立的线程，可以将 I/O 所产生的消耗并行处理。为每个分片维持一个独立的数据库连接，还能够避免过早的将查询结果数据加载至内存。 独立的数据库连接，能够持有查询结果集游标位置的引用，在需要获取相应数据时移动游标即可。</p><p>以结果集游标下移进行结果归并的方式，称之为流式归并，它无需将结果数据全数加载至内存，可以有效的节省内存资源，进而减少垃圾回收的频次。 当无法保证每个分片查询持有一个独立数据库连接时，则需要在复用该数据库连接获取下一张分表的查询结果集之前，将当前的查询结果集全数加载至内存。 因此，即使可以采用流式归并，在此场景下也将退化为内存归并。</p><p>一方面是对数据库连接资源的控制保护，一方面是采用更优的归并模式达到对中间件内存资源的节省，如何处理好两者之间的关系，是 ShardingSphere 执行引擎需要解决的问题。 具体来说，如果一条 SQL 在经过 ShardingSphere 的分片后，需要操作某数据库实例下的 200 张表。 那么，是选择创建 200 个连接并行执行，还是选择创建一个连接串行执行呢？效率与资源控制又应该如何抉择呢？</p><p>针对上述场景，ShardingSphere 提供了一种解决思路。 它提出了连接模式（Connection Mode）的概念，将其划分为内存限制模式（MEMORY_STRICTLY）和连接限制模式（CONNECTION_STRICTLY）这两种类型。</p><h4 id="内存限制模式"><a class="markdownIt-Anchor" href="#内存限制模式"></a> 内存限制模式</h4><p>使用此模式的前提是，ShardingSphere 对一次操作所耗费的数据库连接数量不做限制。 如果实际执行的 SQL 需要对某数据库实例中的 200 张表做操作，则对每张表创建一个新的数据库连接，并通过多线程的方式并发处理，以达成执行效率最大化。 并且在 SQL 满足条件情况下，优先选择流式归并，以防止出现内存溢出或避免频繁垃圾回收情况。</p><h4 id="连接限制模式"><a class="markdownIt-Anchor" href="#连接限制模式"></a> 连接限制模式</h4><p>使用此模式的前提是，ShardingSphere 严格控制对一次操作所耗费的数据库连接数量。 如果实际执行的 SQL 需要对某数据库实例中的 200 张表做操作，那么只会创建唯一的数据库连接，并对其 200 张表串行处理。 如果一次操作中的分片散落在不同的数据库，仍然采用多线程处理对不同库的操作，但每个库的每次操作仍然只创建一个唯一的数据库连接。 这样即可以防止对一次请求对数据库连接占用过多所带来的问题。该模式始终选择内存归并。</p><p>内存限制模式适用于 OLAP 操作，可以通过放宽对数据库连接的限制提升系统吞吐量； 连接限制模式适用于 OLTP 操作，OLTP 通常带有分片键，会路由到单一的分片，因此严格控制数据库连接，以保证在线系统数据库资源能够被更多的应用所使用，是明智的选择。</p><h3 id="自动化执行引擎"><a class="markdownIt-Anchor" href="#自动化执行引擎"></a> 自动化执行引擎</h3><p>ShardingSphere 最初将使用何种模式的决定权交由用户配置，让开发者依据自己业务的实际场景需求选择使用内存限制模式或连接限制模式。</p><p>这种解决方案将两难的选择的决定权交由用户，使得用户必须要了解这两种模式的利弊，并依据业务场景需求进行选择。 这无疑增加了用户对 ShardingSphere 的学习和使用的成本，并非最优方案。</p><p>这种一分为二的处理方案，将两种模式的切换交由静态的初始化配置，是缺乏灵活应对能力的。在实际的使用场景中，面对不同 SQL 以及占位符参数，每次的路由结果是不同的。 这就意味着某些操作可能需要使用内存归并，而某些操作则可能选择流式归并更优，具体采用哪种方式不应该由用户在 ShardingSphere 启动之前配置好，而是应该根据 SQL 和占位符参数的场景，来动态的决定连接模式。</p><p>为了降低用户的使用成本以及连接模式动态化这两个问题，ShardingSphere 提炼出自动化执行引擎的思路，在其内部消化了连接模式概念。 用户无需了解所谓的内存限制模式和连接限制模式是什么，而是交由执行引擎根据当前场景自动选择最优的执行方案。</p><p>自动化执行引擎将连接模式的选择粒度细化至每一次 SQL 的操作。 针对每次 SQL 请求，自动化执行引擎都将根据其路由结果，进行实时的演算和权衡，并自主地采用恰当的连接模式执行，以达到资源控制和效率的最优平衡。 针对自动化的执行引擎，用户只需配置 maxConnectionSizePerQuery 即可，该参数表示一次查询时每个数据库所允许使用的最大连接数。</p><p>执行引擎分为准备和执行两个阶段。</p><h4 id="准备阶段"><a class="markdownIt-Anchor" href="#准备阶段"></a> 准备阶段</h4><p>顾名思义，此阶段用于准备执行的数据。它分为结果集分组和执行单元创建两个步骤。</p><p>结果集分组是实现内化连接模式概念的关键。执行引擎根据 maxConnectionSizePerQuery 配置项，结合当前路由结果，选择恰当的连接模式。 具体步骤如下：</p><p>将 SQL 的路由结果按照数据源的名称进行分组。</p><p>通过下图的公式，可以获得每个数据库实例在 maxConnectionSizePerQuery 的允许范围内，每个连接需要执行的 SQL 路由结果组，并计算出本次请求的最优连接模式。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/12.png"  alt="连接模式" /><br />在 maxConnectionSizePerQuery 允许的范围内，当一个连接需要执行的请求数量大于 1 时，意味着当前的数据库连接无法持有相应的数据结果集，则必须采用内存归并； 反之，当一个连接需要执行的请求数量等于 1 时，意味着当前的数据库连接可以持有相应的数据结果集，则可以采用流式归并。</p><p>每一次的连接模式的选择，是针对每一个物理数据库的。也就是说，在同一次查询中，如果路由至一个以上的数据库，每个数据库的连接模式不一定一样，它们可能是混合存在的形态。</p><p>通过上一步骤获得的路由分组结果创建执行的单元。 当数据源使用数据库连接池等控制数据库连接数量的技术时，在获取数据库连接时，如果不妥善处理并发，则有一定几率发生死锁。 在多个请求相互等待对方释放数据库连接资源时，将会产生饥饿等待，造成交叉的死锁问题。</p><p>举例说明，假设一次查询需要在某一数据源上获取两个数据库连接，并路由至同一个数据库的两个分表查询。 则有可能出现查询 A 已获取到该数据源的 1 个数据库连接，并等待获取另一个数据库连接；而查询 B 也已经在该数据源上获取到的一个数据库连接，并同样等待另一个数据库连接的获取。 如果数据库连接池的允许最大连接数是 2，那么这 2 个查询请求将永久的等待下去。下图描绘了死锁的情况。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/13.png"  alt="死锁" /><br />ShardingSphere 为了避免死锁的出现，在获取数据库连接时进行了同步处理。 它在创建执行单元时，以原子性的方式一次性获取本次 SQL 请求所需的全部数据库连接，杜绝了每次查询请求获取到部分资源的可能。 由于对数据库的操作非常频繁，每次获取数据库连接时时都进行锁定，会降低 ShardingSphere 的并发。因此，ShardingSphere 在这里进行了 2 点优化：</p><ol><li><p>避免锁定一次性只需要获取1个数据库连接的操作。因为每次仅需要获取 1 个连接，则不会发生两个请求相互等待的场景，无需锁定。 对于大部分 OLTP 的操作，都是使用分片键路由至唯一的数据节点，这会使得系统变为完全无锁的状态，进一步提升了并发效率。 除了路由至单分片的情况，读写分离也在此范畴之内。</p></li><li><p>仅针对内存限制模式时才进行资源锁定。在使用连接限制模式时，所有的查询结果集将在装载至内存之后释放掉数据库连接资源，因此不会产生死锁等待的问题。</p></li></ol><h4 id="执行阶段"><a class="markdownIt-Anchor" href="#执行阶段"></a> 执行阶段</h4><p>该阶段用于真正的执行 SQL，它分为分组执行和归并结果集生成两个步骤。</p><p>分组执行将准备执行阶段生成的执行单元分组下发至底层并发执行引擎，并针对执行过程中的每个关键步骤发送事件。 如：执行开始事件、执行成功事件以及执行失败事件。执行引擎仅关注事件的发送，它并不关心事件的订阅者。 ShardingSphere 的其他模块，如：分布式事务、调用链路追踪等，会订阅感兴趣的事件，并进行相应的处理。</p><p>ShardingSphere 通过在执行准备阶段的获取的连接模式，生成内存归并结果集或流式归并结果集，并将其传递至结果归并引擎，以进行下一步的工作。</p><p>执行引擎的整体结构划分如下图所示。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/14.png"  alt="执行引擎" /></p><h2 id="结果归并"><a class="markdownIt-Anchor" href="#结果归并"></a> 结果归并</h2><p>将从各个数据节点获取的多数据结果集，组合成为一个结果集并正确的返回至请求客户端，称为结果归并。</p><p>ShardingSphere 支持的结果归并从功能上分为遍历、排序、分组、分页和聚合 5 种类型，它们是组合而非互斥的关系。 从结构划分，可分为流式归并、内存归并和装饰者归并。流式归并和内存归并是互斥的，装饰者归并可以在流式归并和内存归并之上做进一步的处理。</p><p>由于从数据库中返回的结果集是逐条返回的，并不需要将所有的数据一次性加载至内存中，因此，在进行结果归并时，沿用数据库返回结果集的方式进行归并，能够极大减少内存的消耗，是归并方式的优先选择。</p><p>流式归并是指每一次从结果集中获取到的数据，都能够通过逐条获取的方式返回正确的单条数据，它与数据库原生的返回结果集的方式最为契合。遍历、排序以及流式分组都属于流式归并的一种。</p><p>内存归并则是需要将结果集的所有数据都遍历并存储在内存中，再通过统一的分组、排序以及聚合等计算之后，再将其封装成为逐条访问的数据结果集返回。</p><p>装饰者归并是对所有的结果集归并进行统一的功能增强，目前装饰者归并有分页归并和聚合归并这 2 种类型。</p><h3 id="遍历归并"><a class="markdownIt-Anchor" href="#遍历归并"></a> 遍历归并</h3><p>它是最为简单的归并方式。 只需将多个数据结果集合并为一个单向链表即可。在遍历完成链表中当前数据结果集之后，将链表元素后移一位，继续遍历下一个数据结果集即可。</p><h3 id="排序归并"><a class="markdownIt-Anchor" href="#排序归并"></a> 排序归并</h3><p>由于在 SQL 中存在 ORDER BY 语句，因此每个数据结果集自身是有序的，因此只需要将数据结果集当前游标指向的数据值进行排序即可。 这相当于对多个有序的数组进行排序，归并排序是最适合此场景的排序算法。</p><p>ShardingSphere 在对排序的查询进行归并时，将每个结果集的当前数据值进行比较（通过实现 Java 的 Comparable 接口完成），并将其放入优先级队列。 每次获取下一条数据时，只需将队列顶端结果集的游标下移，并根据新游标重新进入优先级排序队列找到自己的位置即可。</p><p>通过一个例子来说明 ShardingSphere 的排序归并，下图是一个通过分数进行排序的示例图。 图中展示了 3 张表返回的数据结果集，每个数据结果集已经根据分数排序完毕，但是 3 个数据结果集之间是无序的。 将 3 个数据结果集的当前游标指向的数据值进行排序，并放入优先级队列，t_score_0 的第一个数据值最大，t_score_2 的第一个数据值次之，t_score_1 的第一个数据值最小，因此优先级队列根据 t_score_0，t_score_2 和 t_score_1 的方式排序队列。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/15.png"  alt="排序归并例子" /><br />下图则展现了进行 next 调用的时候，排序归并是如何进行的。 通过图中我们可以看到，当进行第一次 next 调用时，排在队列首位的 t_score_0 将会被弹出队列，并且将当前游标指向的数据值（也就是 100）返回至查询客户端，并且将游标下移一位之后，重新放入优先级队列。 而优先级队列也会根据 t_score_0 的当前数据结果集指向游标的数据值（这里是 90）进行排序，根据当前数值，t_score_0 排列在队列的最后一位。 之前队列中排名第二的 t_score_2 的数据结果集则自动排在了队列首位。</p><p>在进行第二次 next 时，只需要将目前排列在队列首位的 t_score_2 弹出队列，并且将其数据结果集游标指向的值返回至客户端，并下移游标，继续加入队列排队，以此类推。 当一个结果集中已经没有数据了，则无需再次加入队列。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/16.png"  alt="排序归并" /><br />可以看到，对于每个数据结果集中的数据有序，而多数据结果集整体无序的情况下，ShardingSphere 无需将所有的数据都加载至内存即可排序。 它使用的是流式归并的方式，每次 next 仅获取唯一正确的一条数据，极大的节省了内存的消耗。</p><p>从另一个角度来说，ShardingSphere 的排序归并，是在维护数据结果集的纵轴和横轴这两个维度的有序性。 纵轴是指每个数据结果集本身，它是天然有序的，它通过包含 ORDER BY 的 SQL 所获取。 横轴是指每个数据结果集当前游标所指向的值，它需要通过优先级队列来维护其正确顺序。 每一次数据结果集当前游标的下移，都需要将该数据结果集重新放入优先级队列排序，而只有排列在队列首位的数据结果集才可能发生游标下移的操作。</p><h3 id="分组归并"><a class="markdownIt-Anchor" href="#分组归并"></a> 分组归并</h3><p>分组归并的情况最为复杂，它分为流式分组归并和内存分组归并。 流式分组归并要求 SQL 的排序项与分组项的字段以及排序类型（ASC 或 DESC）必须保持一致，否则只能通过内存归并才能保证其数据的正确性。</p><p>举例说明，假设根据科目分片，表结构中包含考生的姓名（为了简单起见，不考虑重名的情况）和分数。通过 SQL 获取每位考生的总分，可通过如下 SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, <span class="keyword">SUM</span>(score) <span class="keyword">FROM</span> t_score <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>在分组项与排序项完全一致的情况下，取得的数据是连续的，分组所需的数据全数存在于各个数据结果集的当前游标所指向的数据值，因此可以采用流式归并。如下图所示。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/17.png"  alt="分组归并1" /><br />进行归并时，逻辑与排序归并类似。 下图展现了进行 next 调用的时候，流式分组归并是如何进行的。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/18.png"  alt="分组归并2" /><br />通过图中我们可以看到，当进行第一次 next 调用时，排在队列首位的 t_score_java 将会被弹出队列，并且将分组值同为 “Jetty” 的其他结果集中的数据一同弹出队列。 在获取了所有的姓名为 “Jetty” 的同学的分数之后，进行累加操作，那么，在第一次 next 调用结束后，取出的结果集是 “Jetty” 的分数总和。 与此同时，所有的数据结果集中的游标都将下移至数据值 “Jetty” 的下一个不同的数据值，并且根据数据结果集当前游标指向的值进行重排序。 因此，包含名字顺着第二位的 “John” 的相关数据结果集则排在的队列的前列。</p><p>流式分组归并与排序归并的区别仅仅在于两点：</p><ol><li>它会一次性的将多个数据结果集中的分组项相同的数据全数取出。</li><li>它需要根据聚合函数的类型进行聚合计算。<br />对于分组项与排序项不一致的情况，由于需要获取分组的相关的数据值并非连续的，因此无法使用流式归并，需要将所有的结果集数据加载至内存中进行分组和聚合。 例如，若通过以下 SQL 获取每位考生的总分并按照分数从高至低排序：</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, <span class="keyword">SUM</span>(score) <span class="keyword">FROM</span> t_score <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>那么各个数据结果集中取出的数据与排序归并那张图的上半部分的表结构的原始数据一致，是无法进行流式归并的。</p><p>当 SQL 中只包含分组语句时，根据不同数据库的实现，其排序的顺序不一定与分组顺序一致。 但由于排序语句的缺失，则表示此 SQL 并不在意排序顺序。 因此，ShardingSphere 通过 SQL 优化的改写，自动增加与分组项一致的排序项，使其能够从消耗内存的内存分组归并方式转化为流式分组归并方案。</p><h3 id="聚合归并"><a class="markdownIt-Anchor" href="#聚合归并"></a> 聚合归并</h3><p>无论是流式分组归并还是内存分组归并，对聚合函数的处理都是一致的。 除了分组的 SQL 之外，不进行分组的 SQL 也可以使用聚合函数。 因此，聚合归并是在之前介绍的归并类的之上追加的归并能力，即装饰者模式。聚合函数可以归类为比较、累加和求平均值这 3 种类型。</p><p>比较类型的聚合函数是指 MAX 和 MIN。它们需要对每一个同组的结果集数据进行比较，并且直接返回其最大或最小值即可。</p><p>累加类型的聚合函数是指 SUM 和 COUNT。它们需要将每一个同组的结果集数据进行累加。</p><p>求平均值的聚合函数只有 AVG。它必须通过 SQL 改写的 SUM 和 COUNT 进行计算，相关内容已在 SQL 改写的内容中涵盖，不再赘述。</p><h3 id="分页归并"><a class="markdownIt-Anchor" href="#分页归并"></a> 分页归并</h3><p>上文所述的所有归并类型都可能进行分页。 分页也是追加在其他归并类型之上的装饰器，ShardingSphere 通过装饰者模式来增加对数据结果集进行分页的能力。 分页归并负责将无需获取的数据过滤掉。</p><p>ShardingSphere 的分页功能比较容易让使用者误解，用户通常认为分页归并会占用大量内存。 在分布式的场景中，将 LIMIT 10000000, 10 改写为 LIMIT 0, 10000010，才能保证其数据的正确性。 用户非常容易产生 ShardingSphere 会将大量无意义的数据加载至内存中，造成内存溢出风险的错觉。 其实，通过流式归并的原理可知，会将数据全部加载到内存中的只有内存分组归并这一种情况。 而通常来说，进行 OLAP 的分组 SQL，不会产生大量的结果数据，它更多的用于大量的计算，以及少量结果产出的场景。 除了内存分组归并这种情况之外，其他情况都通过流式归并获取数据结果集，因此 ShardingSphere 会通过结果集的 next 方法将无需取出的数据全部跳过，并不会将其存入内存。</p><p>但同时需要注意的是，由于排序的需要，大量的数据仍然需要传输到 ShardingSphere 的内存空间。 因此，采用 LIMIT 这种方式分页，并非最佳实践。 由于 LIMIT 并不能通过索引查询数据，因此如果可以保证 ID 的连续性，通过 ID 进行分页是比较好的解决方案，例如：</p><p>SELECT * FROM t_order WHERE id &gt; 100000 AND id &lt;= 100010 ORDER BY id;<br />或通过记录上次查询结果的最后一条记录的 ID 进行下一页的查询，例如：</p><p>SELECT * FROM t_order WHERE id &gt; 10000000 LIMIT 10;<br />归并引擎的整体结构划分如下图。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sharding-jdbc/19.png"  alt="归并引擎" /></p><h1 id="使用示例"><a class="markdownIt-Anchor" href="#使用示例"></a> 使用示例</h1><h2 id="引入maven依赖"><a class="markdownIt-Anchor" href="#引入maven依赖"></a> 引入Maven依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- for spring boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;sharding-sphere.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- for spring namespace --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-namespace<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;sharding-sphere.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基于spring-boot的规则配置"><a class="markdownIt-Anchor" href="#基于spring-boot的规则配置"></a> 基于Spring boot的规则配置</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里要注册所有的数据源</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.names</span>=<span class="string">ds0,ds1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是数据源0的配置</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.jdbc-url</span>=<span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.password</span>=<span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是数据源1的配置</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.jdbc-url</span>=<span class="string">jdbc:mysql://localhost:3307/test?serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.password</span>=<span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分库策略</span></span><br><span class="line"><span class="comment"># 分库的列是user_id</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.default-database-strategy.standard.sharding-column</span>=<span class="string">user_id</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.default-database-strategy.standard.precise-algorithm-class-name</span>=<span class="string">com.sinosun.demo.sharding.PreciseShardingAlgorithmImpl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分表策略</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.actual-data-nodes</span>=<span class="string">ds$-&gt;&#123;0..1&#125;.t_order$-&gt;&#123;0..1&#125;</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.table-strategy.inline.sharding-column</span>=<span class="string">order_id</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.table-strategy.inline.algorithm-expression</span>=<span class="string">t_order$-&gt;&#123;order_id % 2&#125;</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.key-generator.column</span>=<span class="string">order_id</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order.key-generator.type</span>=<span class="string">SNOWFLAKE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order_item.actual-data-nodes</span>=<span class="string">ds$-&gt;&#123;0..1&#125;.t_order_item$-&gt;&#123;0..1&#125;</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order_item.table-strategy.inline.sharding-column</span>=<span class="string">order_id</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_order_item.table-strategy.inline.algorithm-expression</span>=<span class="string">t_order_item$-&gt;&#123;order_id % 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定表</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.binding-tables</span>=<span class="string">t_order, t_order_item</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 广播表, 其主节点是ds0</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.broadcast-tables</span>=<span class="string">t_config</span></span><br><span class="line"><span class="meta">spring.shardingsphere.sharding.tables.t_config.actual-data-nodes</span>=<span class="string">ds$-&gt;&#123;0&#125;.t_config</span></span><br></pre></td></tr></table></figure><h2 id="在spring中使用datasource"><a class="markdownIt-Anchor" href="#在spring中使用datasource"></a> 在Spring中使用DataSource</h2><p>直接通过注入的方式即可使用DataSource，或者将DataSource配置在JPA、Hibernate或MyBatis中使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br></pre></td></tr></table></figure><p>更多详细使用请参考： <a href="https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/" target="_blank" rel="noopener"><strong>shardingsphere-jdbc使用手册</strong></a></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://shardingsphere.apache.org/document/current/cn/overview/" target="_blank" rel="noopener">shardingsphere官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 分库分表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分库分表 </tag>
            
            <tag> ShardingSphere-JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈一谈 ConcurrentModificationException</title>
      <link href="/posts/32b01532/"/>
      <url>/posts/32b01532/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p>首先我们先看一下下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"1"</span>);</span><br><span class="line">        list.add(<span class="string">"2"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"2"</span>.equals(item)) &#123;</span><br><span class="line">                list.remove(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行一下发现会抛出<code>ConcurrentModificationException</code>异常，下面我们就来谈一谈<code>ConcurrentModificationException</code>。</p><h1 id="foreach的底层实现"><a class="markdownIt-Anchor" href="#foreach的底层实现"></a> foreach的底层实现</h1><p>要了解为啥报<code>ConcurrentModificationException</code>异常，我们先来看看foreach的底层实现。<br />首先，我们将下面的代码编译生成<code>.class</code>文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//对集合 , 本质上是iterator迭代器</span></span><br><span class="line">       list.add(<span class="string">"1"</span>);</span><br><span class="line">       list.add(<span class="string">"2"</span>);</span><br><span class="line">       <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span>[] intArr = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> val : intArr) &#123;<span class="comment">//对数组 , 就是用fori的常规方式实现</span></span><br><span class="line">           System.out.println(val);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后再用反编译工具打开该<code>·class</code>文件，我们会看到下面的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">"1"</span>);</span><br><span class="line">        list.add(<span class="string">"2"</span>);</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">for</span> (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) &#123;</span><br><span class="line">            s = (String) localIterator.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span>[] intArr = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intArr.length; i++) &#123;</span><br><span class="line">            val = intArr[i];</span><br><span class="line">            System.out.println(val);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们就知道了 foreach在数组上还是使用了原来的fori循环 , 在其他可迭代对象上 , 实则是调用了itearator()方式使用迭代器的方式完成遍历。</p><h1 id="源码解析"><a class="markdownIt-Anchor" href="#源码解析"></a> 源码解析</h1><p>既然我们知道了foreach的底层实现，那我们就直接来看一下<code>ArrayList.iterator()</code>的源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到返回了一个<code>Itr</code>的类，<code>Itr</code>是<code>AbstractList</code>的一个内部类，用于迭代，下面是其代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">            Objects.requireNonNull(consumer);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                consumer.accept((E) elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">            cursor = i;</span><br><span class="line">            lastRet = i - <span class="number">1</span>;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据代码可知，每次迭代list时，会初始化Itr的三个成员变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">int</span> cursor = <span class="number">0</span>;   <span class="comment">//将要访问的元素的索引</span></span><br><span class="line"> <span class="keyword">int</span> lastRet = -<span class="number">1</span>;  <span class="comment">//上一个访问元素的索引</span></span><br><span class="line"><span class="keyword">int</span> expectedModCount = modCount;<span class="comment">//expectedModCount为预期修改值，初始化等于modCount（AbstractList类中的一个成员变量）</span></span><br></pre></td></tr></table></figure><p>接着调用<code>hasNext()</code>循环判断访问元素的下标是否到达末尾。如果没有，调用<code>next()</code>方法，取出元素。<br />而最上面测试代码出现异常的原因在于，<code>next()</code>方法调用<code>checkForComodification()</code>时，发现了<code>modCount != expectedModCount</code>，抛出异常。<br />接下来我们看下<code>ArrayList</code>的源码，了解下<code>modCount</code> 是如何与<code>expectedModCount</code>不相等的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E paramE)</span> </span>&#123;  </span><br><span class="line">    ensureCapacityInternal(<span class="keyword">this</span>.size + <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">/** 省略此处代码 */</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> paramInt)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.elementData == EMPTY_ELEMENTDATA)  </span><br><span class="line">        paramInt = Math.max(<span class="number">10</span>, paramInt);  </span><br><span class="line">    ensureExplicitCapacity(paramInt);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> paramInt)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.modCount += <span class="number">1</span>;    <span class="comment">//修改modCount  </span></span><br><span class="line">    <span class="comment">/** 省略此处代码 */</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object paramObject)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">if</span> (paramObject == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; ++i) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.elementData[i] != <span class="keyword">null</span>)  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            fastRemove(i);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; ++i) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (!(paramObject.equals(<span class="keyword">this</span>.elementData[i])))  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            fastRemove(i);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> paramInt)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.modCount += <span class="number">1</span>;   <span class="comment">//修改modCount  </span></span><br><span class="line">    <span class="comment">/** 省略此处代码 */</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.modCount += <span class="number">1</span>;    <span class="comment">//修改modCount  </span></span><br><span class="line">    <span class="comment">/** 省略此处代码 */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以看出，<code>ArrayList</code>的<code>add</code>、<code>remove</code>、<code>clear</code>方法都会造成<code>modCount</code>的改变。迭代过程中如何调用这些方法就会造成<code>modCount</code>的增加，使迭代类中<code>expectedModCount</code>和<code>modCount</code>不相等，从而抛出<code>ConcurrentModificationException</code>异常。</p><h1 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h1><p>现在我们已经基本了解了异常的发送原因了。接下来我们来解决它。<br />假如我就是想在迭代集合时删除集合的元素，怎么办？</p><h2 id="单线程环境"><a class="markdownIt-Anchor" href="#单线程环境"></a> 单线程环境</h2><p>细心的朋友会发现Itr中的也有一个<code>remove</code>方法，实质也是调用了ArrayList中的remove，但增加了<code>expectedModCount = modCount;</code>保证了不会抛出<code>java.util.ConcurrentModificationException</code>异常。我们就可以将代码修改为下面这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    String str = iter.next();</span><br><span class="line">      <span class="keyword">if</span>( str.equals(<span class="string">"B"</span>) )&#123;</span><br><span class="line">        iter.remove(); <span class="comment">// 关键代码</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这个办法的有两个弊端</p><ol><li>只能进行remove操作，add、clear等Itr中没有。</li><li>而且只适用单线程环境。</li></ol><h2 id="多线程环境"><a class="markdownIt-Anchor" href="#多线程环境"></a> 多线程环境</h2><p>在多线程环境下，我们运行下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"1"</span>);</span><br><span class="line">        list.add(<span class="string">"2"</span>);</span><br><span class="line">        list.add(<span class="string">"3"</span>);</span><br><span class="line">        list.add(<span class="string">"4"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + iterator.next());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    String element = iterator.next();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + element);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"2"</span>.equals(element)) &#123;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果发现还是会抛异常，异常的原因很简单，一个线程修改了list的<code>modCount</code>导致另外一个线程迭代时<code>modCount</code>与该迭代器的<code>expectedModCount</code>不相等。</p><p>此时有两个办法：</p><ol><li>迭代前加锁，解决了多线程问题，但还是不能进行迭代add、clear等操作</li><li>采用<code>CopyOnWriteArrayList</code>，解决了多线程问题，同时可以add、clear等操作</li></ol><p>CopyOnWriteArrayList也是一个线程安全的ArrayList，其实现原理在于，每次add,remove等操作时，先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。具体参考：<a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="noopener"><strong>聊聊并发-Java中的Copy-On-Write容器</strong></a></p><h1 id="fail-fast机制"><a class="markdownIt-Anchor" href="#fail-fast机制"></a> fail-fast机制</h1><p>到这里，我们似乎已经理解完这个异常的产生缘由和解决方案了。<br />但是，仔细思考，还是会有几点疑惑：</p><ol><li>既然modCount与expectedModCount不同会产生异常，那为什么还设置这个变量？</li><li>ConcurrentModificationException可以翻译成“并发修改异常”，那这个异常是否与多线程有关呢？<br />我们来看看源码中modCount的注解</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;.</span></span><br><span class="line"><span class="comment">     * Structural modifications are those that change the size of the</span></span><br><span class="line"><span class="comment">     * list, or otherwise perturb it in such a fashion that iterations in</span></span><br><span class="line"><span class="comment">     * progress may yield incorrect results.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This field is used by the iterator and list iterator implementation</span></span><br><span class="line"><span class="comment">     * returned by the &#123;<span class="doctag">@code</span> iterator&#125; and &#123;<span class="doctag">@code</span> listIterator&#125; methods.</span></span><br><span class="line"><span class="comment">     * If the value of this field changes unexpectedly, the iterator (or list</span></span><br><span class="line"><span class="comment">     * iterator) will throw a &#123;<span class="doctag">@code</span> ConcurrentModificationException&#125; in</span></span><br><span class="line"><span class="comment">     * response to the &#123;<span class="doctag">@code</span> next&#125;, &#123;<span class="doctag">@code</span> remove&#125;, &#123;<span class="doctag">@code</span> previous&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> set&#125; or &#123;<span class="doctag">@code</span> add&#125; operations.  This provides</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in</span></span><br><span class="line"><span class="comment">     * the face of concurrent modification during iteration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass</span></span><br><span class="line"><span class="comment">     * wishes to provide fail-fast iterators (and list iterators), then it</span></span><br><span class="line"><span class="comment">     * merely has to increment this field in its &#123;<span class="doctag">@code</span> add(int, E)&#125; and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> remove(int)&#125; methods (and any other methods that it overrides</span></span><br><span class="line"><span class="comment">     * that result in structural modifications to the list).  A single call to</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> add(int, E)&#125; or &#123;<span class="doctag">@code</span> remove(int)&#125; must add no more than</span></span><br><span class="line"><span class="comment">     * one to this field, or the iterators (and list iterators) will throw</span></span><br><span class="line"><span class="comment">     * bogus &#123;<span class="doctag">@code</span> ConcurrentModificationExceptions&#125;.  If an implementation</span></span><br><span class="line"><span class="comment">     * does not wish to provide fail-fast iterators, this field may be</span></span><br><span class="line"><span class="comment">     * ignored.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>我们注意到，注解中频繁的出现了<code>fail-fast</code><br />那么<code>fail-fast</code>（快速失败）机制是什么呢？</p><blockquote><p>“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出ConcurrentModificationException 异常，从而产生fail-fast机制。</p></blockquote><p>看到这里，我们明白了，<code>fail-fast</code>机制就是为了防止多线程修改集合造成并发问题的机制嘛。<br />之所以有modCount这个成员变量，就是为了辨别多线程修改集合时出现的错误。而<code>java.util.ConcurrentModificationException</code>就是并发异常。<br />但是单线程使用不当时也可能抛出这个异常。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java为啥计算时间从1970-1-1开始</title>
      <link href="/posts/8a25b5de/"/>
      <url>/posts/8a25b5de/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p>Java中计算开始时间是从1970年1月1日开始的，但是为什么从1970年开始呢？其他语言也是从1970年1月1日开始么？</p><h1 id="java时间计算起点"><a class="markdownIt-Anchor" href="#java时间计算起点"></a> Java时间计算起点</h1><p>我们都知道，在Java中执行下面的代码会打印<code>Thu Jan 01 08:00:00 CST 1970</code>(系统时区设置为UTC+08:00-也就是北京时间) (如果设置为UTC世界时则会打印<code>Thu Jan 01 00:00:00 CST 1970</code>)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Date(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>为什么这个时间会定义在1970 年 1 月 1 日这个时候呢 ?<br />一番百度+Google，得到了以下答案：</p><blockquote><p>java 起源于 UNIX 系统，而 UNIX 认为 1970 年 1 月 1 日 0 点是时间纪元，所以java也遵循unix的这套时间系统。</p></blockquote><p>哪UNIX为什么要以1970 年 1 月 1 日 0 点为时间纪元呢？<br />其实原因也很简单，是因为当初的操作系统都是32位的，所以时间也是用32位来表示的。所以所能表示的最大值就是<code>2^32-1=2147483647</code>。也就是<code>2147483647/(365 * 24 * 60 * 60)=68.1</code>年。而当时最早的unix操作系统是由AT&amp;T贝尔实验室的三位科学家在1969年开发的，所以当时他们为了让时间尽可能的多利用起来，便用了下一年，即1970年1月1日作为开始。所以目前32位系统的时间最多能支撑到2038年1月19日3时14分7秒。到了这一天的凌晨3点14分8秒，时间表示就会因为溢出变为1901年12月13日20时45分52秒。这样便会出现时间回归的现象，会导致很多问题，所以还是要早点更新到64位操作系统。在64位操作系统中，系统可以表示到292,277,026,596年12月4日15时30分08秒。肯定是够够的了。</p><p>到这里java为啥从1970年1月1日开始的问题算是解答了，其他的语言其实也都遵循unix的这套时间系统，所以都是从1970年1月1日开始的。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://en.wikipedia.org/wiki/Unix_time" target="_blank" rel="noopener">Unix time - wiki</a><br /><a href="https://www.cnblogs.com/Jack47/p/unix-time-date-episode.html" target="_blank" rel="noopener">关于计算机中时间的科普和八卦</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 1970 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL LEFT JOIN 只取被关联表中一条数据</title>
      <link href="/posts/29a14022/"/>
      <url>/posts/29a14022/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>最近遇到一个需求，需要查询被关联表中最新的一条数据，在此记录一下。</p><h1 id="创建表和初始化数据"><a class="markdownIt-Anchor" href="#创建表和初始化数据"></a> 创建表和初始化数据</h1><p>比如我有两个表，用户表（user）、用户登录记录表(user_login_log)。现在需要查询用户并同时带出他最近的登录记录。</p><p>下面是初始化SQL</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">VARCHAR</span> (<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_login_log`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`user_id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`login_time`</span> <span class="built_in">TIMESTAMP</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'登录时间'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">'zhangsan'</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">'lisi'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user_login_log`</span> (<span class="string">`id`</span>,<span class="string">`user_id`</span>,<span class="string">`login_time`</span>) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">'1'</span>,<span class="string">'2020-01-01 12:58:30'</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">'1'</span>,<span class="string">'2020-01-02 12:58:30'</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">'1'</span>,<span class="string">'2020-01-03 12:58:30'</span>);</span><br></pre></td></tr></table></figure><h1 id="使用group-by"><a class="markdownIt-Anchor" href="#使用group-by"></a> 使用GROUP BY</h1><p>首先想到的就是GROUP BY ，看下面SQL</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`user`</span> u</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(login_time), <span class="keyword">id</span> <span class="keyword">AS</span> log_id,user_id</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`user_login_log`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id</span><br><span class="line">) l <span class="keyword">ON</span> u.id = l.user_id;</span><br></pre></td></tr></table></figure><p>下面是执行结果：<br /><img alt='执行结果' src='https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/mysql-left-join-orderby/1.png' align='left'/></p><p>初一看好像结果是对的，再仔细看log_id字段，按照想法应该是最后一条记录的ID(3)才对呀 [捂脸]。</p><p>查了一下资料，发现MySQL的GROUP BY 默认会保留“最先搜索出来的一条数据”<br />这样子的话，我又对SQL进行了改造：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`user`</span> u</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`user_login_log`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> login_time <span class="keyword">DESC</span>)temp <span class="keyword">GROUP</span> <span class="keyword">BY</span> temp.user_id</span><br><span class="line">) l <span class="keyword">ON</span> u.id = l.user_id;</span><br></pre></td></tr></table></figure><p>一执行，结果和刚才一模一样。[-_-||]</p><p>再查询了资料：根据MySQL手册，在MySQL5.7中，如果不加LIMIT，系统会把ORDER BY优化掉(MySQL5.5或之前不会)。再修改SQL：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`user`</span> u</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`user_login_log`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> login_time <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">10000</span>)temp <span class="keyword">GROUP</span> <span class="keyword">BY</span> temp.user_id</span><br><span class="line">) l <span class="keyword">ON</span> u.id = l.user_id;</span><br></pre></td></tr></table></figure><p>这样子终于行了：<br /><img alt='执行结果' src='https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/mysql-left-join-orderby/2.png' align='left'/></p><p>但是看着那个LIMIT 10000 很不爽，还有没有其他的方式呢，下面我们看看另外的方式。</p><h1 id="其他的方式"><a class="markdownIt-Anchor" href="#其他的方式"></a> 其他的方式</h1><p>在我不断的查询资料下，在<a href="https://stackoverflow.com/questions/6879391/mysql-join-with-limit-1-on-joined-table/24442655" target="_blank" rel="noopener">StackOverflow</a>看到了另外一种方案：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`user`</span> u</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">`user_login_log`</span> l <span class="keyword">ON</span> l.id=(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> <span class="string">`user_login_log`</span> <span class="keyword">WHERE</span> u.id=user_Id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> login_time <span class="keyword">DESC</span>  <span class="keyword">LIMIT</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>执行了一下也符合预期。</p><p>OK，这个问题就先到这里了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分库分表中间件选型和分库分表流程</title>
      <link href="/posts/4486a01d/"/>
      <url>/posts/4486a01d/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p><a href="/posts/a3a0c28e/">上一篇</a>讲到了分库分表和分库分表的中间件，这篇就来讲讲怎么选择中间件和分库分表使用的流程。</p><h1 id="中间件切入层介绍"><a class="markdownIt-Anchor" href="#中间件切入层介绍"></a> 中间件切入层介绍</h1><p>如下图，从应用程序到数据大体分为以下五层。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table-middleware/1.png"  alt="中间件切入层" title="中间件切入层" /></p><h2 id="编码层"><a class="markdownIt-Anchor" href="#编码层"></a> 编码层</h2><p>在同一个项目中创建多个数据源，采用if else的方式，直接根据条件在代码中路由。Spring中有动态切换数据源的抽象类，具体参见<code>AbstractRoutingDataSource</code>。</p><p>如果项目不是很庞大，使用这种方式能够快速的进行分库。但缺点也是显而易见的，需要编写大量的代码，照顾到每个分支。当涉及跨库查询、聚合，需要循环计算结果并合并的场景，工作量巨大。</p><p>如果项目裂变，此类代码大多不能共用，大多通过拷贝共享。长此以往，码将不码。</p><h2 id="框架层"><a class="markdownIt-Anchor" href="#框架层"></a> 框架层</h2><p>这种情况适合公司ORM框架统一的情况，但在很多情况下不太现实。主要是修改或增强现有ORM框架的功能，在SQL中增加一些自定义原语或者<code>hint</code>来实现。</p><p>通过实现一些拦截器（比如<code>Mybatis</code>的<code>Interceptor</code>接口），增加一些自定义解析来控制数据的流向，效果虽然较好，但会改变一些现有的编程经验。</p><p>很多情况要修改框架源码，不推荐。</p><h2 id="驱动层"><a class="markdownIt-Anchor" href="#驱动层"></a> 驱动层</h2><p>基于在编码层和框架层切入的各种缺点，真正的数据库中间件起码要从驱动层开始。什么意思呢？其实就是重新编写了一个JDBC的驱动，在内存中维护一个路由列表，然后将请求转发到真正的数据库连接中。</p><p>像<code>TDDL</code>、<code>ShardingJDBC</code>等，都是在此层切入。</p><p>包括Mysql Connector/J的<code>Failover</code>协议 (具体指“load balancing”、“replication”、“farbic”等），也是直接在驱动上进行修改。</p><p>请求流向一般是这样的：<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table-middleware/2.png"  alt="驱动层请求流向" title="驱动层请求流向" /></p><h2 id="代理层"><a class="markdownIt-Anchor" href="#代理层"></a> 代理层</h2><p>代理层的数据库中间件，将自己伪装成一个数据库，接受业务端的链接。然后负载业务端的请求，解析或者转发到真正的数据库中。</p><p>像<code>MySQL Router</code>、<code>MyCat</code>等，都是在此层切入。<br />请求流向一般是这样的：<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table-middleware/3.png"  alt="代理层请求流向" title="代理层请求流向" /></p><h2 id="实现层"><a class="markdownIt-Anchor" href="#实现层"></a> 实现层</h2><p>SQL特殊版本支持，如<code>Mysql cluster</code>本身就支持各种特性，<code>mariadb galera cluster</code>支持对等双主，<code>Greenplum</code>支持分片等。</p><p>需要换存储，一般是解决方案，就不在讨论之列了。</p><p>通过以上层次描述，很明显，我们选择或开发中间件，就集中在驱动层和代理层。在这两层，能够对数据库连接和路由进行更强的控制和更细致的管理。但它们的区别也是明显的。</p><h1 id="驱动层和代理层对比"><a class="markdownIt-Anchor" href="#驱动层和代理层对比"></a> 驱动层和代理层对比</h1><h2 id="驱动层特点"><a class="markdownIt-Anchor" href="#驱动层特点"></a> 驱动层特点</h2><h3 id="仅支持单语言支持丰富的db"><a class="markdownIt-Anchor" href="#仅支持单语言支持丰富的db"></a> 仅支持单语言，支持丰富的DB</h3><p>一般在驱动层的中间件，就是针对单语言的，比如：sharding-jdbc仅支持java。如果你的开发语言固定，后端数据源类型丰富，推荐使用此方案。</p><h3 id="占用较多的数据库连接"><a class="markdownIt-Anchor" href="#占用较多的数据库连接"></a> 占用较多的数据库连接</h3><p>驱动层中间件要维护很多数据库连接。比如一个分了10个 库 的表，每个java中的Connection要维护10个数据库连接。如果项目过多，则会出现连接爆炸（我们算一下，如果每个项目6个实例，连接池中minIdle等于5，3个项目的连接总数是 10<em>6</em>5*3 = 900 个）。像Postgres这种每个连接对应一个进程的数据库，压力会很大。</p><h3 id="数据聚合在业务实例执行"><a class="markdownIt-Anchor" href="#数据聚合在业务实例执行"></a> 数据聚合在业务实例执行</h3><p>数据聚合，比如<code>count</code> <code>sum</code>等，是通过多次查询，然后在业务实例的内存中进行聚合。</p><p>路由表存在于业务方实例内存中，通过轮询或者被动通知的途径更新路由表即可。</p><h3 id="集中式管理"><a class="markdownIt-Anchor" href="#集中式管理"></a> 集中式管理</h3><p>所有集群的配置管理都集中在一个地方，运维负担小，DBA即可完成相关操作。</p><h2 id="代理层特点"><a class="markdownIt-Anchor" href="#代理层特点"></a> 代理层特点</h2><h3 id="异构支持db支持有限"><a class="markdownIt-Anchor" href="#异构支持db支持有限"></a> 异构支持，DB支持有限</h3><p>代理层中间件正好相反。仅支持一种后端关系型数据库，但支持多种开发语言。如果你的系统是异构的，并且都有同样的SLA要求，则推荐使用此方案。</p><h3 id="运维负担大"><a class="markdownIt-Anchor" href="#运维负担大"></a> 运维负担大</h3><p>代理层需要维护数据库连接数量有限（MySQL Router那种粘性连接除外）。但作为一个独立的服务，既要考虑单独部署，又要考虑高可用，会增加很多额外节点，更别提用了影子节点的公司了。<br />另外，代理层是请求唯一的入口，稳定性要求极高，一旦有高耗内存的聚合查询把节点搞崩溃了，都是灾难性的事故。</p><h1 id="中间件选择"><a class="markdownIt-Anchor" href="#中间件选择"></a> 中间件选择</h1><p>建议聚焦在<code>MyCat</code>和<code>ShardingJDBC</code>上。另外，还有大量其他的中间件，不熟悉建议不要妄动。<br />数据库中间件不好维护，你会发现大量半死不活的项目。</p><p>以下列表，排名不分先后，有几个是只有HA功能，没有拆分功能的：</p><p>Atlas、Kingshard、DBProxy、mysql router、MaxScale、58 Oceanus、OneProxy、ArkProxy、Ctrip DAL、Tsharding、vitess、DDB、Heisenberg、proxysql、Mango、DDAL、Datahekr、MTAtlas、MTDDL、Zebra、Cobar</p><h2 id="几个常用的中间件简介"><a class="markdownIt-Anchor" href="#几个常用的中间件简介"></a> 几个常用的中间件简介</h2><h3 id="cobar"><a class="markdownIt-Anchor" href="#cobar"></a> Cobar</h3><p><a href="https://github.com/alibaba/cobar" target="_blank" rel="noopener">Cobar</a> 是提供关系型数据库（MySQL）分布式服务的中间件，它可以让传统的数据库得到良好的线性扩展，并看上去还是一个数据库，对应用保持透明。<br />Cobar属于阿里B2B事业群，始于2008年，在阿里服役3年多，接管3000+个MySQL数据库的schema,集群日处理在线SQL请求50亿次以上,集群日处理在线数据流量TB级别以上。<br />Cobar以Proxy的形式位于前台应用和实际数据库之间，对前台的开放的接口是MySQL通信协议，将前台SQL语句变更并按照数据分布规则发到合适的后台数据分库，再合并返回结果，模拟单库下的数据库行为。<br />Cobar属于中间层方案，在应用程序和MySQL之间搭建一层Proxy。中间层介于应用程序与数据库间，需要做一次转发，而基于JDBC协议并无额外转发，直接由应用程序连接数据库，性能上有些许优势。这里并非说明中间层一定不如客户端直连，除了性能，需要考虑的因素还有很多，中间层更便于实现监控、数据迁移、连接管理等功能。<br />由于Cobar发起人的离职，Cobar停止维护。后续的类似中间件，比如MyCAT建立于Cobar之上，包括现在阿里服役的RDRS其中也复用了Cobar-Proxy的相关代码。</p><h3 id="mycat"><a class="markdownIt-Anchor" href="#mycat"></a> MyCAT</h3><p><a href="http://www.mycat.io/" target="_blank" rel="noopener">MyCAT</a>是社区爱好者在阿里cobar基础上进行二次开发，解决了cobar当时存 在的一些问题，并且加入了许多新的功能在其中。目前MyCAT社区活 跃度很高，目前已经有一些公司在使用MyCAT。总体来说支持度比 较高，也会一直维护下去，发展到目前的版本，已经不是一个单纯的MySQL代理了，它的后端可以支持MySQL, SQL Server, Oracle, DB2, PostgreSQL等主流数据库，也支持MongoDB这种新型NoSQL方式的存储，未来还会支持更多类型的存储。<br />MyCAT是一个强大的数据库中间件，不仅仅可以用作读写分离，以及分表分库、容灾管理，而且可以用于多租户应用开发、云平台基础设施，让你的架构具备很强的适应性和灵活性，借助于即将发布的MyCAT只能优化模块，系统的数据访问瓶颈和热点一目了然，根据这些统计分析数据，你可以自动或手工调整后端存储，将不同的表隐射到不同存储引擎上，而整个应用的代码一行也不用改变。<br />MyCAT是在Cobar基础上发展的版本，两个显著提高：后端由BIO改为NIO，并发量有大幅提高； 增加了对Order By, Group By, Limit等聚合功能（虽然Cobar也可以支持Order By, Group By, Limit语法，但是结果没有进行聚合，只是简单返回给前端，聚合功能还是需要业务系统自己完成）。</p><h3 id="sharding-jdbc"><a class="markdownIt-Anchor" href="#sharding-jdbc"></a> sharding-JDBC</h3><p><a href="https://github.com/sharding-sphere" target="_blank" rel="noopener">sharding-JDBC</a>是当当应用框架ddframe中，从关系型数据库模块dd-rdb中分离出来的数据库水平分片框架，实现透明化数据库分库分表访问(目前已更名为ShardingSphere-JDBC)。<br />定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。</p><ul><li>适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC。</li><li>支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等。</li><li>支持任意实现 JDBC 规范的数据库，目前支持 MySQL，Oracle，SQLServer，PostgreSQL 以及任何遵循 SQL92 标准的数据库。</li></ul><h3 id="ddb"><a class="markdownIt-Anchor" href="#ddb"></a> DDB</h3><p>网易. Distributed DataBase.<br />DDB经历了三次服务模式的重大更迭：Driver模式-&gt;Proxy模式-&gt;云模式。<br />Driver模式：基于JDBC驱动访问，提供一个db.jar, 和TDDL类似， 位于应用层和JDBC之间. Proxy模式：在DDB中搭建了一组代理服务器来提供标准的MySQL服务，在代理服务器内部实现分库分表的逻辑。应用通过标准数据库驱动访问DDB Proxy, Proxy内部通过MySQL解码器将请求还原为SQL, 并由DDB Driver执行得到结果。<br />私有云模式：基于网易私有云开发的一套平台化管理工具Cloudadmin, 将DDB原先Master的功能打散，一部分分库相关功能集成到proxy中，如分库管理、表管理、用户管理等，一部分中心化功能集成到Cloudadmin中，如报警监控，此外，Cloudadmin中提供了一键部署、自动和手动备份，版本管理等平台化功能。</p><h3 id="oneproxy"><a class="markdownIt-Anchor" href="#oneproxy"></a> OneProxy</h3><p>数据库界大牛，前支付宝数据库团队领导楼方鑫开发，基于mysql官方 的proxy思想利用c进行开发的，OneProxy是一款商业收费的中间件， 楼总舍去了一些功能点，专注在性能和稳定性上。有朋友测试过说在 高并发下很稳定。</p><h3 id="oceanus"><a class="markdownIt-Anchor" href="#oceanus"></a> Oceanus</h3><p>58同城数据库中间件，Oceanus致力于打造一个功能简单、可依赖、易于上手、易于扩展、易于集成的解决方案，甚至是平台化系统。拥抱开源，提供各类插件机制集成其他开源项目，新手可以在几分钟内上手编程，分库分表逻辑不再与业务紧密耦合，扩容有标准模式，减少意外错误的发生。</p><h3 id="vitess"><a class="markdownIt-Anchor" href="#vitess"></a> Vitess</h3><p>这个中间件是Youtube生产在使用的，但是架构很复杂。 与以往中间件不同，使用Vitess应用改动比较大要 使用他提供语言的API接口，我们可以借鉴他其中的一些设计思想。</p><h1 id="分库分表使用注意点"><a class="markdownIt-Anchor" href="#分库分表使用注意点"></a> 分库分表使用注意点</h1><p><strong>确保数据均衡</strong> 拆分数据库的数据尽量均匀，比如按省份分user库不均匀，按userid取模会比较均匀<br /><strong>不用深分页</strong> 不带切分键的深分页，会取出所有库所取页数之前的所有数据在内存排序计算。容易造成内存溢出。<br /><strong>减少子查询</strong> 子查询会造成SQL解析紊乱，解析错误的情况，尽量减少SQL的子查询。<br /><strong>事务最小原则</strong> 尽量缩小单机事务涉及的库范围，即尽可能减少夸库操作，将同类操作的库/表分在一起<br /><strong>特殊函数</strong> distinct、having、union、in、or等，一般不被支持。或者被支持，使用之后会增加风险，需要改造。</p><h1 id="分库分表流程与解决方案"><a class="markdownIt-Anchor" href="#分库分表流程与解决方案"></a> 分库分表流程与解决方案</h1><p>无论是采用哪个层面切入进行分库分表，都面临以下工作过程。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table-middleware/4.png"  alt="分库分表工作过程" title="分库分表工作过程" /></p><h2 id="信息收集"><a class="markdownIt-Anchor" href="#信息收集"></a> 信息收集</h2><h3 id="统计影响的业务和项目"><a class="markdownIt-Anchor" href="#统计影响的业务和项目"></a> 统计影响的业务和项目</h3><p>项目范围越大，分库难度越高。有时候，一句复杂的SQL能够涉及四五个业务方，这种SQL都是需要重点关注的。<br />确定分库分表的规模，是只分其中的几张表，还是全部涉及。分的越多，工作量越大，几乎是线性的。还有一些项目是牵一发动全身的。</p><h3 id="确定参与人员"><a class="markdownIt-Anchor" href="#确定参与人员"></a> 确定参与人员</h3><p>除了分库分表组件的技术支持人员，最应该参与的是对系统、对现有代码最熟悉的几个人。只有他们能够确定哪些SQL该废弃掉、SQL的影响面等。</p><h3 id="确定分库分表策略"><a class="markdownIt-Anchor" href="#确定分库分表策略"></a> 确定分库分表策略</h3><p>确定分库分表的维度和切分键。切分键（就是路由数据的column）一旦确定，是不允许修改的，所以在前期架构设计上，应该首先将其确立下来，才能进行后续的工作；数据维度多意味着有不同的切分键，达到不同条件查询的效果。这涉及到数据的冗余（多写、数据同步），会更加复杂。</p><h2 id="前期准备"><a class="markdownIt-Anchor" href="#前期准备"></a> 前期准备</h2><h3 id="数据规整"><a class="markdownIt-Anchor" href="#数据规整"></a> 数据规整</h3><p>库表结构不满足需求，需要提前规整。比如，切分键的字段名称不同或者类型各异。在实施分库分表策略时，这些个性会造成策略过大不好维护。</p><h3 id="扫描所有sql"><a class="markdownIt-Anchor" href="#扫描所有sql"></a> 扫描所有SQL</h3><p>将项目中所有的SQL扫描出来，逐个判断是否能够按照切分键正常运行。<br />在判断过程中肯定会有大量不合规的SQL，则都需要给出改造方案，这是主要的工作量之一。</p><h3 id="验证工具支持"><a class="markdownIt-Anchor" href="#验证工具支持"></a> 验证工具支持</h3><p>直接在原有项目上进行改动和验证是可行的，但会遇到诸多问题，主要是效率太低。我倾向于首先设计一些验证工具，输入要验证的SQL或者列表，然后打印路由信息和结果进行判断。</p><h3 id="技术准备"><a class="markdownIt-Anchor" href="#技术准备"></a> 技术准备</h3><p>建议以下提到的各个点，都找一个例子体验一下，然后根据自己的团队预估难度。以下：</p><ul><li>中间件所有不支持的SQL类型</li><li>整理容易造成崩溃的注意事项</li><li>不支持的SQL给出处理方式</li><li>考虑一个通用的主键生成器</li><li>考虑没有切分键的SQL如何处理</li><li>考虑定时任务等扫全库的如何进行遍历</li><li>考虑跨库跨表查询如何改造</li><li>准备一些工具集</li></ul><h2 id="实施阶段"><a class="markdownIt-Anchor" href="#实施阶段"></a> 实施阶段</h2><h3 id="数据迁移"><a class="markdownIt-Anchor" href="#数据迁移"></a> 数据迁移</h3><p>分库分表会重新影响数据的分布，无论是全量还是增量，都会涉及到数据迁移，所以Databus是必要的。一种理想的状态是所有的增删改都是消息，可以通过订阅MQ进行双写。但一般情况下，仍然需要去模拟这个状态，比如使用Canal组件。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table-middleware/5.png"  alt="通过Canal模拟消息双写" title="通过Canal模拟消息双写" /></p><h3 id="充足的测试"><a class="markdownIt-Anchor" href="#充足的测试"></a> 充足的测试</h3><p>分库分表必须经过充足的测试，每一句SQL都要经过严格的验证。如果有单元测试或者自动化测试工具，完全的覆盖是必要的。一旦有数据进行了错误的路由，尤其是增删改，将会创造大量的麻烦。在测试阶段，将验证过程输出到单独的日志文件，充足测试后review日志文件是否有错误的数据流向。</p><h3 id="sql复验"><a class="markdownIt-Anchor" href="#sql复验"></a> SQL复验</h3><p>强烈建议统一进行一次SQL复验。主要是根据功能描述，确定SQL的正确性，也就是通常说的review。</p><h3 id="演练"><a class="markdownIt-Anchor" href="#演练"></a> 演练</h3><p>在非线上环境多次对方案进行演练，确保万无一失。</p><h3 id="制定新的sql规范"><a class="markdownIt-Anchor" href="#制定新的sql规范"></a> 制定新的SQL规范</h3><p>分库分表以后，项目中的SQL就加了枷锁，不能够随意书写了。很多平常支持的操作，在拆分环境下就可能运行不了了。所以在上线前，涉及的SQL都应该有一个确认过程，即使已经经过了充足的测试。</p><h1 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h1><p>分库分表是战略性的技术方案，很多情况无法回退或者回退方案复杂。如果要拆分的库表涉及多个业务方，公司技术人员复杂，CTO要亲自挂帅进行协调，并有专业仔细的架构师进行监督。没有授权的协调人员会陷入尴尬的境地，导致流程失控项目难产。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://segmentfault.com/a/1190000017272697" target="_blank" rel="noopener">分库分表？选型和流程要慎重，否则会失控</a><br /><a href="https://blog.csdn.net/xuheng8600/article/details/80336094" target="_blank" rel="noopener">数据库分库分表中间件对比</a><br /><a href="https://segmentfault.com/a/1190000021755246" target="_blank" rel="noopener">深入数据库分区分库分表</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分库分表 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分库分表</title>
      <link href="/posts/a3a0c28e/"/>
      <url>/posts/a3a0c28e/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>关系型数据库本身比较容易成为系统瓶颈，单机存储容量、连接数、处理能力都有限。当单表的数据量达到1000W或100G以后，由于查询维度较多，即使添加从库、优化索引，做很多操作时性能仍下降严重。此时就要考虑对其进行切分了，切分的目的就在于减少数据库的负担，缩短查询时间。</p><blockquote><p><em>MySQL单库数据量在5000万以内性能比较好，超过阈值后性能会随着数据量的增大而变弱。MySQL单表的数据量是500w-1000w之间性能比较好，超过1000w性能也会下降。</em><br /><em>分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成 ，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。</em></p></blockquote><h1 id="分库分表"><a class="markdownIt-Anchor" href="#分库分表"></a> 分库分表</h1><p>数据库分布式核心内容无非就是数据切分（Sharding），以及切分后对数据的定位、整合。数据切分就是将数据分散存储到多个数据库中，使得单一数据库中的数据量变小，通过扩充主机的数量缓解单一数据库的性能问题，从而达到提升数据库操作性能的目的。</p><p>数据切分根据其切分类型，可以分为两种方式：垂直（纵向）切分和水平（横向）切分</p><h2 id="垂直纵向切分"><a class="markdownIt-Anchor" href="#垂直纵向切分"></a> 垂直（纵向）切分</h2><p>垂直切分常见有<strong>垂直分库</strong>和<strong>垂直分表</strong>两种。</p><h3 id="垂直分库"><a class="markdownIt-Anchor" href="#垂直分库"></a> 垂直分库</h3><p>**垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库。做法与大系统拆分为多个小系统类似，按业务分类进行独立划分。与&quot;微服务治理&quot;的做法相似，每个微服务使用单独的一个数据库。**如图：<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table/1.png"  alt="垂直分库" title="垂直分库" /></p><h3 id="垂直分表"><a class="markdownIt-Anchor" href="#垂直分表"></a> 垂直分表</h3><p>垂直分表是基于数据库中的&quot;列&quot;进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。在字段很多的情况下（例如一个大表有100多个字段），通过&quot;大表拆小表&quot;，更便于开发与维护，也能避免跨页问题，MySQL底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table/2.png"  alt="垂直分表" title="垂直分表" /></p><h3 id="垂直切分的优缺点"><a class="markdownIt-Anchor" href="#垂直切分的优缺点"></a> 垂直切分的优缺点</h3><p>优点：</p><ul><li>解决业务系统层面的耦合，业务清晰</li><li>与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等</li><li>高并发场景下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈</li></ul><p>缺点：</p><ul><li>部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度</li><li>分布式事务处理复杂</li><li>依然存在单表数据量过大的问题（需要水平切分）</li></ul><h2 id="水平横向切分"><a class="markdownIt-Anchor" href="#水平横向切分"></a> 水平（横向）切分</h2><p>当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平切分了。</p><p><strong>水平切分分为库内分表和分库分表，是根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果</strong>。如图所示：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table/3.png"  alt="水平切分" title="水平切分" /></p><p>库内分表只解决了单一表数据量过大的问题，但没有将表分布到不同机器的库上，因此对于减轻MySQL数据库的压力来说，帮助不是很大，大家还是竞争同一个物理机的CPU、内存、网络IO，最好通过分库分表来解决。</p><h3 id="水平切分的优缺点"><a class="markdownIt-Anchor" href="#水平切分的优缺点"></a> 水平切分的优缺点</h3><p>优点：</p><ul><li>不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力</li><li>应用端改造较小，不需要拆分业务模块</li></ul><p>缺点：</p><ul><li>跨分片的事务一致性难以保证</li><li>跨库的join关联查询性能较差</li><li>数据多次扩展难度和维护量极大</li></ul><p>水平切分后同一张表会出现在多个数据库/表中，每个库/表的内容不同。下面介绍几种典型的数据分片规则</p><h3 id="水平切分几种典型的数据分片规则"><a class="markdownIt-Anchor" href="#水平切分几种典型的数据分片规则"></a> 水平切分几种典型的数据分片规则</h3><h4 id="根据数值范围"><a class="markdownIt-Anchor" href="#根据数值范围"></a> 根据数值范围</h4><p>按照时间区间或ID区间来切分。例如：按日期将不同月甚至是日的数据分散到不同的库中；将userId为1<sub>999999的记录分到第一个库，1000000</sub>2000000的分到第二个库，以此类推。某种意义上，某些系统中使用的&quot;冷热数据分离&quot;，将一些使用较少的历史数据迁移到其他库中，业务功能上只提供热点数据的查询，也是类似的实践。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table/4.png"  alt="根据数值范围" title="根据数值范围" /><br />优点：</p><ul><li>单表大小可控</li><li>天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移</li><li>使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。</li></ul><p>缺点：</p><ul><li>热点数据成为性能瓶颈。连续分片可能存在数据热点，例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询</li></ul><h4 id="根据数值取模"><a class="markdownIt-Anchor" href="#根据数值取模"></a> 根据数值取模</h4><p>一般采用hash取模mod的切分方式，例如：将 Customer 表根据 cusno 字段切分到4个库中，余数为0的放到第一个库，余数为1的放到第二个库，以此类推。这样同一个用户的数据会分散到同一个库中，如果查询条件带有cusno字段，则可明确定位到相应库去查询。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table/5.png"  alt="根据数值取模" title="根据数值取模" /><br />优点：</p><ul><li>数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈</li></ul><p>缺点：</p><ul><li>后期分片集群扩容时，需要迁移旧的数据（使用一致性hash算法能较好的避免这个问题）</li><li>容易面临跨分片查询的复杂问题。比如上例中，如果频繁用到的查询条件中不带cusno时，将会导致无法定位数据库，从而需要同时向4个库发起查询，再在内存中合并数据，取最小集返回给应用，分库反而成为拖累。</li></ul><h1 id="分库分表带来的问题"><a class="markdownIt-Anchor" href="#分库分表带来的问题"></a> 分库分表带来的问题</h1><p>分库分表能有效的环节单机和单库带来的性能瓶颈和压力，突破网络IO、硬件资源、连接数的瓶颈，同时也带来了一些问题。下面将描述这些技术挑战以及对应的解决思路</p><h2 id="事务一致性问题"><a class="markdownIt-Anchor" href="#事务一致性问题"></a> 事务一致性问题</h2><h3 id="分布式事务"><a class="markdownIt-Anchor" href="#分布式事务"></a> 分布式事务</h3><p>当更新内容同时分布在不同库中，不可避免会带来跨库事务问题。跨分片事务也是分布式事务，没有简单的方案，一般可使用&quot;XA协议&quot;和&quot;两阶段提交&quot;等方案处理。</p><p>分布式事务能最大限度保证了数据库操作的原子性。但在提交事务时需要协调多个节点，推后了提交事务的时间点，延长了事务的执行时间。导致事务在访问共享资源时发生冲突或死锁的概率增高。随着数据库节点的增多，这种趋势会越来越严重，从而成为系统在数据库层面上水平扩展的枷锁。</p><h3 id="最终一致性"><a class="markdownIt-Anchor" href="#最终一致性"></a> 最终一致性</h3><p>对于那些性能要求很高，但对一致性要求不高的系统，往往不苛求系统的实时一致性，只要在允许的时间段内达到最终一致性即可，可采用事务补偿的方式。与事务在执行中发生错误后立即回滚的方式不同，事务补偿是一种事后检查补救的措施，一些常见的实现方法有：对数据进行对账检查，基于日志进行对比，定期同标准数据来源进行同步等等。事务补偿还要结合业务系统来考虑。</p><p>可以参考往期：<a href="/posts/62ceeeec/"><strong>分布式事务解决方案</strong></a></p><h2 id="跨节点关联查询-join-问题"><a class="markdownIt-Anchor" href="#跨节点关联查询-join-问题"></a> 跨节点关联查询 join 问题</h2><p>切分之前，系统中很多列表和详情页所需的数据可以通过sql join来完成。而切分之后，数据可能分布在不同的节点上，此时join带来的问题就比较麻烦了，考虑到性能，尽量避免使用join查询。</p><p>解决这个问题的一些方法：</p><h3 id="全局表"><a class="markdownIt-Anchor" href="#全局表"></a> 全局表</h3><p>全局表，也可看做是&quot;数据字典表&quot;，就是系统中所有模块都可能依赖的一些表，为了避免跨库join查询，可以将这类表在每个数据库中都保存一份。这些数据通常很少会进行修改，所以也不担心一致性的问题。</p><h3 id="字段冗余"><a class="markdownIt-Anchor" href="#字段冗余"></a> 字段冗余</h3><p>一种典型的反范式设计，利用空间换时间，为了性能而避免join查询。例如：订单表保存userId时候，也将userName冗余保存一份，这样查询订单详情时就不需要再去查询&quot;买家user表&quot;了。</p><p>但这种方法适用场景也有限，比较适用于依赖字段比较少的情况。而冗余字段的数据一致性也较难保证，就像上面订单表的例子，买家修改了userName后，是否需要在历史订单中同步更新呢？这也要结合实际业务场景进行考虑。</p><h3 id="数据组装"><a class="markdownIt-Anchor" href="#数据组装"></a> 数据组装</h3><p>在系统层面，分两次查询，第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据。最后将获得到的数据进行字段拼装。</p><h3 id="er分片"><a class="markdownIt-Anchor" href="#er分片"></a> ER分片</h3><p>关系型数据库中，如果可以先确定表之间的关联关系，并将那些存在关联关系的表记录存放在同一个分片上，那么就能较好的避免跨分片join问题。在1:1或1:n的情况下，通常按照主表的ID主键切分。如下图所示：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table/6.png"  alt="ER分片" title="ER分片：父子关系-t_order_detail中order_id关联t_order中ID" /></p><p>这样一来，node1上面的t_order订单表与t_order_detail订单详情表就可以通过order_id进行局部的关联查询了，node2上也一样。</p><h2 id="跨节点分页-排序-函数问题"><a class="markdownIt-Anchor" href="#跨节点分页-排序-函数问题"></a> 跨节点分页、排序、函数问题</h2><p>跨节点多库进行查询时，会出现limit分页、order by排序等问题。分页需要按照指定字段进行排序，当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；当排序字段非分片字段时，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户。如图所示：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table/7.png"  alt="跨节点分页" title="跨节点分页" /></p><p>上图中只是取第一页的数据，对性能影响还不是很大。但是如果取得页数很大，情况则变得复杂很多，因为各分片节点中的数据可能是随机的，为了排序的准确性，需要将所有节点的前N页数据都排序好做合并，最后再进行整体的排序，这样的操作时很耗费CPU和内存资源的，所以页数越大，系统的性能也会越差。</p><p>在使用Max、Min、Sum、Count之类的函数进行计算的时候，也需要先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终将结果返回。如图所示：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table/8.png"  alt="使用Max、Min、Sum、Count之类的函数" title="使用Max、Min、Sum、Count之类的函数" /></p><h2 id="全局主键避重问题"><a class="markdownIt-Anchor" href="#全局主键避重问题"></a> 全局主键避重问题</h2><p>在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库自生成的ID无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题。下面介绍有一些常见的主键生成策略。</p><h3 id="uuid"><a class="markdownIt-Anchor" href="#uuid"></a> UUID</h3><p>UUID标准形式包含32个16进制数字，分为5段，形式为8-4-4-4-12的36个字符，详见<a href="https://baike.baidu.com/item/UUID" target="_blank" rel="noopener"><strong>UUID</strong></a>。例如：550e8400-e29b-41d4-a716-446655440000</p><p>UUID是主键是最简单的方案，本地生成，性能高，没有网络耗时。但缺点也很明显，由于UUID非常长，会占用大量的存储空间；另外，作为主键建立索引和基于索引进行查询时都会存在性能问题，在InnoDB下，UUID的无序性会引起数据位置频繁变动，导致分页。</p><h3 id="结合数据库维护主键id表"><a class="markdownIt-Anchor" href="#结合数据库维护主键id表"></a> 结合数据库维护主键ID表</h3><p>在数据库中建立 sequence 表：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sequence`</span> (  </span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,  </span><br><span class="line">  <span class="string">`stub`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">''</span>,  </span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`id`</span>),  </span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`stub`</span> (<span class="string">`stub`</span>)  </span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;</span><br></pre></td></tr></table></figure><p>stub字段设置为唯一索引，同一stub值在sequence表中只有一条记录，可以同时为多张表生成全局ID。sequence表的内容，如下所示：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">+-------------------+------+  </span><br><span class="line">| id                | stub |  </span><br><span class="line">+-------------------+------+  </span><br><span class="line">| <span class="number">82157623227190423</span> |    A |  </span><br><span class="line">+-------------------+------+</span><br></pre></td></tr></table></figure><p>使用 MyISAM 存储引擎而不是 InnoDB，以获取更高的性能。MyISAM使用的是表级别的锁，对表的读写是串行的，所以不用担心在并发时两次读取同一个ID值。</p><p>当需要全局唯一的64位ID时，执行：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> <span class="keyword">sequence</span> (stub) <span class="keyword">VALUES</span> (<span class="string">'A'</span>);  </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LAST_INSERT_ID</span>(); </span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>这两条语句是Connection级别的，select last_insert_id() 必须与 replace into 在同一数据库连接下才能得到刚刚插入的新ID。</p><p>使用replace into代替insert into好处是避免了表行数过大，不需要另外定期清理。</p><p>此方案较为简单，但缺点也明显：存在单点问题，强依赖DB，当DB异常时，整个系统都不可用。配置主从可以增加可用性，但当主库挂了，主从切换时，数据一致性在特殊情况下难以保证。另外性能瓶颈限制在单台MySQL的读写性能。</p><p>flickr团队使用的一种主键生成策略，与上面的sequence表方案类似，但更好的解决了单点和性能瓶颈的问题。<br />这一方案的整体思想是：建立2个以上的全局ID生成的服务器，每个服务器上只部署一个数据库，每个库有一张sequence表用于记录当前全局ID。表中ID增长的步长是库的数量，起始值依次错开，这样能将ID的生成散列到各个数据库上。如下图所示：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table/9.png"  alt="主键生成策略" title="主键生成策略" /></p><p>两个数据库服务器生成ID，设置不同的auto_increment值。第一台sequence的起始值为1，每次步长增长2，另一台的sequence起始值为2，每次步长增长也是2。结果第一台生成的ID都是奇数（1, 3, 5, 7 …），第二台生成的ID都是偶数（2, 4, 6, 8 …）。</p><p>这种方案将生成ID的压力均匀分布在两台机器上。同时提供了系统容错，第一台出现了错误，可以自动切换到第二台机器上获取ID。但有以下几个缺点：系统添加机器，水平扩展时较复杂；每次获取ID都要读写一次DB，DB的压力还是很大，只能靠堆机器来提升性能。</p><p>可以基于flickr的方案继续优化，使用批量的方式降低数据库的写压力，每次获取一段区间的ID号段，用完之后再去数据库获取，可以大大减轻数据库的压力。如下图所示：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table/10.png"  alt="主键生成策略优化" title="主键生成策略优化" /></p><p>还是使用两台DB保证可用性，数据库中只存储当前的最大ID。ID生成服务每次批量拉取6个ID，先将max_id修改为5，当应用访问ID生成服务时，就不需要访问数据库，从号段缓存中依次派发0<sub>5的ID。当这些ID发完后，再将max_id修改为11，下次就能派发6</sub>11的ID。于是，数据库的压力降低为原来的1/6。</p><h3 id="snowflake分布式自增id算法"><a class="markdownIt-Anchor" href="#snowflake分布式自增id算法"></a> Snowflake分布式自增ID算法</h3><p>Twitter的snowflake算法解决了分布式系统生成全局ID的需求，生成64位的Long型数字，组成部分：</p><p>第一位未使用</p><ul><li>接下来41位是毫秒级时间，41位的长度可以表示69年的时间</li><li>5位datacenterId，5位workerId。10位的长度最多支持部署1024个节点</li><li>最后12位是毫秒内的计数，12位的计数顺序号支持每个节点每毫秒产生4096个ID序列</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/snow-flake/1.png"  alt="SnowFlake" title="SnowFlake" /></p><p>这样的好处是：毫秒数在高位，生成的ID整体上按时间趋势递增；不依赖第三方系统，稳定性和效率较高，理论上QPS约为409.6w/s（1000*2^12），并且整个分布式系统内不会产生ID碰撞；可根据自身业务灵活分配bit位。</p><p>不足就在于：强依赖机器时钟，如果时钟回拨，则可能导致生成ID重复。</p><p>具体实现可以参考上期：<a href="/posts/29910899/"><strong>雪花算法</strong></a></p><p><strong>综上</strong><br />结合数据库和snowflake的唯一ID方案，可以参考业界较为成熟的解法：<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener"><strong>Leaf——美团点评分布式ID生成系统</strong></a>，并考虑到了高可用、容灾、分布式下时钟等问题。</p><h2 id="数据迁移-扩容问题"><a class="markdownIt-Anchor" href="#数据迁移-扩容问题"></a> 数据迁移、扩容问题</h2><p>当业务高速发展，面临性能和存储的瓶颈时，才会考虑分片设计，此时就不可避免的需要考虑历史数据迁移的问题。一般做法是先读出历史数据，然后按指定的分片规则再将数据写入到各个分片节点中。此外还需要根据当前的数据量和QPS，以及业务发展的速度，进行容量规划，推算出大概需要多少分片（一般建议单个分片上的单表数据量不超过1000W）</p><p>如果采用数值范围分片，只需要添加节点就可以进行扩容了，不需要对分片数据迁移。如果采用的是数值取模分片，则考虑后期的扩容问题就相对比较麻烦。</p><h1 id="什么时候考虑切分"><a class="markdownIt-Anchor" href="#什么时候考虑切分"></a> 什么时候考虑切分</h1><p>下面讲述一下什么时候需要考虑做数据切分。</p><h2 id="能不切分尽量不要切分"><a class="markdownIt-Anchor" href="#能不切分尽量不要切分"></a> 能不切分尽量不要切分</h2><p>并不是所有表都需要进行切分，主要还是看数据的增长速度。切分后会在某种程度上提升业务的复杂度，数据库除了承载数据的存储和查询外，协助业务更好的实现需求也是其重要工作之一。</p><p>不到万不得已不用轻易使用分库分表这个大招，避免&quot;过度设计&quot;和&quot;过早优化&quot;。分库分表之前，不要为分而分，先尽力去做力所能及的事情，例如：升级硬件、升级网络、读写分离、索引优化等等。当数据量达到单表的瓶颈时候，再考虑分库分表。</p><h2 id="数据量过大正常运维影响业务访问"><a class="markdownIt-Anchor" href="#数据量过大正常运维影响业务访问"></a> 数据量过大，正常运维影响业务访问</h2><p>这里说的运维，指：</p><ul><li><p>对数据库备份，如果单表太大，备份时需要大量的磁盘IO和网络IO。例如1T的数据，网络传输占50MB时候，需要20000秒才能传输完毕，整个过程的风险都是比较高的</p></li><li><p>对一个很大的表进行DDL修改时，MySQL会锁住全表，这个时间会很长，这段时间业务不能访问此表，影响很大。如果使用pt-online-schema-change，使用过程中会创建触发器和影子表，也需要很长的时间。在此操作过程中，都算为风险时间。将数据表拆分，总量减少，有助于降低这个风险。</p></li><li><p>大表会经常访问与更新，就更有可能出现锁等待。将数据切分，用空间换时间，变相降低访问压力</p></li></ul><h2 id="随着业务发展需要对某些字段垂直拆分"><a class="markdownIt-Anchor" href="#随着业务发展需要对某些字段垂直拆分"></a> 随着业务发展，需要对某些字段垂直拆分</h2><p>举个例子，假如项目一开始设计的用户表如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id                   bigint             #用户的ID</span><br><span class="line">name                 varchar            #用户的名字</span><br><span class="line">last_login_time      datetime           #最近登录时间</span><br><span class="line">personal_info        text               #私人信息</span><br><span class="line">.....                                   #其他信息字段</span><br></pre></td></tr></table></figure><p>在项目初始阶段，这种设计是满足简单的业务需求的，也方便快速迭代开发。而当业务快速发展时，用户量从10w激增到10亿，用户非常的活跃，每次登录会更新 last_login_name 字段，使得 user 表被不断update，压力很大。而其他字段：id, name, personal_info 是不变的或很少更新的，此时在业务角度，就要将 last_login_time 拆分出去，新建一个 user_time 表。</p><p>personal_info 属性是更新和查询频率较低的，并且text字段占据了太多的空间。这时候，就要对此垂直拆分出 user_ext 表了。</p><h2 id="数据量快速增长"><a class="markdownIt-Anchor" href="#数据量快速增长"></a> 数据量快速增长</h2><p>随着业务的快速发展，单表中的数据量会持续增长，当性能接近瓶颈时，就需要考虑水平切分，做分库分表了。此时一定要选择合适的切分规则，提前预估好数据容量</p><h2 id="安全性和可用性"><a class="markdownIt-Anchor" href="#安全性和可用性"></a> 安全性和可用性</h2><p>鸡蛋不要放在一个篮子里。在业务层面上垂直切分，将不相关的业务的数据库分隔，因为每个业务的数据量、访问量都不同，不能因为一个业务把数据库搞挂而牵连到其他业务。利用水平切分，当一个数据库出现问题时，不会影响到100%的用户，每个库只承担业务的一部分数据，这样整体的可用性就能提高。</p><h1 id="案例分析"><a class="markdownIt-Anchor" href="#案例分析"></a> 案例分析</h1><p><strong>用户中心业务场景</strong><br />用户中心是一个非常常见的业务，主要提供用户注册、登录、查询/修改等功能，其核心表为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User(uid, login_name, passwd, sex, age, nickname)</span><br><span class="line"></span><br><span class="line">uid为用户ID,  主键</span><br><span class="line">login_name, passwd, sex, age, nickname,  用户属性</span><br></pre></td></tr></table></figure><p>任何脱离业务的架构设计都是耍流氓，在进行分库分表前，需要对业务场景需求进行梳理：</p><p>用户侧：前台访问，访问量较大，需要保证高可用和高一致性。主要有两类需求：</p><ul><li>用户登录：通过login_name/phone/email查询用户信息，1%请求属于这种类型</li><li>用户信息查询：登录之后，通过uid来查询用户信息，99%请求属这种类型</li></ul><p>运营侧：后台访问，支持运营需求，按照年龄、性别、登陆时间、注册时间等进行分页的查询。是内部系统，访问量较低，对可用性、一致性的要求不高。</p><h2 id="水平切分方案"><a class="markdownIt-Anchor" href="#水平切分方案"></a> 水平切分方案</h2><p>当数据量越来越大时，需要对数据库进行水平切分，上文描述的切分方法有&quot;根据数值范围&quot;和&quot;根据数值取模&quot;。</p><p><strong>根据数值范围</strong>：以主键uid为划分依据，按uid的范围将数据水平切分到多个数据库上。例如：user-db1存储uid范围为0<sub>1000w的数据，user-db2存储uid范围为1000w</sub>2000wuid数据。</p><ul><li>优点是：扩容简单，如果容量不够，只要增加新db即可。</li><li>不足是：请求量不均匀，一般新注册的用户活跃度会比较高，所以新的user-db2会比user-db1负载高，导致服务器利用率不平衡</li></ul><p><strong>根据数值取模</strong>：也是以主键uid为划分依据，按uid取模的值将数据水平切分到多个数据库上。例如：user-db1存储uid取模得1的数据，user-db2存储uid取模得0的uid数据。</p><ul><li>优点是：数据量和请求量分布均均匀</li><li>不足是：扩容麻烦，当容量不够时，新增加db，需要rehash。需要考虑对数据进行平滑的迁移。</li></ul><h2 id="非uid的查询方法"><a class="markdownIt-Anchor" href="#非uid的查询方法"></a> 非uid的查询方法</h2><p>水平切分后，对于按uid查询的需求能很好的满足，可以直接路由到具体数据库。而按非uid的查询，例如login_name，就不知道具体该访问哪个库了，此时需要遍历所有库，性能会降低很多。</p><p>对于用户侧，可以采用&quot;建立非uid属性到uid的映射关系&quot;的方案；对于运营侧，可以采用&quot;前台与后台分离&quot;的方案。</p><h3 id="建立非uid属性到uid的映射关系"><a class="markdownIt-Anchor" href="#建立非uid属性到uid的映射关系"></a> 建立非uid属性到uid的映射关系</h3><h4 id="映射关系"><a class="markdownIt-Anchor" href="#映射关系"></a> 映射关系</h4><p>例如：login_name不能直接定位到数据库，可以建立login_name→uid的映射关系，用索引表或缓存来存储。当访问login_name时，先通过映射表查询出login_name对应的uid，再通过uid定位到具体的库。</p><p>映射表只有两列，可以承载很多数据，当数据量过大时，也可以对映射表再做水平切分。这类kv格式的索引结构，可以很好的使用cache来优化查询性能，而且映射关系不会频繁变更，缓存命中率会很高。</p><h4 id="基因法"><a class="markdownIt-Anchor" href="#基因法"></a> 基因法</h4><p>分库基因：假如通过uid分库，分为8个库，采用uid%8的方式进行路由，此时是由uid的最后3bit来决定这行User数据具体落到哪个库上，那么这3bit可以看为分库基因。</p><p>上面的映射关系的方法需要额外存储映射表，按非uid字段查询时，还需要多一次数据库或cache的访问。如果想要消除多余的存储和查询，可以通过f函数取login_name的基因作为uid的分库基因。生成uid时，参考上文所述的分布式唯一ID生成方案，再加上最后3位bit值=f(login_name)。当查询login_name时，只需计算f(login_name)%8的值，就可以定位到具体的库。不过这样需要提前做好容量规划，预估未来几年的数据量需要分多少库，要预留一定bit的分库基因。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/split-database-table/11.png"  alt="基因法" title="基因法" /></p><h3 id="前台与后台分离"><a class="markdownIt-Anchor" href="#前台与后台分离"></a> 前台与后台分离</h3><p>对于用户侧，主要需求是以单行查询为主，需要建立login_name/phone/email到uid的映射关系，可以解决这些字段的查询问题。</p><p>而对于运营侧，很多批量分页且条件多样的查询，这类查询计算量大，返回数据量大，对数据库的性能消耗较高。此时，如果和用户侧公用同一批服务或数据库，可能因为后台的少量请求，占用大量数据库资源，而导致用户侧访问性能降低或超时。</p><p>这类业务最好采用&quot;前台与后台分离&quot;的方案，运营侧后台业务抽取独立的service和db，解决和前台业务系统的耦合。由于运营侧对可用性、一致性的要求不高，可以不访问实时库，而是通过binlog异步同步数据到运营库进行访问。在数据量很大的情况下，还可以使用ES搜索引擎或Hive来满足后台复杂的查询方式。</p><h1 id="支持分库分表中间件"><a class="markdownIt-Anchor" href="#支持分库分表中间件"></a> 支持分库分表中间件</h1><p>站在巨人的肩膀上能省力很多，目前分库分表已经有一些较为成熟的开源解决方案：</p><ul><li><a href="https://github.com/sharding-sphere" target="_blank" rel="noopener">sharding-jdbc（当当）</a></li><li><a href="https://github.com/baihui212/tsharding" target="_blank" rel="noopener">TSharding（蘑菇街）</a></li><li><a href="https://github.com/Qihoo360/Atlas" target="_blank" rel="noopener">Atlas（奇虎360）</a></li><li><a href="https://github.com/alibaba/cobar" target="_blank" rel="noopener">Cobar（阿里巴巴）</a></li><li><a href="http://www.mycat.io/" target="_blank" rel="noopener">MyCAT（基于Cobar）</a></li><li><a href="https://github.com/58code/Oceanus" target="_blank" rel="noopener">Oceanus（58同城）</a></li><li><a href="https://github.com/vitessio/vitess" target="_blank" rel="noopener">Vitess（谷歌）</a></li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.cnblogs.com/jshen/p/7682502.html" target="_blank" rel="noopener">分库分表的思想</a><br /><a href="https://www.cnblogs.com/butterfly100/p/9034281.html" target="_blank" rel="noopener">原文——数据库分库分表思路</a><br /><a href="https://zhuanlan.zhihu.com/p/27871998" target="_blank" rel="noopener">数据库分布式架构扫盲——分库分表</a><br /><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960212&amp;idx=1&amp;sn=ab4c52ab0309f7380f7e0207fa357128&amp;pass_ticket=G8v3RrpK9Is7NJZH0fOShUfY8lp5oz9un8K5L24LeGGVtiBTXkBMc9UKkTMdQeDS" target="_blank" rel="noopener">数据库水平切分架构实践</a><br /><a href="http://www.ywnds.com/?p=7239" target="_blank" rel="noopener">从原则、方案、策略及难点阐述分库分表</a><br /><a href="https://tech.meituan.com/MT_Leaf.html" target="_blank" rel="noopener">Leaf——美团点评分布式ID生成系统</a><br /><a href="http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-horizontal-split-table" target="_blank" rel="noopener">水平分库分表的关键步骤以及可能遇到的问题</a><br /><a href="http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-horizontal-split-table" target="_blank" rel="noopener">水平分库分表的关键步骤以及可能遇到的问题</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分库分表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>snowflake算法</title>
      <link href="/posts/29910899/"/>
      <url>/posts/29910899/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><p>SnowFlake 算法，是 Twitter 开源的分布式 id 生成算法。<br />其核心思想就是：使用一个 64 bit 的 long 型的数字作为全局唯一 id。<br />在分布式系统中的应用十分广泛，且ID 引入了时间戳，基本上保持自增的，后面的代码中有详细的注解。</p><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/snow-flake/1.png"  alt="SnowFlake" title="SnowFlake" /></p><p>如图：</p><ul><li>最高位是符号位，始终为0，表示正数，不可用。</li><li>41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。</li><li>10位的机器标识，10位的长度最多支持部署1024个节点。</li><li>12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。</li></ul><h1 id="java实现"><a class="markdownIt-Anchor" href="#java实现"></a> Java实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Twitter的Snowflake 算法&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 分布式系统中，有一些需要使用全局唯一ID的场景，有些时候我们希望能使用一种简单一些的ID，并且希望ID能够按照时间有序生成。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * snowflake的结构如下(每部分用-分开):&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 第一位为未使用，接下来的41位为毫秒级时间(41位的长度可以使用69年)&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点）&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 一共加起来刚好64位，为一个Long型。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 并且可以通过生成的id反推出生成时间,datacenterId和workerId</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> maomao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/03/01 18:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Snowflake</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间 可以设置为系统上线时间（2019-01-01）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> twepoch = <span class="number">1546272000000L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器id所占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据标识id所占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大支持数据中心节点数0~31，一共32个 结果是31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列在id中占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器ID向左移12位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据标识id向左移17位(12+5)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间截向左移22位(5+5+12)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> dataCenterId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId     终端ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataCenterId 数据中心ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Snowflake</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> dataCenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"worker Id can't be greater than %d or less than 0"</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dataCenterId &gt; maxDatacenterId || dataCenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"datacenter Id can't be greater than %d or less than 0"</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.dataCenterId = dataCenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Snowflake的ID，获取机器id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id snowflake算法生成的id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 所属机器的id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getWorkerId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id &gt;&gt; workerIdShift &amp; ~(-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Snowflake的ID，获取数据中心id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id snowflake算法生成的id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 所属数据中心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDataCenterId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id &gt;&gt; datacenterIdShift &amp; ~(-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Snowflake的ID，获取生成时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id snowflake算法生成的id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 生成的时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getGenerateDateTime</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (id &gt;&gt; timestampLeftShift &amp; ~(-<span class="number">1L</span> &lt;&lt; <span class="number">41L</span>)) + twepoch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个ID</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = genTime();</span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="comment">// 如果服务器时间有问题(时钟后退) 报错。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">"Clock moved backwards. Refusing to generate id for %d ms"</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line">        <span class="comment">// sequenceMask 为啥是4095  2^12 = 4096</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 时间戳改变，毫秒内序列重置</span></span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上次生成ID的时间截</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (dataCenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个ID（字符串形式）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ID 字符串形式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">nextIdStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Long.toString(nextId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环等待下一个时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上次记录的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 下一个时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = genTime();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = genTime();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成时间戳</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">genTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Snowflake idWorker = <span class="keyword">new</span> Snowflake(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> id = idWorker.nextId();</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((System.nanoTime() - startTime) / <span class="number">1000000</span> + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="snowflake算法优缺点"><a class="markdownIt-Anchor" href="#snowflake算法优缺点"></a> SnowFlake算法优缺点</h1><h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2><ul><li>高性能高可用：生成时不依赖于数据库，完全在内存中生成。</li><li>容量大：每秒中能生成数百万的自增ID。</li><li>ID自增：存入数据库中，索引效率高。</li></ul><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><ul><li>依赖与系统时间的一致性，如果系统时间被回调，或者改变，可能会造成id冲突或者重复（可以用百度开源的分布式唯一ID生成器 UidGenerator或者美团开源的分布式ID生成系统 Leaf解决）</li><li>在分布式系统中，所有的机器可能时间不同步，会导致Id不是全局递增的（正常我们只需要趋势递增就OK）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> snowflake算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务解决方案</title>
      <link href="/posts/62ceeeec/"/>
      <url>/posts/62ceeeec/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p>在<a href="/posts/a2fb19c9/">上一篇</a>文章的BASE理论中提到了最终一致性，其实分布式事务的讨论主要就是聚焦于强一致性和最终一致性。</p><p>分布式事务就是为了解决微服务架构（形式都是分布式系统）中不同节点之间的数据一致性问题。这个一致性问题本质上解决的也是传统事务需要解决的问题，即一个请求在多个微服务调用链中，所有服务的数据处理要么全部成功，要么全部回滚。当然分布式事务问题的形式可能与传统事务会有比较大的差异，但是问题本质是一致的，都是要求解决数据的一致性问题。</p><p>下面我们从微服务开始来了解一下分布式事务和一些最终一致性的解决方案。</p><h1 id="微服务"><a class="markdownIt-Anchor" href="#微服务"></a> 微服务</h1><h2 id="微服务发展"><a class="markdownIt-Anchor" href="#微服务发展"></a> 微服务发展</h2><p>微服务倡导将复杂的单体应用拆分为若干个功能简单、松耦合的服务，这样可以降低开发难度、增强扩展性、便于敏捷开发。当前被越来越多的开发者推崇，很多互联网行业巨头、开源社区等都开始了微服务的讨论和实践。</p><h2 id="微服务落地存在的问题"><a class="markdownIt-Anchor" href="#微服务落地存在的问题"></a> 微服务落地存在的问题</h2><p>虽然微服务现在如火如荼，但对其实践其实仍处于探索阶段。很多中小型互联网公司，鉴于经验、技术实力等问题，微服务落地比较困难。</p><p>如著名架构师Chris Richardson所言，目前存在的主要困难有如下几方面：</p><ol><li>单体应用拆分为分布式系统后，进程间的通讯机制和故障处理措施变的更加复杂。</li><li>系统微服务化后，一个看似简单的功能，内部可能需要调用多个服务并操作多个数据库实现，服务调用的分布式事务问题变的非常突出。</li><li>微服务数量众多，其测试、部署、监控等都变的更加困难。</li></ol><p>随着RPC框架的成熟，第一个问题已经逐渐得到解决。例如springcloud可以非常好的支持restful调用，dubbo可以支持多种通讯协议。</p><p>对于第三个问题，随着docker、devops技术的发展以及各公有云paas平台自动化运维工具的推出，微服务的测试、部署与运维会变得越来越容易。</p><p>而对于第二个问题，现在还没有通用方案很好的解决微服务产生的事务问题。分布式事务已经成为微服务落地最大的阻碍，也是最具挑战性的一个技术难题。</p><h1 id="分布式事务中相关概念"><a class="markdownIt-Anchor" href="#分布式事务中相关概念"></a> 分布式事务中相关概念</h1><p><strong>刚性事务</strong>：满足ACID理论的事务</p><p><strong>柔性事务</strong>：满足BASE理论（基本可用，最终一致）的事务</p><p><strong>XA协议</strong>：全局事务管理器与资源管理器的接口。XA是由X/Open组织提出的分布式事务规范。该规范主要定义了全局事务管理器和局部资源管理器之间的接口。主流的数据库产品都实现了XA接口。XA接口是一个双向的系统接口，在事务管理器以及多个资源管理器之间作为通信桥梁。之所以需要XA是因为在分布式系统中从理论上讲两台机器是无法达到一致性状态的，因此引入一个单点进行协调。由全局事务管理器管理和协调的事务可以跨越多个资源和进程。全局事务管理器一般使用XA二阶段协议与数据库进行交互。</p><p><strong>幂等</strong>：重复调用多次产生的业务结果与调用一次产生的结果相同。</p><h1 id="分布式事务典型方案"><a class="markdownIt-Anchor" href="#分布式事务典型方案"></a> 分布式事务典型方案</h1><p>在分布式系统中，要实现分布式事务，现有解决方案无外乎那几种，下面我们就来一一了解一下。</p><h2 id="两阶段提交2pc"><a class="markdownIt-Anchor" href="#两阶段提交2pc"></a> 两阶段提交(2PC)</h2><p>两阶段提交缩写2PC（two-phase commit）,是一个非常经典的强一致、中心化的原子提交协议。这里所说的中心化是指协议中有两类节点：一个中心化<strong>协调者</strong>节点（coordinator）和N个<strong>参与者</strong>节点（partcipant）。</p><ol><li><p><strong>第一阶段表决阶段(投票阶段)</strong>：所有参与者都将本事务能否成功的信息反馈发给协调者。</p><ul><li>事务询问：协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应</li><li>执行事务并反馈：各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中，如果参与者成功执事务操作，就反馈给协调者Yes响应，表示事物可以执行，如果没有成功执行事务，就反馈给协调者No响应，表示事务不可以执行</li></ul></li><li><p><strong>第二阶段执行阶段</strong>：协调者根据所有参与者的反馈，通知所有参与者，步调一致地在所有分支上提交或者回滚。<br />假如协调者从所有的参与者或得反馈都是Yes响应，那么就会执行事务提交</p><ul><li>发送提交请求：协调者向所有参与者节点发出Commit请求</li><li>事务提交：参与者接受到Commit请求后，会正式执行事务提交操作，并在完成提交之后放弃整个事务执行期间占用的事务资源</li><li>反馈事务提交结果：参与者在完成事物提交之后，向协调者发送ACK消息</li><li>完成事务：协调者接收到所有参与者反馈的ACK消息后，完成事务</li></ul><p>假如任何一个参与者向协调者反馈了No响应，或者在等待超市之后，协调者尚无法接收到所有参与者的反馈响应，那么就中断事务。</p><ul><li>发送回滚请求：协调者向所有参与者节点发出Rollback请求</li><li>事务回滚：参与者接收到Rollback请求后，会利用其在阶段一中记录的Undo信息执行事物回滚操作，并在完成回滚之后释放事务执行期间占用的资源。</li><li>反馈事务回滚结果：参与则在完成事务回滚之后，向协调者发送ACK消息</li><li>中断事务：协调者接收到所有参与者反馈的ACk消息后，完成事务中断</li></ul></li></ol><img alt='2PC' src='https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/distributed-transaction/1.png' align='left'/><h3 id="存在的问题"><a class="markdownIt-Anchor" href="#存在的问题"></a> 存在的问题</h3><ul><li><strong>同步阻塞</strong>：对于任何一次指令必须收到明确的响应，才会继续做下一步，否则处于阻塞状态，占用的资源被一直锁定，不会被释放。</li><li><strong>单点故障</strong>：一旦协调者出现故障，整个系统不可用</li><li><strong>数据不一致</strong>：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li><li><strong>不确定性</strong>：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。</li></ul><h2 id="三阶段提交3pc"><a class="markdownIt-Anchor" href="#三阶段提交3pc"></a> 三阶段提交(3PC)</h2><p>三阶段提交协议（3PC 协议）是两阶段提交协议的改进版本。它通过超时机制解决了阻塞的问题，并且把两个阶段增加为三个阶段：</p><ol><li><strong>第一阶段询问阶段(CanCommit)</strong>：协调者询问参与者是否可以完成指令，协调者只需要回答是还是不是，而不需要做真正的操作，这个阶段参与者在等待超时后会自动中止。</li><li><strong>第二阶段准备阶段(PreCommit)</strong>：如果在询问阶段所有的参与者都返回可以执行操作，协调者向参与者发送预执行请求，然后参与者写 redo 和 undo 日志，锁定资源，执行操作，但是不提交操作；如果在询问阶段任何参与者返回不能执行操作的结果，则协调者向参与者发送中止请求，这里的逻辑与两阶段提交协议的的准备阶段是相似的，这个阶段参与者在等待超时后会自动提交。</li><li><strong>第三阶段提交阶段(Commit)</strong>：如果每个参与者在准备阶段返回准备成功，也就是预留资源和执行操作成功，协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；如果任何一个参与者返回准备失败，也就是预留资源或者执行操作失败，协调者向参与者发起中止指令，参与者取消已经变更的事务，执行 undo 日志，释放锁定的资源，这里的逻辑与两阶段提交协议的提交阶段一致。</li></ol><p>询问阶段可以确保尽可能早的发现无法执行操作而需要中止的行为，但是它并不能发现所有的这种行为，只会减少这种情况的发生。<br />如果在询问阶段等待超时，则自动中止；如果在准备阶段之后等待超时，则自动提交。这也是根据概率统计上的正确性最大。</p><h2 id="tcc方案"><a class="markdownIt-Anchor" href="#tcc方案"></a> TCC方案</h2><p>TCC（Try-Confirm-Cancel）又称补偿事务。其核心思想是：“针对每个操作都要注册一个与其对应的确认和补偿（撤销操作）”。它分为三个操作：</p><ol><li><strong>Try操作</strong>：主要是对业务系统做检测及资源预留。</li><li><strong>Confirm操作</strong>：确认执行业务操作。(需要保证幂等性)</li><li><strong>Cancel操作</strong>：取消执行业务操作。(需要保证幂等性)</li></ol><p>事务发起方向事务协调器发起事务请求，事务协调器调用所有事务参与者的 try 方法完成资源的预留，这时候并没有真正执行业务，而是为后面具体要执行的业务预留资源，这里完成了一阶段。<br />如果事务协调器发现有参与者的 try 方法预留资源时候发现资源不够，则调用参与方的 cancel 方法回滚预留的资源，需要注意 cancel 方法需要实现业务幂等，因为有可能调用失败（比如网络原因参与者接受到了请求，但是由于网络原因事务协调器没有接受到回执）会重试。<br />如果事务协调器发现所有参与者的 try 方法返回都 OK，则事务协调器调用所有参与者的 confirm 方法，不做资源检查，直接进行具体的业务操作。<br />如果协调器发现所有参与者的 confirm 方法都 OK 了，则分布式事务结束。<br />如果协调器发现有些参与者的 confirm 方法失败了，或者由于网络原因没有收到回执，则协调器会进行重试。这里如果重试一定次数后还是失败，会做事务补偿。</p><img alt='TCC' src='https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/distributed-transaction/2.png' align='left'/><p>与2PC协议比较 ，TCC拥有以下特点：</p><ul><li>位于业务服务层而非资源层 ，由业务层保证原子性</li><li>没有单独的准备(Prepare)阶段，降低了提交协议的成本</li><li>Try操作 兼备资源操作与准备能力</li><li>Try操作可以灵活选择业务资源的锁定粒度，而不是锁住整个资源，提高了并发度</li></ul><p>当然，TCC需要较高的开发成本，每个子业务都需要有响应的comfirm、Cancel操作，即实现相应的补偿逻辑。</p><h2 id="本地消息表"><a class="markdownIt-Anchor" href="#本地消息表"></a> 本地消息表</h2><p>本地消息表这个方案最初是 ebay 架构师 Dan Pritchett 在 2008 年发表给 ACM 的文章。该方案中会有消息生产者与消费者两个角色，假设系统 A 是消息生产者，系统 B 是消息消费者，其大致流程如下：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/distributed-transaction/3.png"  alt="本地消息表" /></p><ol><li>当系统 A 被其他系统调用发生数据库表更操作，首先会更新数据库的业务表，其次会往相同数据库的消息表中插入一条数据，两个操作发生在同一个事务中</li><li>系统 A 的脚本定期轮询本地消息往 mq 中写入一条消息，如果消息发送失败会进行重试</li><li>系统 B 消费 mq 中的消息，并处理业务逻辑。如果本地事务处理失败，会在继续消费 mq 中的消息进行重试，如果业务上的失败，可以通知系统 A 进行回滚操作。<br />本地消息表实现的条件：</li></ol><ul><li>消费者与生成者的接口都要支持幂等</li><li>生产者需要额外记录消息日志</li><li>需要提供补偿逻辑，如果消费者业务失败，需要生产者支持回滚操作<br />容错机制：</li><li>步骤 1 失败时，事务直接回滚</li><li>步骤 2、3 写 mq 与消费 mq 失败会进行重试</li><li>步骤 3 业务失败系统 B 向系统 A 发起事务回滚操作</li></ul><p>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。</p><h2 id="基于可靠消息"><a class="markdownIt-Anchor" href="#基于可靠消息"></a> 基于可靠消息</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/distributed-transaction/4.png"  alt="基于可靠消息" /><br />如上图，大致流程如下：</p><ol><li>A 系统先向 mq 发送一条 prepare 消息，如果 prepare 消息发送失败，则直接取消操作<br />如果消息发送成功，则执行本地事务</li><li>如果本地事务执行成功，则向 mq 发送一条 confirm 消息，如果发送失败，则发送回滚消息</li><li>B 系统定期消费 mq 中的 confirm 消息，执行本地事务，并发送 ack 消息。如果 B 系统中的本地事务失败，会一直不断重试，如果是业务失败，会向 A 系统发起回滚请求</li><li>mq 会定期轮询所有 prepared 消息调用系统 A 提供的接口查询消息的处理情况，如果该 prepare 消息本地事务处理成功，则重新发送 confirm 消息，否则直接回滚该消息</li></ol><p>该方案与本地消息最大的不同是去掉了本地消息表，其次本地消息表依赖消息表重试写入 mq 这一步由本方案中的轮询 prepare 消息状态来重试或者回滚该消息替代。其实现条件与余容错方案基本一致。目前市面上实现该方案的只有阿里的 RocketMq。</p><h2 id="最大努力通知"><a class="markdownIt-Anchor" href="#最大努力通知"></a> 最大努力通知</h2><p>最大努力通知是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果 不影响主动方的处理结果。</p><p>这个方案的大致意思就是：</p><p>系统 A 本地事务执行完之后，发送个消息到 MQ；<br />这里会有个专门消费 MQ 的服务，这个服务会消费 MQ 并调用系统 B 的接口；<br />要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B, 反复 N 次(逐步拉大通知间隔)，最后还是不行就放弃。</p><p>系统A应该提供一个查询执行情况接口，以供系统B校对结果和执行补偿操作。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>到这里分布式事务了解得差不多了，分布式事务本身是一个技术难题，是没有一种完美的方案应对所有场景的，具体还是要根据业务场景去抉择。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p><a href="https://www.jianshu.com/p/5f193a5fc9cf" target="_blank" rel="noopener">详谈式最终一致性</a><br /><a href="https://www.cnblogs.com/bluemiaomiao/p/11216380.html" target="_blank" rel="noopener">分布式事务中常见的三种解决方案</a><br /><a href="https://zhuanlan.zhihu.com/p/100279671" target="_blank" rel="noopener">微服务分布式事务4种解决方案实战</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP原则和BASE的学习</title>
      <link href="/posts/a2fb19c9/"/>
      <url>/posts/a2fb19c9/</url>
      
        <content type="html"><![CDATA[<p>分布式系统（distributed system）正变得越来越重要，现在大型网站几乎都是分布式的。<br />分布式系统的最大难点，就是各个节点的状态如何同步。CAP 原则是这方面的基本，下面我们就来了解一下CAP原则和其权衡的结果BASE。</p><h1 id="cap原则"><a class="markdownIt-Anchor" href="#cap原则"></a> CAP原则</h1><p>CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得。</p><ul><li><strong>一致性</strong>（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（注意这个的C和数据库事务ACID中的C是不同的含义，要注意区分）</li><li><strong>可用性</strong>（A）：在用户访问系统时，系统是否还能响应客户端的读写请求。</li><li><strong>分区容错性</strong>（P）：分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。</li></ul><p>如下图：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/cap-base/1.png"  alt="CAP原则" /></p><p>由于分区容忍性是分布式的最基本要求，大部分的分布式系统都是在C和A之间做选择。</p><h1 id="base"><a class="markdownIt-Anchor" href="#base"></a> BASE</h1><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。</p><p>BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p><p>接下来我们着重对BASE中的三要素进行详细讲解。</p><p><strong>基本可用</strong>：指分布式系统在出现不可预知故障的时候，允许损失部分可用性。<br />注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子：</p><p><em>响应时间上的损失</em>：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。<br /><em>功能上的损失</em>：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p><p><strong>软状态状态</strong>：是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><p><strong>最终一致性</strong>：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><p>参考资料：<br /><a href="https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">CAP原则 - 百科</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring事务</title>
      <link href="/posts/7d41eccf/"/>
      <url>/posts/7d41eccf/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是事务"><a class="markdownIt-Anchor" href="#什么是事务"></a> 什么是事务</h1><p>事务(Transaction)是指是程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，否则在每个操作中所作的所有更改都会被撤消。Spring事务管理基于底层数据库本身的事务处理机制。</p><p>事务具备ACID四种特性，ACID是Atomic（原子性）、Consistency（一致性）、Isolation（隔离性）和Durability（持久性）的英文缩写。</p><ul><li>原子性（Atomicity）<br />原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</li><li>一致性（Consistency）<br />一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。举例来说，假设用户A和用户B两者的钱加起来一共是1000，那么不管A和B之间如何转账、转几次账，事务结束后两个用户的钱相加起来应该还得是1000，这就是事务的一致性。</li><li>隔离性（Isolation）<br />隔离性是当多个用户并发访问数据库时，比如同时操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li><li>持久性（Durability）<br />持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li></ul><h1 id="事务的传播特性"><a class="markdownIt-Anchor" href="#事务的传播特性"></a> 事务的传播特性</h1><p>事务传播行为就是多个事务方法调用时，如何定义方法间事务的传播。Spring定义了7中传播行为：</p><ol><li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，<strong>这是Spring默认的选择</strong>。</li><li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li><li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li><li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li><li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li><li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作。</li></ol><h1 id="事务的隔离级别"><a class="markdownIt-Anchor" href="#事务的隔离级别"></a> 事务的隔离级别</h1><ol><li>read uncommited：是最低的事务隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。</li><li>read commited：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。</li><li>repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻读。它除了保证一个事务不能被另外一个事务读取未提交的数据之外还避免了以下情况产生（不可重复读）。</li><li>serializable：这是花费最高代价但最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻读</li></ol><h2 id="脏读-不可重复读-幻读概念说明"><a class="markdownIt-Anchor" href="#脏读-不可重复读-幻读概念说明"></a> 脏读、不可重复读、幻读概念说明</h2><ul><li><strong>脏读</strong>：指当一个事务正字访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。</li><li><strong>不可重复读</strong>：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。</li><li><strong>幻读</strong>：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）</li></ul><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">read uncommited</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">read commited</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">repeatable read</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">serializable</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><p>(√)代表会发生，(×)代表不会发生</p><h1 id="事务几种实现方式"><a class="markdownIt-Anchor" href="#事务几种实现方式"></a> 事务几种实现方式</h1><ol><li>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。</li><li>基于 TransactionProxyFactoryBean的声明式事务管理</li><li>基于 @Transactional 的声明式事务管理</li><li>基于Aspectj AOP配置事务</li></ol><h1 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h1><p><a href="https://www.jianshu.com/p/35a60503e6c3" target="_blank" rel="noopener">Spring 事务详解</a></p><style>table th {width: 25%;}</style>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth 2.0 学习</title>
      <link href="/posts/443da21b/"/>
      <url>/posts/443da21b/</url>
      
        <content type="html"><![CDATA[<h1 id="oauth-20-介绍"><a class="markdownIt-Anchor" href="#oauth-20-介绍"></a> OAuth 2.0 介绍</h1><p>OAuth（Open Authorization，开放授权）是为用户资源的授权定义了一个安全、开放及简单的标准，第三方无需知道用户的账号及密码，就可获取到用户的授权信息。<br />OAuth2.0是OAuth协议的延续版本，但不向后兼容OAuth 1.0。</p><p>在传统的客户端-服务器身份验证模型中，客户端请求访问限制资源（受保护的资源）是通过使用资源所有者凭证向资源服务器进行身份验证。为了让第三方应用程序访问受限制的资源，资源所有者需要将自己的凭证提供给第三方。这会带来一些问题和局限性：</p><ul><li>需要第三方应用程序来存储资源所有者的凭证以供将来使用，通常是密码明文。</li><li>服务器需要支持密码验证，尽管密码方式有安全性弱点。</li><li>第三方应用程序获得了访问限制资源的权限并可以持续访问，而且也有访问限制资源子集的能力。</li><li>资源所有者不能撤消对单个第三方的访问权限而不撤销所有第三方的访问权限，如果要撤销授权就只能修改密码。</li><li>任何第三方应用程序被攻击都会导致用户密码以及其保护的资源损害。</li></ul><p>OAuth通过引入授权层解决了这些问题，并将客户角色与资源角色分开。在OAuth中，客户端请求访问受控资源，由资源所有者控制并由资源服务器托管，并且发出的凭证与资源所有者的凭证不同。而不是直接使用资源所有者的凭证来访问受保护的资源。大致流程如下：</p><ol><li>客户端申请<strong>访问令牌</strong>（包含访问具体范围，生存期和其他访问属性的字符串）。</li><li>访问令牌经资源所有者的批准由授权服务器向第三方客户端颁发。</li><li>客户端使用访问令牌访问资源服务器托管的受保护资源。</li></ol><h1 id="oauth-20-中的角色"><a class="markdownIt-Anchor" href="#oauth-20-中的角色"></a> OAuth 2.0 中的角色</h1><p>OAuth 2.0为用户和应用定义了如下四种角色：</p><ul><li><p>资源拥有者(resource owner)</p><p>资源拥有者是指拥有共享数据的人或应用。比如Facebook或者Google的用户就是是资源拥有者，他们拥有的资源就是他们的数据。资源拥有者一般指人，这也是最常见的情况。但资源拥有者也可以是一个应用，OAuth 2.0规范中包含这两种可能性。</p></li><li><p>资源服务器(resource server)</p><p>资源服务器是指托管资源的服务器。比如，Facebook或Google就是资源服务器(或者有一个资源服务器)。</p></li><li><p>客户端应用(client)</p><p>客户端应用是指请求访问存储在资源服务器的资源的应用。资源被资源拥有者所拥有。客户端应用可以是一个请求访问用户Facebook账号的第三方游戏。</p></li><li><p>授权服务器(authorization server)</p><p>授权服务器是指授权客户端应用能够访问资源拥有者所拥有的资源。授权服务器和资源服务器可以是同一个服务器，但不是必须的。如果这两个服务器是分开的，OAuth 2.0没有讨论这个两个服务器应该如何通信。这是由资源服务器和授权服务器开发者自己设计决定的。</p></li></ul><h1 id="oauth-20-授权方式"><a class="markdownIt-Anchor" href="#oauth-20-授权方式"></a> OAuth 2.0 授权方式</h1><p>OAuth 2.0为我们提供了四种授权方式，如下：</p><ul><li>授权码（authorization-code）</li><li>隐藏式（implicit）</li><li>密码式（password）：</li><li>客户端凭证（client credentials）</li></ul><p><strong>注意</strong>：不管哪一种授权方式，第三方应用申请令牌之前，都必须先到要访问的系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。<br />下面我们就一一来了解一下。</p><h2 id="授权码方式"><a class="markdownIt-Anchor" href="#授权码方式"></a> 授权码方式</h2><p>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</p><p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。如下图：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/oauth2/1.png"  alt="授权码方式" /></p><p><strong>A</strong>：用户访问客户端，客户端将用户导向授权服务器，通过用户代理（User-Agent）发送包括它的客户端标识符、请求的范围、本地状态和一个重定向URI，授权服务器在授予(或拒绝)访问权后将其发送给用户代理。URI如下：</p><blockquote><p><code>http://authorization-server/oauth/authorize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=CALLBACK_URL&amp;scope=read</code></p></blockquote><p>在URI中<code>response_type</code>参数表示要求返回授权码（code），<code>client_id</code>参数让授权服务器知道是谁在请求，<code>redirect_uri</code>参数是授权服务器接受或拒绝请求后的跳转网址（一般需要encode），scope参数表示要求的授权范围（这里是只读）</p><p><strong>B</strong>：授权服务器对资源所有者进行身份验证(通过用户代理，让用户输入用户名和密码)，并确定资源所有者是否授予或拒绝客户端的访问请求。</p><p><strong>C</strong>：用户跳转后，假如资源所有者同意授权请求，那么授权服务器将会使用前面提供的或者事先指定的重定向URI（redirection URI），重定向到客户端，并附上一个授权码（code）和一个前面提供的本地状态（state）（如果有的话，则会原值返回）。</p><blockquote><p><code>https://client/callback?code=AUTHORIZATION_CODE</code></p></blockquote><p>上面 URL 中，<code>code</code>参数就是授权码。</p><p><strong>D</strong>：客户端收到授权码，附上早先的重定向URI，向授权服务器申请令牌。这一步是在<strong>客户端的后台</strong>的服务器上完成的，对用户不可见。在发出请求时，授权服务器对客户端进行身份验证。请求参数包含授权代码、用于获得验证的授权代码的重定向URI、标识客户端身份的client id和client secret。</p><blockquote><p><code>https://authorization-server/oauth/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRETgrant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=CALLBACK_URL</code></p></blockquote><p>上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 authorization-server 确认 client 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p><p><strong>E</strong>：授权服务器对客户端进行身份验证，验证授权代码，并确保所收到的重定向URI与用于在步骤<strong>C</strong>中对客户端重定向的URI相匹配，如果有效，授权服务器将发送访问令牌<code>access token</code>和刷新令牌<code>refresh token</code>（可选）。</p><p>然后授权服务器给我们返回授权码，如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="attr">"access_token"</span>:<span class="string">"ACCESS_TOKEN"</span>,</span><br><span class="line">  <span class="attr">"token_type"</span>:<span class="string">"bearer"</span>,</span><br><span class="line">  <span class="attr">"expires_in"</span>:<span class="number">2592000</span>,</span><br><span class="line">  <span class="attr">"refresh_token"</span>:<span class="string">"REFRESH_TOKEN"</span>,</span><br><span class="line">  <span class="attr">"scope"</span>:<span class="string">"read"</span>,</span><br><span class="line">  <span class="attr">"other"</span>:<span class="string">"..."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的参数主要是：</p><ul><li>access_token：表示访问令牌。必选项。</li><li>token_type：表示令牌类型。该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>refresh_token：表示更新令牌。可选项，用来获取下一次的访问令牌。</li><li>scope：表示权限范围。可选项，如果与客户端申请的范围一致，此项可省略。</li></ul><p>最后我们拿到access_token去访问受保护的资源即可，如下：</p><blockquote><p><code>http://resource-server/api/userinfo?access_token=ACCESS_TOKEN</code></p></blockquote><h2 id="隐藏式"><a class="markdownIt-Anchor" href="#隐藏式"></a> 隐藏式</h2><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）“隐藏式”（implicit）。如下图：<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/oauth2/2.png"  alt="隐藏式" /></p><p><strong>A</strong>：Client网站提供一个链接，要求用户跳转到authorization-server，授权用户数据给 Client 网站使用。</p><blockquote><p><code>https://authorization-server/oauth/authorize?response_type=token&amp;client_id=CLIENT_IDredirect_uri=CALLBACK_URL&amp;scope=read</code></p></blockquote><p>上面 URL 中，<code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。</p><p><strong>B</strong>：授权服务器对资源所有者进行身份验证(通过用户代理，让用户输入用户名和密码)，并确定资源所有者是否授予或拒绝客户端的访问请求。</p><p><strong>C</strong>：用户跳转到 authorization-server ，登录后同意给予 client 网站授权。这时，authorization-server就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 client。</p><blockquote><p><code>https://client/callback#token=ACCESS_TOKEN</code></p></blockquote><p>上面 URL 中，<code>token</code>参数就是令牌，client因此直接在前端拿到令牌。</p><p><strong>注意</strong>:令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在&quot;中间人攻击&quot;的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p><p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p><h2 id="密码式"><a class="markdownIt-Anchor" href="#密码式"></a> 密码式</h2><p>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为&quot;密码式&quot;（password）。如下图：<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/oauth2/3.png"  alt="密码式" /></p><p><strong>A</strong>：Client要求用户提供authorization-server的用户名和密码。</p><p><strong>B</strong>：拿到用户名密码以后，Client 就直接向 authorization-server 请求令牌。</p><blockquote><p><code>https://authorization-server/token?grant_type=password&amp;username=USERNAME&amp;password=PASSWORD&amp;client_id=CLIENT_ID</code></p></blockquote><p>上面 URL 中，grant_type参数是授权方式，这里的password表示&quot;密码式&quot;，username和password是 authorization-server 的用户名和密码。</p><p><strong>C</strong>：授权服务器认证用户名和密码信息正确后，然后返回客户端access_token等信息，这里是以<strong>JSON</strong>的方式返回，类似授权码方式时返回的JSON</p><p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p><h2 id="客户端凭证"><a class="markdownIt-Anchor" href="#客户端凭证"></a> 客户端凭证</h2><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向&quot;服务提供商&quot;进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求&quot;服务提供商&quot;提供服务，其实不存在授权问题。如下图：<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/oauth2/4.png"  alt="客户端凭证" /></p><p><strong>A</strong>：客户端直接向授权服务器发起认证请求，URI如下：</p><blockquote><p><code>https://authorization-server/token?grant_type=client_credentials&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET</code></p></blockquote><p>上面 URL 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让 authorization-server 确认 client 的身份</p><p><strong>B</strong>：authorization-server 网站验证通过以后，直接返回令牌。</p><p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p><p>好了，OAuth 2.0 到这里就差不多了，更多的内容请访问<a href="https://oauth.net/2/" target="_blank" rel="noopener">官网</a></p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p><a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth 2.0官网</a></p>]]></content>
      
      
      <categories>
          
          <category> 权限 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro入门</title>
      <link href="/posts/43cf7ac5/"/>
      <url>/posts/43cf7ac5/</url>
      
        <content type="html"><![CDATA[<h1 id="shiro-简介"><a class="markdownIt-Anchor" href="#shiro-简介"></a> Shiro 简介</h1><p>Apache Shiro 是 Java 的一个安全框架。目前，使用 Apache Shiro 的人越来越多，因为它相当简单，对比 Spring Security，可能没有 Spring Security 做的功能强大，但是在实际工作时可能并不需要那么复杂的东西，所以使用小而简单的 Shiro 就足够了。对于它俩到底哪个好，这个不必纠结，能更简单的解决项目问题就好了。</p><h2 id="shiro基本功能"><a class="markdownIt-Anchor" href="#shiro基本功能"></a> Shiro基本功能</h2><p>Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。Shiro 可以帮助我们完成：认证、授权、加密、会话管理、与 Web 集成、缓存等。这不就是我们想要的嘛，而且 Shiro 的 API 也是非常简单；其基本功能点如下图所示：<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/shiro/1.png"  alt="Shiro基本功能" /><br /><strong>Authentication</strong>：身份认证 / 登录，验证用户是不是拥有相应的身份；</p><p><strong>Authorization</strong>：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</p><p><strong>Session Management</strong>：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；</p><p><strong>Cryptography</strong>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</p><p><strong>Web Support</strong>：Web 支持，可以非常容易的集成到 Web 环境；</p><p><strong>Caching</strong>：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率；</p><p><strong>Concurrency</strong>：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</p><p><strong>Testing</strong>：提供测试支持；</p><p><strong>Run As</strong>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</p><p><strong>Remember Me</strong>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</p><p><strong>注：记住一点，Shiro 不会去维护用户、维护权限；这些需要我们自己去设计 / 提供；然后通过相应的接口注入给 Shiro 即可。</strong></p><h2 id="shiro架构"><a class="markdownIt-Anchor" href="#shiro架构"></a> Shiro架构</h2><p>接下来我们分别从外部和内部来看看 Shiro 的架构，对于一个好的框架，从外部来看应该具有非常简单易于使用的 API，且 API 契约明确；从内部来看的话，其应该有一个可扩展的架构，即非常容易插入用户自定义实现，因为任何框架都不能满足所有需求。</p><h2 id="从外部看"><a class="markdownIt-Anchor" href="#从外部看"></a> 从外部看</h2><p>首先，我们从外部来看 Shiro 吧，即从应用程序角度的来观察如何使用 Shiro 完成工作。如下图：<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/shiro/2.png"  alt="Shiro架构-外部" /><br />可以看到：应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject；其每个 API 的含义：</p><p><strong>Subject</strong>：主体，代表了当前 “用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；</p><p><strong>SecurityManager</strong>：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；</p><p><strong>Realm</strong>：域，Shiro 从从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。</p><p>也就是说对于我们而言，最简单的一个 Shiro 应用：</p><p>应用代码通过 Subject 来进行认证和授权，而 Subject 又委托给 SecurityManager；</p><p>我们需要给 Shiro 的 SecurityManager 注入 Realm，从而让 SecurityManager 能得到合法的用户及其权限进行判断。<br /><strong>从以上也可以看出，Shiro 不提供维护用户 / 权限，而是通过 Realm 让开发人员自己注入。</strong></p><h2 id="从内部看"><a class="markdownIt-Anchor" href="#从内部看"></a> 从内部看</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/shiro/3.png"  alt="Shiro架构-内部" /><br /><strong>Subject</strong>：主体，可以看到主体可以是任何可以与应用交互的 “用户”；</p><p><strong>SecurityManager</strong>：相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。</p><p><strong>Authenticator</strong>：认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</p><p><strong>Authrizer</strong>：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</p><p><strong>Realm</strong>：可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户 / 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm；</p><p><strong>SessionManager</strong>：如果写过 Servlet 就应该知道 Session 的概念，Session 呢需要有人去管理它的生命周期，这个组件就是 SessionManager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所有呢，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）；</p><p><strong>SessionDAO</strong>：DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能；</p><p><strong>CacheManager</strong>：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</p><p><strong>Cryptography</strong>：密码模块，Shiro 提高了一些常见的加密组件用于如密码加密 / 解密的。</p><h1 id="shiro使用"><a class="markdownIt-Anchor" href="#shiro使用"></a> Shiro使用</h1><p>下面简单简绍一下在SpringBoot如何使用。<br /><strong>第一步</strong>：添加包引用。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!--shiro--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第二步</strong>：创建 Realm</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = (String) token.getPrincipal();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"admin"</span>.equals(username)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException(<span class="string">"账户不存在!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(username, <span class="string">"123"</span>, getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Realm 中实现简单的认证操作即可，不做授权，授权的具体写法可以参考：<a href="https://www.w3cschool.cn/shiro/hzlw1ifd.html" target="_blank" rel="noopener">Shiro Realm 介绍</a>。这里的认证表示用户名必须是 admin ，用户密码必须是 123 ，满足这样的条件，就能登录成功！</p><p><strong>第三步</strong> 配置 Shiro 基本信息<br />接下来在 application.properties 中配置 Shiro 的基本信息：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">shiro.sessionManager.sessionIdCookieEnabled=true</span><br><span class="line">shiro.sessionManager.sessionIdUrlRewritingEnabled=true</span><br><span class="line">shiro.unauthorizedUrl=/unauthorizedurl</span><br><span class="line">shiro.web.enabled=true</span><br><span class="line">shiro.successUrl=/index</span><br><span class="line">shiro.loginUrl=/login</span><br></pre></td></tr></table></figure><p>配置解释：</p><ul><li>第一行表示是否允许将sessionId 放到 cookie 中</li><li>第二行表示是否允许将 sessionId 放到 Url 地址拦中</li><li>第三行表示访问未获授权的页面时，默认的跳转路径</li><li>第四行表示开启 shiro</li><li>第五行表示登录成功的跳转页面</li><li>第六行表示登录页面</li></ul><p>再配置 ShiroConfig</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MyRealm <span class="title">myRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRealm();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DefaultWebSecurityManager <span class="title">securityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager manager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        manager.setRealm(myRealm());</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">ShiroFilterChainDefinition <span class="title">shiroFilterChainDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultShiroFilterChainDefinition definition = <span class="keyword">new</span> DefaultShiroFilterChainDefinition();</span><br><span class="line">        definition.addPathDefinition(<span class="string">"/doLogin"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        definition.addPathDefinition(<span class="string">"/**"</span>, <span class="string">"authc"</span>);</span><br><span class="line">        <span class="keyword">return</span> definition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里进行 Shiro 的配置主要配置 3 个 Bean ：</p><ul><li>首先需要提供一个 Realm 的实例。</li><li>需要配置一个 SecurityManager，在 SecurityManager 中配置 Realm。</li><li>配置一个 ShiroFilterChainDefinition ，在 ShiroFilterChainDefinition 中指定路径拦截规则等。</li></ul><p>这样就基本上完成了。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p><a href="https://www.w3cschool.cn/shiro/" target="_blank" rel="noopener">跟我学Shiro - w3cschool</a></p>]]></content>
      
      
      <categories>
          
          <category> 权限 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS单点登录</title>
      <link href="/posts/b6c57655/"/>
      <url>/posts/b6c57655/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>在日常生活中，很多人由于忘记某些网站的登录密码而烦恼，因为大多数用户都要记忆不少于10个用户名和相应密码。为了便于记忆，很多人都在不同的站点使用相同的用户名和密码，虽然这样可以减少负担，但是同时也降低了安全性，而且使用不同的站点同样要进行多次登录。同时，随着信息化飞速发展，大型企业和政府部门等都开始使用电子系统进行办公，而且整个办公系统由多个不同的子系统构成，如办公自动化(OA)系统，财务管理系统，档案管理系统，信息查询系统等。如果每个系统都使用独立的登录和验证机制，那么每天工作人员都要登录不同的系统进行办公。用户登录的频繁操作，降低了员工的工作效率，造成工作成本的浪费。而大量的密码和用户名的记忆时间长了也会出现问题，忘记密码或者混淆密码都会造成很大的麻烦。基于以上原因，为用户提供一个畅通的登录通道就变得十分重要。</p><h1 id="ssosinglesign-on单点登录"><a class="markdownIt-Anchor" href="#ssosinglesign-on单点登录"></a> SSO(SingleSign-On，单点登录)</h1><h2 id="sso简介"><a class="markdownIt-Anchor" href="#sso简介"></a> SSO简介</h2><p>SSO是一种帮助用户快捷访问网络中多个站点的安全通信技术。单点登录系统基于一种安全的通信协议，该协议通过多个系统之间的用户身份信息的交换来实现单点登录。使用单点登录系统时，用户只需要登录一次，就可以访问多个系统，不需要记忆多个口令密码。单点登录使用户可以快速访问网络，从而提高工作效率，同时也能帮助提高系统的安全性。</p><p>在SSO体系中，主要包括三部分：</p><ul><li>User （多个）</li><li>Web 应用（多个）</li><li>SSO 认证中心（ 1 个）</li></ul><p>而SSO的实现基本核心原则如下：</p><ul><li>所有的登录都在 SSO 认证中心进行</li><li>SSO 认证中心通过一些方法来告诉 Web 应用当前访问用户究竟是不是已通过认证的用户</li><li>SSO 认证中心和所有的 Web 应用建立一种信任关系， SSO 认证中心对用户身份正确性的判断会通过某种方法告之 Web 应用，而且判断结果必须被 Web 应用信任。</li></ul><h2 id="sso原理"><a class="markdownIt-Anchor" href="#sso原理"></a> SSO原理</h2><h3 id="登录"><a class="markdownIt-Anchor" href="#登录"></a> 登录</h3><p>上面介绍我们知道，在SSO中有一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。那其他的系统如何访问受保护的资源？这里就是通过认证中心间接授权通过令牌来实现，当SSO验证了用户信息的正确性后，就会创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sso-cas/1.png"  alt="单点登录-登录" /></p><p>上面是一张SSO登录原理图，下面我们来分析一下具体的流程：</p><ol><li>首先用户访问系统1受保护的资源，系统1发现未登陆，跳转至SSO认证中心，并将自己的参数传递过去</li><li>SSO认证中心发现用户未登录，将用户引导至登录页面</li><li>用户输入用户名和密码提交至SSO认证中心</li><li>SSO认证中心校验用户信息，创建用户与SSO认证中心之间的会话，称为全局会话，同时创建授权令牌</li><li>SSO认证中心带着令牌跳转会最初的请求地址（系统1）</li><li>系统1拿到令牌，去SSO认证中心校验令牌是否有效</li><li>SSO认证中心校验令牌，返回有效，注册系统1的地址</li><li>系统1使用该令牌创建与用户的会话，称为局部会话，返回给用户受保护资源</li><li>用户访问系统2受保护的资源</li><li>系统2发现用户未登录，跳转至SSO认证中心，并将自己的地址作为参数传递过去</li><li>SSO认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</li><li>系统2拿到令牌，去SSO认证中心校验令牌是否有效</li><li>SSO认证中心校验令牌，返回有效，注册系统2地址</li><li>系统2使用该令牌创建与用户的局部会话，返回给用户受保护资源</li></ol><p>用户登录成功之后，会与SSO认证中心及各个子系统建立会话，用户与SSO认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过SSO认证中心，全局会话与局部会话有如下约束关系：</p><ul><li>局部会话存在，全局会话一定存在</li><li>全局会话存在，局部会话不一定存在</li><li>全局会话销毁，局部会话必须销毁</li></ul><h3 id="注销"><a class="markdownIt-Anchor" href="#注销"></a> 注销</h3><p>既然有登陆那么就自然有注销，单点登录也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁。原理图如下：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sso-cas/2.png"  alt="单点登录-注销" /><br />SSO认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作</p><p>同样的我们也来分析一下具体的流程：</p><ol><li>用户向系统1发起注销请求</li><li>系统1根据用户与系统1建立的会话id拿到令牌，向SSO认证中心发起注销请求</li><li>SSO认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址</li><li>SSO认证中心向所有注册系统发起注销请求</li><li>各注册系统接收SSO认证中心的注销请求，销毁局部会话</li><li>SSO认证中心引导用户至登录页面</li></ol><p>上面的关于SSO原理部分参考单点登录原理与简单实现，如果不太理解可以去看看<a href="https://www.cnblogs.com/ywlaker/p/6113927.html" target="_blank" rel="noopener"><em>原文</em></a>。</p><h1 id="cas"><a class="markdownIt-Anchor" href="#cas"></a> CAS</h1><h2 id="cas介绍"><a class="markdownIt-Anchor" href="#cas介绍"></a> CAS介绍</h2><p>CAS全称为Central Authentication Service即中央认证服务，是一个企业多语言单点登录的解决方案，并努力去成为一个身份验证和授权需求的综合平台。</p><p>CAS是由Yale大学发起的一个企业级的、开源的项目，旨在为Web应用系统提供一种可靠的单点登录解决方法（属于 Web SSO ）。</p><p>CAS协议至少涉及三方：客户端Web浏览器，请求身份验证的Web应用程序和CAS服务器。 它也可能涉及后端服务，如数据库服务器，它没有自己的HTTP接口，但与Web应用程序进行通信。</p><p><strong>主要特征</strong>：</p><ul><li><p>多种的协议的支持，包括CAS (v1、v2、v3)、SAML(v1、v2)、OAuth、OpenID、OpenID Connect和WS-Federation Passive Requestor</p></li><li><p>多种认证机制，可以通过JAAS，LDAP，RDBMS，X.509，Radius，SPNEGO，JWT，Remote，Trusted，BASIC，Apache Shiro，MongoDB，Pac4J等进行身份验证</p></li><li><p>可以通过WS-FED，Facebook，Twitter，SAML IdP，OpenID，OpenID Connect，CAS等代理委派认证</p></li><li><p>多种形式的授权包括ABAC, Time/Date, REST, Internet2’s Grouper等</p></li><li><p>同时也支持HAZELCAST、EHCache、JPA、MycCache、Apache IGITE、MangGDB、ReDIS、DimoDoB、Couchbase等实现高可用多个集群部署</p></li><li><p>各种丰富的客户端，像常见的Java、Python、Node、PHP、C#、Perl等等</p></li></ul><p>下面是CAS相关的一些网址：<br /><a href="https://github.com/apereo/cas" target="_blank" rel="noopener">Github</a>、<a href="https://github.com/apereo/cas/tags" target="_blank" rel="noopener">下载链接</a>、<a href="https://apereo.github.io/cas/5.2.x/index.html" target="_blank" rel="noopener">开发文档</a>、<a href="https://www.apereo.org/projects/cas" target="_blank" rel="noopener">CAS官网</a></p><h2 id="cas基本原理"><a class="markdownIt-Anchor" href="#cas基本原理"></a> CAS基本原理</h2><p>CAS的结构中主要分两部分，一部分是CAS Server，另一部分是CAS Client。</p><ul><li><p>CAS Server：CAS Server 负责完成对用户的认证工作 , 需要独立部署 , CAS Server 会处理用户名 / 密码等凭证(Credentials)。</p></li><li><p>CAS Client：负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到 CAS Server 进行认证。（原则上，客户端应用不再接受任何的用户名密码等 Credentials ）。<br />下图是 CAS 最基本的协议过程<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sso-cas/3.png"  alt="CAS流程" /></p></li></ul><ol><li>访问服务：浏览器(Web Browser)发送请求访问应用系统(包含CAS Client的服务)提供的服务资源。</li><li>定向认证：应用系统会<strong>重定向</strong>用户请求到认证中心(CAS Server)。</li><li>用户认证：如果认证中心发现用户未认证，会跳转到用户认证界面，让用户进行身份认证。</li><li>发放票据：如果认证通过，认证中心会产生一个随机的Service Ticket发放给用户，并重定向用户请求到应用系统。</li><li>验证票据：应用系统拿Service Ticket去认证中心验证票据的合法性，验证通过后，允许客户端访问服务。</li><li>传输用户信息：最后认证中心传输用户认证结果信息给应用系统。</li></ol><h2 id="cas两种模式"><a class="markdownIt-Anchor" href="#cas两种模式"></a> CAS两种模式</h2><p>CAS有两种模式：基础模式和代理模式<br />基础模式适用于：参与SSO的应用都为Web应用且各应用之间相互独立。<br />代理模式适用于：参与SSO的应用存在非Web应用（CAS基本模式会用到Cookie）或者应用之间存在集成关系。</p><h3 id="基础模式"><a class="markdownIt-Anchor" href="#基础模式"></a> 基础模式</h3><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sso-cas/4.png"  alt="CAS基础模式" /><br />如上图：首先用户访问受保护的资源，权限没有认证，所以会把请求的URL以参数跳转到CAS认证中心，CAS认证中心发现没有SSO session，所以弹出登录页面，输入用户信息，提交到CAS认证中心进行信息的认证，如果信息正确，CAS认证中心就会创建一个SSO session和CASTGC cookie，这个CASTGC cookie包含了TGT，而用户session则以TGT为key创建，同时服务端会分发一个ST返回给用户。用户拿到了ST后，访问带参数ST的资源地址，同时应用将ST发送给CAS认证中心，CAS认证中心对ST进行校验，同时判断相应的cookie（包含TGT）是否正确（通过先前设定的key），判断ST是否是有效的，结果会返回一个包含成功信息的XML给应用。应用在建立相应的session和cookie跳转到浏览器，用户再通过浏览器带cookie去应用访问受保护的资源地址，cookie和后端session验证成功便可以成功访问到信息。</p><p>第二次访问应用时，浏览器就会携带相应的cookie信息，后台session验证用户是否登录，与一般单系统应用登录模式一样。</p><p>当我们访问其他的应用，与前面的步骤也是基本相同，首先用户访问受保护的资源，跳转回浏览器，浏览器含有先前登录的CASTGC cookie，CASTGC cookie包含了TGT并发送到CAS认证中心，CAS认证中心校验TGT是否有效，如果有效分发浏览器一个带ST参数的资源地址URL，应用程序拿到ST后，再发送给CAS认证中心，如果认证了ST有效后，结果会返回一个包含成功信息的XML给应用。同样的步骤，应用在建立相应的session和cookie跳转到浏览器，用户再通过浏览器带cookie去应用访问受保护的资源地址，验证session成功便可以成功访问到信息。</p><h3 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h3><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/sso-cas/5.png"  alt="CAS代理模式" /><br />如上图代理模式分两步</p><ol><li>加载代理应用</li></ol><p>首先用户访问代理地址，权限没有认证，所以会把请求的URL以参数跳转到CAS认证中心，CAS认证中心发现没有SSO session，所以弹出登录页面，输入用户信息，提交到CAS认证中心进行信息的认证，如果信息正确，CAS认证中心就会创建一个SSO session——CASTGC cookie，这个CASTGC cookie包含了TGT，这个TGT作为一个用户session，它会分发一个ST返回给用户。用户拿到了ST后，访问带参数ST的代理地址，代理地址将ST发送给CAS认证中心并且带一个pgtUrl，这是请求一个PGT的回调URL。CAS认证中通过调用回调PGT URL将TGT和PGTIOU传递给代理地址，代理地址匹配存储PGTIOU和PGT并执行下一步，然后CAS返回一个PGTIOU给代理匹配刚刚存储是PGTIOU与PGT是否一致。后面就通过PGTIOU查找PGT，然后代理地址在建立相应的session cookie跳转到浏览器，用户再通过浏览器带cookie去访问代理地址。</p><ol start="2"><li>通过代理访问应用</li></ol><p>通过代理访问应用，在浏览器中通过携带相应的cookie去访问代理，然后验证session cookie的有效性，然后再代理地址通过PGT跳转到CAS认证中心，认证中心再通过代理地址访问应用，相同的步骤，应用发送ST给CAS认证中心，检验proxy ticket是否有效，如何有效返回给应用一个XML信息。在应用中查询代理URL是否可信赖，阻止代理用户非法的行为。然后应用再建立相应的session cookie跳转到代理地址，代理地址再带cookie去访问应用，并验证是否正确。如果正确，则应用响应代理地址的请求，代理地址再把请求发送给用户。</p><h2 id="cas术语概念"><a class="markdownIt-Anchor" href="#cas术语概念"></a> CAS术语概念</h2><h3 id="cas-系统中的票据-tgc-tgt-st-pgt-pgtiou-pt"><a class="markdownIt-Anchor" href="#cas-系统中的票据-tgc-tgt-st-pgt-pgtiou-pt"></a> CAS 系统中的票据： TGC、TGT 、 ST 、 PGT 、 PGTIOU 、 PT 。</h3><ol><li><p>TGC（ticket-granting cookie）<br />授权的票据证明，由 CAS Server 通过 SSL 方式发送给终端用户，存放用户身份认证凭证的Cookie，在浏览器和CAS Server间通讯时使用，并且只能基于安全通道传输（Https），是CAS Server用来明确用户身份的凭证。</p></li><li><p>TGT（Ticket Grangting Ticket）<br />TGT是CAS为用户签发的登录票据，拥有了TGT，用户就可以证明自己在CAS成功登录过。TGT封装了Cookie值以及此Cookie值对应的用户信息。用户在CAS认证成功后，CAS生成Cookie（叫TGC），写入浏览器，同时生成一个TGT对象，放入自己的缓存，TGT对象的ID就是Cookie的值。当HTTP再次请求到来时，如果传过来的有CAS生成的Cookie，则CAS以此Cookie值为key查询缓存中有无TGT ，如果有的话，则说明用户之前登录过，如果没有，则用户需要重新登录。</p></li><li><p>ST（Service Ticket）<br />ST是CAS为用户签发的访问某一service的票据。用户访问service时，service发现用户没有ST，则要求用户去CAS获取ST。用户向CAS发出获取ST的请求，如果用户的请求中包含Cookie，则CAS会以此Cookie值为key查询缓存中有无TGT，如果存在TGT，则用此TGT签发一个ST，返回给用户。用户凭借ST去访问service，service拿ST去CAS验证，验证通过后，允许用户访问资源。</p></li><li><p>PGT（Proxy Granting Ticket）<br />Proxy Service的代理凭据。用户通过CAS成功登录某一Proxy Service后，CAS生成一个PGT对象，缓存在CAS本地，同时将PGT的值（一个UUID字符串）回传给Proxy Service，并保存在Proxy Service里。Proxy Service拿到PGT后，就可以为Target Service（back-end service）做代理，为其申请PT。</p></li><li><p>PGTIOU（Proxy Granting Ticket I Owe You）<br />PGTIOU是CAS协议中定义的一种附加票据，它增强了传输、获取PGT的安全性。<br />PGT的传输与获取的过程：Proxy Service调用CAS的serviceValidate接口验证ST成功后，CAS首先会访问pgtUrl指向的Https URL，将生成的 PGT及PGTIOU传输给proxy service，proxy service会以PGTIOU为key，PGT为value，将其存储在Map中；然后CAS会生成验证ST成功的XML消息，返回给Proxy Service，XML消息中含有PGTIOU，proxy service收到XML消息后，会从中解析出PGTIOU的值，然后以其为key，在Map中找出PGT的值，赋值给代表用户信息的Assertion对象的pgtId，同时在Map中将其删除。</p></li><li><p>PT（Proxy Ticket）<br />PT是用户访问Target Service（back-end service）的票据。如果用户访问的是一个Web应用，则Web应用会要求浏览器提供ST，浏览器就会用Cookie去CAS获取一个ST，然后就可以访问这个Web应用了。如果用户访问的不是一个Web应用，而是一个C/S结构的应用，因为C/S结构的应用得不到Cookie，所以用户不能自己去CAS获取ST，而是通过访问proxy service的接口，凭借proxy service的PGT去获取一个PT，然后才能访问到此应用。</p></li></ol><h3 id="tgt-st-pgt-pt之间关系"><a class="markdownIt-Anchor" href="#tgt-st-pgt-pt之间关系"></a> TGT、ST、PGT、PT之间关系</h3><ul><li>ST是TGT签发的。用户在CAS上认证成功后，CAS生成TGT，用TGT签发一个ST，ST的ticketGrantingTicket属性值是TGT对象，然后把ST的值redirect到客户应用。</li><li>PGT是ST签发的。用户凭借ST去访问Proxy service，Proxy service去CAS验证ST（同时传递PgtUrl参数给CAS），如果ST验证成功，则CAS用ST签发一个PGT，PGT对象里的ticketGrantingTicket是签发ST的TGT对象。</li><li>PT是PGT签发的。Proxy service代理back-end service去CAS获取PT的时候，CAS根据传来的pgt参数，获取到PGT对象，然后调用其grantServiceTicket方法，生成一个PT对象。</li></ul><h3 id="其他概念"><a class="markdownIt-Anchor" href="#其他概念"></a> 其他概念</h3><ul><li><p>KDC(Key Distribution Center)----------密钥发放中心；</p></li><li><p>Authentication Service (AS) --------- 认证服务，索取Crendential ，发放 TGT；</p></li><li><p>Ticket-Granting Service (TGS) --------- 票据授权服务，索取TGT ，发放ST。</p></li></ul><h1 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h1><p><a href="https://baike.baidu.com/item/SSO/3451380" target="_blank" rel="noopener">SSO百度百科</a><br /><a href="https://blog.csdn.net/Anumbrella/java/article/details/80821486" target="_blank" rel="noopener">初识SSO</a></p>]]></content>
      
      
      <categories>
          
          <category> 权限 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> SSO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RBAC权限模型</title>
      <link href="/posts/37cc241/"/>
      <url>/posts/37cc241/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>权限对于每个系统都非常重要，现有的系统的权限管理基本都是基于RBAC来实现的，所以我们应该学习RBAC。</p><h1 id="什么是rbac模型"><a class="markdownIt-Anchor" href="#什么是rbac模型"></a> 什么是RBAC模型</h1><p>RBAC是Role-Based Access Control的英文缩写，意思是基于角色的访问控制。<br />RBAC认为权限授权实际上是Who、What、How的问题。在RBAC模型中，who、what、how构成了访问权限三元组，也就是“Who对What(Which)进行How的操作，也就是“主体”对“客体”的操作，其中who——是权限的拥有者或主体（如：User、Role），what——是资源或对象（Resource、Class)</p><p>RBAC其实是一种分析模型，主要分为：</p><ul><li>基本模型RBAC0（Core RBAC）</li><li>角色分层模型RBAC1（Hierarchal RBAC）</li><li>角色限制模型RBAC2（Constraint RBAC）</li><li>统一模型RBAC3（Combines RBAC）。</li></ul><h2 id="rbac0"><a class="markdownIt-Anchor" href="#rbac0"></a> RBAC0</h2><p>RBAC0，它是RBAC的核心，RBAC1、RBAC2、RBAC3都是先后在RBAC0上的扩展。RBAC0定义了能构成RBAC控制系统的最小的元素集合，RBAC0由四部分构成：</p><ul><li>用户（User）</li><li>角色（Role）</li><li>会话（Session）</li><li>许可（Pemission）</li></ul><p>其中许可又包括“操作”和“控制对象”其中许可被赋予角色，而不是用户，当一个角色被指定给一个用户时，此用户就拥有了该角色所包含的许可。会话是动态的概念，用户必须通过会话才可以设置角色，是用户与激活的角色之间的映射关系。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/rbac/1.png"  alt="RBAC0" title="RBAC0" /></p><p>图中，用户与角色是多对多的关系；角色和许可也是多对多的关系；用户与会话是一对一关系；会话与角色是一对多关系；</p><h2 id="rbac1"><a class="markdownIt-Anchor" href="#rbac1"></a> RBAC1</h2><p>RBAC1，它是RBAC角色的分层模型，RBAC1建立在RBAC0基础之上，在角色中引入了继承的概念，有了继承那么角色就有了上下级或者等级关系，角色间的继承关系可分为一般继承关系和受限继承关系。一般继承关系仅要求角色继承关系是一个绝对偏序关系，允许角色间的多继承。而受限继承关系则进一步要求角色继承关系是一个树结构，实现角色间的单继承。</p><p>这种模型合适于角色之间的层次明确，包含明确。<br /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/rbac/2.png"  alt="RBAC1" title="RBAC1" /></p><h2 id="rbac2"><a class="markdownIt-Anchor" href="#rbac2"></a> RBAC2</h2><p>RBAC2，它是RBAC的约束模型，RBAC2也是建立的RBAC0的基础之上的，在RBAC0基础上假如了约束的概念，主要引入了静态职责分离SSD(Static Separation of Duty)和动态职责分离DSD(Dynamic Separation of Duty)。</p><p>SSD是用户和角色的指派阶段加入的，主要是对用户和角色有如下约束:</p><ul><li>互斥角色：同一个用户在两个互斥角色中只能选择一个</li><li>基数约束：一个用户拥有的角色是有限的，一个角色拥有的许可也是有限的</li><li>先决条件约束：用户想要获得高级角色，首先必须拥有低级角色</li></ul><p>DSD是会话和角色之间的约束，可以动态的约束用户拥有的角色，如一个用户可以拥有两个角色，但是运行时只能激活一个角色。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/rbac/3.png"  alt="RBAC2" title="RBAC2" /></p><h2 id="rbac3"><a class="markdownIt-Anchor" href="#rbac3"></a> RBAC3</h2><p>RBAC3，它是RBAC1与RBAC2合集，所以RBAC3是既有角色分层又有约束的一种模型</p><p>以上就是RBAC模型的四种设计思想，在使用中根据系统需要做相应的修改。</p><h1 id="rbac新解"><a class="markdownIt-Anchor" href="#rbac新解"></a> RBAC新解</h1><p>有两种正使用的 RBAC 控制方式：隐式(模糊)的方式和显示(明确)的方式</p><h2 id="隐式模糊的方式"><a class="markdownIt-Anchor" href="#隐式模糊的方式"></a> 隐式(模糊)的方式</h2><p>不能明确的知道一个角色到底关联了哪些可执行操作，直接通过角色来验证用户有没有操作权限<br />例如：“超级管理员”角色能新建用户</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(hasRole(<span class="string">"admin"</span>))&#123;</span><br><span class="line">  <span class="comment">// show add user button</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种权限访问控制是非常脆弱的，一个极小的权限方面的需求变动都可能导致上面的代码需要重新修改<br />假如：需要新增“部门管理员”角色，也能新增用户</p><p>这种方式就是基于角色的访问控制：（Role-Based Access Control）</p><h2 id="显示明确的方式"><a class="markdownIt-Anchor" href="#显示明确的方式"></a> 显示(明确)的方式</h2><p>明确定义一个角色能对哪些资源进行什么操作<br />例如：如果当前用户有新建用户的权限则显示新建按钮</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接判断是否拥有权限</span></span><br><span class="line"><span class="keyword">if</span>(user.hasPermission(<span class="string">"user:add"</span>))&#123;</span><br><span class="line">  <span class="comment">// show add user button</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显式的权限控制方式的好处"><a class="markdownIt-Anchor" href="#显式的权限控制方式的好处"></a> 显式的权限控制方式的好处</h2><h3 id="更少的代码重构"><a class="markdownIt-Anchor" href="#更少的代码重构"></a> 更少的代码重构</h3><p>系统的功能需求一旦确定下来后，一段时间内对它的改动相应还是比较少的。<br />显式的权限控制方式不会因不同的角色要对功能进行操作而修改功能代码</p><h3 id="更直观"><a class="markdownIt-Anchor" href="#更直观"></a> 更直观</h3><p>保护资源对象、控制对资源对象的操作。<br />这样的权限控制方式更符合人们的思想习惯。</p><h3 id="更有弹性"><a class="markdownIt-Anchor" href="#更有弹性"></a> 更有弹性</h3><p>可支持任何安全模型的设计。<br />例如：将操作(权限)直接分配给角色，或者将多个角色关联到组(group)上。</p><h3 id="外部安全策略管理"><a class="markdownIt-Anchor" href="#外部安全策略管理"></a> 外部安全策略管理</h3><p>资源/行为与用户、组、角色的关联可以通过外部的模块或专用工具或管理控制台来完成</p><h3 id="可在运行环境做修改"><a class="markdownIt-Anchor" href="#可在运行环境做修改"></a> 可在运行环境做修改</h3><p>因为基于资源的权限控制代码并不依赖于行为的主体(如组、角色、用户等)（没有将行为的主体的字符名词写在代码中），所以你甚至可以在程序运行的时候通过修改主体能对资源进行的操作，通过配置的方式就可应对权限方面需求的变动，不需要重构代码。</p><p>这种显式的机制带给我们的富有弹性的权限模型。在这种新的模型下，已不必再局限于角色了，你可以将权限直接分配给用户、组或其它对象。</p><p>这种方式就是基于资源的访问控制：（Resource-Based Access Control），也就是所谓的RBAC新解。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ol><li><a href="https://baike.so.com/doc/5499468-5736904.html" target="_blank" rel="noopener">百科RBAC</a></li><li><a href="https://blog.csdn.net/yangwenxue_admin/article/details/73936803" target="_blank" rel="noopener">权限系统与RBAC模型概述</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 权限 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RBAC </tag>
            
            <tag> 权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java后端学习路线图</title>
      <link href="/posts/a7645600/"/>
      <url>/posts/a7645600/</url>
      
        <content type="html"><![CDATA[<h1 id="java后端学习"><a class="markdownIt-Anchor" href="#java后端学习"></a> JAVA后端学习</h1><h2 id="计算机基础知识"><a class="markdownIt-Anchor" href="#计算机基础知识"></a> 计算机基础知识</h2><ul><li>操作系统</li><li>网络</li><li>网络传输协议</li><li>数据结构</li><li>算法</li><li>进程、线程</li><li>linux基础</li></ul><h2 id="常用工具"><a class="markdownIt-Anchor" href="#常用工具"></a> 常用工具</h2><ul><li>Git</li><li>IDEA、VSCode</li><li>JMC</li><li>Linux分析工具</li><li>Maven、Gradle</li></ul><h2 id="java基础知识"><a class="markdownIt-Anchor" href="#java基础知识"></a> JAVA基础知识</h2><ul><li>JAVA基础</li><li>多线程</li><li>JVM</li></ul><h2 id="前端"><a class="markdownIt-Anchor" href="#前端"></a> 前端</h2><ul><li>HTML</li><li>CSS</li><li>JavaScript</li><li>Ajax</li><li>JSON</li><li>Vue</li><li>Node.js</li></ul><h2 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h2><ul><li>MySQL、Oracle</li><li>分库分表：Sharding-Sphere、Mycat、Sharding-JDBC</li></ul><h2 id="基本框架"><a class="markdownIt-Anchor" href="#基本框架"></a> 基本框架</h2><ul><li>Spring</li><li>SpringMVC</li><li>MyBatis</li><li>SpringBoot</li></ul><h2 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h2><ul><li>消息队列基础</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li><li>ActiveMQ</li><li>分布式事务</li></ul><h2 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h2><ul><li>Redis</li><li>Memcache</li><li>MongoDB</li></ul><h2 id="其他框架"><a class="markdownIt-Anchor" href="#其他框架"></a> 其他框架</h2><ul><li>ElasticSearch</li><li>Canal</li><li>Kibana</li><li>Lucene</li><li>Logstash</li></ul><h2 id="大数据"><a class="markdownIt-Anchor" href="#大数据"></a> 大数据</h2><ul><li>ODPS</li><li>Hadoop</li><li>Hive</li><li>Hbase</li><li>Cassandra</li><li>Fllink</li><li>Spark</li></ul><h2 id="rpc"><a class="markdownIt-Anchor" href="#rpc"></a> RPC</h2><ul><li>Dubbo</li><li>SpringCloud</li><li>Netty</li></ul><h2 id="网关"><a class="markdownIt-Anchor" href="#网关"></a> 网关</h2><ul><li>Nginx</li><li>LVS</li><li>Apache</li><li>Zookeeper</li><li>CDN</li></ul><h2 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h2><ul><li>Docker</li><li>K8s</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/posts/5d36ff15/"/>
      <url>/posts/5d36ff15/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br />Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。<br />Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。<br />Markdown 编写的文档后缀为 .md, .markdown。</p></blockquote><h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h1><h2 id="标题"><a class="markdownIt-Anchor" href="#标题"></a> 标题</h2><p>Markdown 标题有两种格式。</p><h3 id="使用-和-标记一级和二级标题"><a class="markdownIt-Anchor" href="#使用-和-标记一级和二级标题"></a> 使用 = 和 - 标记一级和二级标题</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">我是一级标题  </span><br><span class="line">=================</span><br><span class="line"></span><br><span class="line">我的是二级标题  </span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure><p>效果如下：<br /><img src='https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/markdown/1.jpg' align='left'/></p><h3 id="使用-号标记"><a class="markdownIt-Anchor" href="#使用-号标记"></a> 使用 # 号标记</h3><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><p>效果如下：<br /><img src='https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/markdown/2.jpg' align='left'/></p><h2 id="段落与格式"><a class="markdownIt-Anchor" href="#段落与格式"></a> 段落与格式</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。<br />也可以在段落后面使用一个空行来表示重新开始一个段落。</p><h3 id="字体"><a class="markdownIt-Anchor" href="#字体"></a> 字体</h3><p>Markdown 可以使用以下几种字体：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">***粗斜体文本**</span>*</span><br><span class="line"><span class="strong">___粗斜体文本__</span>_</span><br></pre></td></tr></table></figure><p><em>斜体文本</em><br /><em>斜体文本</em><br /><strong>粗体文本</strong><br /><strong>粗体文本</strong><br /><em><strong>粗斜体文本</strong></em><br /><em><strong>粗斜体文本</strong></em></p><h3 id="分隔线"><a class="markdownIt-Anchor" href="#分隔线"></a> 分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="bullet">* </span><span class="emphasis">* *</span></span><br><span class="line"><span class="strong">*****</span></span><br><span class="line"><span class="bullet">- </span>- -</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><h3 id="删除线"><a class="markdownIt-Anchor" href="#删除线"></a> 删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~我是被删除的~~</span><br></pre></td></tr></table></figure><p>效果如下：<br /><s>我是被删除的</s></p><h3 id="下划线"><a class="markdownIt-Anchor" href="#下划线"></a> 下划线</h3><p>下划线可以通过 HTML 的<code>&lt;u&gt;&lt;/u&gt;</code>标签或者自定义样式来实现：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线文本<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"border-bottom:1px dashed black;"</span>&gt;</span></span>带下划线文本<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><u>带下划线文本</u><br /><span style="border-bottom:1px dashed black;">带下划线文本</span></p><h2 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h2><p>Markdown 支持有序列表和无序列表。</p><h3 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表"></a> 无序列表</h3><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>第一项</span><br><span class="line"><span class="bullet">* </span>第二项</span><br><span class="line"><span class="bullet">* </span>第三项</span><br><span class="line"><span class="bullet">+ </span>第四项</span><br><span class="line"><span class="bullet">+ </span>第五项</span><br><span class="line"><span class="bullet">+ </span>第六项</span><br><span class="line"><span class="bullet">- </span>第七项</span><br><span class="line"><span class="bullet">- </span>第八项</span><br><span class="line"><span class="bullet">- </span>第九项</span><br></pre></td></tr></table></figure><p>效果如下：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第四项</li><li>第五项</li><li>第六项</li></ul><ul><li>第七项</li><li>第八项</li><li>第九项</li></ul><h3 id="有序列表"><a class="markdownIt-Anchor" href="#有序列表"></a> 有序列表</h3><p>有序列表使用数字并加上 . 号来表示，如：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>第一项</span><br><span class="line"><span class="bullet">2. </span>第二项</span><br><span class="line"><span class="bullet">3. </span>第三项</span><br></pre></td></tr></table></figure><p>效果如下：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="列表嵌套"><a class="markdownIt-Anchor" href="#列表嵌套"></a> 列表嵌套</h3><p>列表嵌套只需在子列表中的选项添加四个空格即可：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>第一项：</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第二个元素</span><br><span class="line"><span class="bullet">2. </span>第二项：</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure><p>效果如下：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="区块"><a class="markdownIt-Anchor" href="#区块"></a> 区块</h2><h3 id="区块引用"><a class="markdownIt-Anchor" href="#区块引用"></a> 区块引用</h3><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块引用</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>区块引用</p></blockquote><h3 id="区块嵌套"><a class="markdownIt-Anchor" href="#区块嵌套"></a> 区块嵌套</h3><p>区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 最外层</span></span><br><span class="line"><span class="quote">&gt; &gt; 第一层嵌套</span></span><br><span class="line"><span class="quote">&gt; &gt; &gt; 第二层嵌套</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h3 id="区块中使用列表"><a class="markdownIt-Anchor" href="#区块中使用列表"></a> 区块中使用列表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块中使用列表</span></span><br><span class="line"><span class="quote">&gt; 1. 第一项</span></span><br><span class="line"><span class="quote">&gt; 2. 第二项</span></span><br><span class="line"><span class="quote">&gt; + 第一项</span></span><br><span class="line"><span class="quote">&gt; + 第二项</span></span><br><span class="line"><span class="quote">&gt; + 第三项</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h3 id="列表中使用区块"><a class="markdownIt-Anchor" href="#列表中使用区块"></a> 列表中使用区块</h3><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>第一项</span><br><span class="line"><span class="code">    &gt; 引用</span></span><br><span class="line"><span class="code">    &gt; 引用</span></span><br><span class="line"><span class="bullet">* </span>第二项</span><br></pre></td></tr></table></figure><p>效果如下：</p><ul><li>第一项<blockquote><p>引用<br />引用</p></blockquote></li><li>第二项</li></ul><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><h3 id="行内代码"><a class="markdownIt-Anchor" href="#行内代码"></a> 行内代码</h3><p>行内的一个函数或片段的代码可以用反引号（一个两个都行）把它包起来（`），例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">`console.log('这是一个行内代码')`</span> </span><br><span class="line"><span class="string">``</span><span class="built_in">console</span>.log(<span class="string">'这是一个行内代码'</span>)<span class="string">``</span></span><br></pre></td></tr></table></figure><p>效果如下：<br /><code>console.log('这是一个行内代码')</code><br /><code>console.log('这是一个行内代码')</code></p><h3 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h3><p>代码块使用 4 个空格、一个制表符（Tab 键）开头（前面要空一行）或者```（三个或以上） 包裹一段代码：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">  console.log('四个空格')</span><br><span class="line">  console.log('一个制表符')</span><br><span class="line"><span class="code">```</span> [代码语言]</span><br><span class="line">console.log('<span class="code">```</span> 包裹')  </span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><pre><code>console.log('四个空格')  console.log('一个制表符')  </code></pre>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'```包裹'</span>)</span><br></pre></td></tr></table></figure><h2 id="链接与图片"><a class="markdownIt-Anchor" href="#链接与图片"></a> 链接与图片</h2><h3 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h3><p>链接使用方法如下：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  [链接名称](链接地址)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure><p>例如：</p>  <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">百度一下</span>](<span class="link">https://www.baidu.com/</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">https:</span>//<span class="attr">www.baidu.com</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果如下：<br /><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度一下</a><br /><a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></p><p>我们也可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p>  <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这里是 [<span class="string">Google</span>][<span class="symbol">google</span>]，变量名google</span><br><span class="line">这里是 [<span class="string">百度</span>][<span class="symbol">baidu</span>]，变量名baidu</span><br><span class="line"> </span><br><span class="line"> 然后在文档的结尾为变量赋值（网址）：</span><br><span class="line"> [google]: http://www.google.com/</span><br><span class="line"> [baidu]: http://www.baidu.com/</span><br></pre></td></tr></table></figure><p>这里是 <a href="http://www.google.com/" target="_blank" rel="noopener">Google</a>，变量名google<br />这里是 <a href="http://www.baidu.com/" target="_blank" rel="noopener">百度</a>，变量名baidu</p><h3 id="图片"><a class="markdownIt-Anchor" href="#图片"></a> 图片</h3><p>图片语法格式如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">alt 属性文本</span>](<span class="link">图片地址 "可选标题"</span>)</span><br><span class="line">![<span class="string">Markdown图标</span>](<span class="link">https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/markdown/markdown.jpg "Markdown图标"</span>)</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/markdown/markdown.jpg"  alt="Markdown图标" title="Markdown图标" /><br />也可以用HTML标签：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">'markdown'</span> <span class="attr">src</span>=<span class="string">'https://cdn.jsdelivr.net/gh/lshaolin/repo@latest/img/post/markdown/markdown.jpg'</span> <span class="attr">align</span>=<span class="string">'left'</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="表格"><a class="markdownIt-Anchor" href="#表格"></a> 表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><p>语法格式如下：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>我们还可以设置表格的对齐方式：</p><ul><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。</li></ul><p>其中的&quot;-&quot;可以一个或者多个</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单 | 元 | 格 |</span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:right">右对齐</th><th style="text-align:center">居中对齐</th></tr></thead><tbody><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr><tr><td style="text-align:left">单</td><td style="text-align:right">元</td><td style="text-align:center">格</td></tr></tbody></table><h1 id="高级技巧"><a class="markdownIt-Anchor" href="#高级技巧"></a> 高级技巧</h1><h2 id="支持html元素"><a class="markdownIt-Anchor" href="#支持html元素"></a> 支持HTML元素</h2><p><strong>不在 Markdown 涵盖范围之内</strong> 的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。<br />需要注意的是区块元素比如 <code>&lt;div&gt;、 &lt;table&gt;、&lt;pre&gt;、 &lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。<br />行内标签如<code>&lt;span&gt;、 &lt;cite&gt;、&lt;del&gt; &lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>可以在 Markdown 的段落、列表或是标题里随意使用。<br />例如：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">del</span>&gt;</span></span>删除线<span class="xml"><span class="tag">&lt;/<span class="name">del</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果如下：<br /><del>删除线</del></p><h2 id="转义"><a class="markdownIt-Anchor" href="#转义"></a> 转义</h2><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号<br />例如：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**文本加粗**</span> </span><br><span class="line">\<span class="emphasis">*\*</span> 正常显示星号 \<span class="emphasis">*\*</span></span><br></pre></td></tr></table></figure><p>效果如下：<br /><strong>文本加粗</strong><br />** 正常显示星号 **</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line"><span class="bullet">*   </span>星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line"><span class="section">#   井字号</span></span><br><span class="line"><span class="bullet">+   </span>加号</span><br><span class="line"><span class="bullet">-   </span>减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure><h2 id="公式"><a class="markdownIt-Anchor" href="#公式"></a> 公式</h2><p>当你需要在编辑器中插入数学公式时，可以使用一个美元符 $ (行内)或两个美元符 $$ （独占一行）包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax或者KaTeX 对数学公式进行渲染。</p><h3 id="行内与独行"><a class="markdownIt-Anchor" href="#行内与独行"></a> 行内与独行</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">行内公式$x+y+z=0$</span><br><span class="line">独立行$$x+y+z=0$$</span><br></pre></td></tr></table></figure><p>行内公式： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x+y+z=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br />独立行：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x+y+z=0 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><h3 id="上标-下标与组合"><a class="markdownIt-Anchor" href="#上标-下标与组合"></a> 上标、下标与组合</h3><p>上标符号，符号：<code>^</code>，如：<code>$x^4$</code>，效果：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">x^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span><br />下标符号，符号：<code>_</code>，如：<code>$x_1$</code>，效果：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br />组合符号，符号：<code>{}</code>，如：<code>${x}^{2+}_{2}$</code>，效果：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mn>2</mn><mrow><mn>2</mn><mo>+</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">{x}^{2+}_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span></span></span></span></p><p>其他公式详情请参考：<a href="https://juejin.im/post/5a6721bd518825733201c4a2" target="_blank" rel="noopener">MarkDown 插入数学公式</a></p><h2 id="流程图"><a class="markdownIt-Anchor" href="#流程图"></a> 流程图</h2><h3 id="横向流程图"><a class="markdownIt-Anchor" href="#横向流程图"></a> 横向流程图</h3><blockquote><p>``` mermaid<br />graph LR<br />A[开始] --&gt;|链接文字| B(圆边)<br />B --&gt; C{条件x=?}<br />C --&gt;|x=1| D[结果1]<br />C --&gt;|x=2| E[结果2]<br />```</p></blockquote><p>效果如下：</p><div class="mermaid">          graph LR    A[开始] -->|链接文字| B(圆边)    B --> C{条件x=?}    C -->|x=1| D[结果1]    C -->|x=2| E[结果2]          </div><h3 id="竖向流程图"><a class="markdownIt-Anchor" href="#竖向流程图"></a> 竖向流程图</h3><blockquote><p>``` mermaid<br />graph TD<br />A[开始] --&gt;|链接文字| B(圆边)<br />B --&gt; C{条件x=?}<br />C --&gt;|x=1| D[结果1]<br />C --&gt;|x=2| E[结果2]<br />```</p></blockquote><div class="mermaid">          graph TD    A[开始] -->|链接文字| B(圆边)    B --> C{条件x=?}    C -->|x=1| D[结果1]    C -->|x=2| E[结果2]          </div><p>其他如 ：时序图、类别图、状态图、甘特图和圆形图请查看<a href="https://mermaid-js.github.io/mermaid/" target="_blank" rel="noopener">mermaid文档</a></p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ol><li><a href="https://www.markdownguide.org/" target="_blank" rel="noopener">Markdown</a></li><li><a href="https://mermaid-js.github.io/mermaid/" target="_blank" rel="noopener">mermaid文档</a></li><li><a href="https://www.w3cschool.cn/markdownyfsm/" target="_blank" rel="noopener">Markdown 语法说明</a></li><li><a href="https://juejin.im/post/5a6721bd518825733201c4a2" target="_blank" rel="noopener">MarkDown 插入数学公式</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
